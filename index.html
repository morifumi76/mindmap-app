<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó</title>
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAJsklEQVR4nO2Ye3AV1R3HP+fs7r1JIAnFEAgUaUdAU0CkoKiodUapdsRHVdRaKIjFVtqK1YqObX3805kKOGLro3YUcNqOjkCphZbpVEe0KmAdQRgpAmJFJUiAhOSS3MeeX/84Z3dv+iDBoP7R/c7c2b1zXr/n9/c7CylSpEiRIkWKFClSpEiRIkWKFP9nUJ/0AVs2b5JtW7fStGcPYgz1gwZxYuNJjD1l/Cd+dk/wiQjR0tIiDyy4j+W/X8H7+1uhoobKfv1RStF5qIVS2wEG1/bl0kunMPfWeTQ0DP7MjOEf6w2XLXtGxo4eRbH/55kwdS5TJp1H7XED0ZkMSinCYoG2A/t4e8OLPPn0r3li6RiWLlksM2Ze95kY4ZgeunD+fXLr7Xdyxb0PcfaVsygWS3S0t2NMEUQQQGuN1j6ZPn3wMwFvrlnO0ttmcvvNc/j5/Ps/dSMcswOXLlksM2bNZu5vn2fI2DNob96LVgq0tooLKGWPFBHEhIhAdV09TTu2sPCqs1j4s3u45dZ5n6oRjslh7+3eLScMO56p83/DqRddw8E976MyGfAUGiAExFlAAZIcXCzm6VffwPb1z/PodReybds/GDhoEL9buoRXX3mZPU1NZLMZGk9q5IKLLmLyV792TA10TDb79szp8tfte/nBE3+mtelDvCBAEEQr63kDAqDEHioKAUSJ5YVCger6wSy/50Y+XLsSv09fWr1qho2bxMBhXyDf2cm7m19n76Z1nDJiGA8+8gjjvzzhmMjeaxLcv79ZRgwfztWLllHM5dBKIyIorVAGEKsoSoEoGwmQmN6Ap30Kba2ce93NLP9gN2dMncUp51+KQeNMh1KKjoP7WP3Izzh94umsWvVHmTLl4l4bodcG+NvaFyhWfo6hjeMp5HIoz+Y8pus8ERsAShTixLYGEpTSlAp5KmvruOHhFYSlkEP7mwFLnMqljAoCrrr7Fww98WQuv+zrbNr0howdO65XRui1AV7bsJ76ExrJVPUhfziH1h4A4nJeuZy3GoBo3LgLAg0GQaEgDMkdPADakqdCoUgixpiQgx/s5pxps9n55mvcMGtmb8VH93aD5uZmauob0FpjlPWYpX2rrCinv9NYRCwJihtTuPKgEBT4nv2pyP9leyiN9n32N+3jgjl3snnnbjasf0V6I//HNsA77+yQNatXyeaNG5FSAYMN78jbkVRKrEGEKA3KBiEekMhAUZVwFUNiCV0saJsudQ1DaRh9GiuXP/NxVQA+RgqsWP6MLLp/IRPPOAtTUU1ldS2nj5tIvrMDpTTOzTbijVivKuVcLrHyYpsCaxD7gihXNqNpZWWznEy1I9T+w0by9rbtn54Bpn3japk++3uMn3oD0+ddwXFDjkd8HykZirl2lBcleOJl0S7Xbd1LnC82VKRLyDiDQZcqYbtIFc8TFPlSibqGwax+8GFOGz9ORjc2cu2MGZw/+YKjIsUeTz737EmyqamNW5b8icr+gzh8qJWwVLCaGYXSytb1SJmo3GkQ5+WYELGcILEETgzHCwqXCiZ6t9GRGFJQvkc+18reHVs58FET29evZdfLa7jwnDP51eNPMKBuQI9069Gkud+fI4v/8BfuePZ1SsUSpfxhtPaJPRflLk5yl/hKKcRYUpeI1ES54STnozSQyEjxsN3LxFkSH4ISQfsBfkUFyvfwgoCOfXtYfNv16A/eYv3rGxlQV9etft1O2Lr1LWkcNZqbnn6VwcNHkWtrwfN9t9i6NCKuJL+dkF3YMJbddcWS8IDrFJWOKka0QOKo+vf+KdnLxIfrbAVVtf14bPYlHK9aeW7ty93q120VWLRgPiO/MoWhY04ld+igbXMF1+gIaFutMUnUI2K9FckGyRqJ+DxRPtIsapasYknbjEmaIRdbiLiyqTVKe2jtE+bzdLS08K35i3lu3UZWrljWbYns1gAvvvQSY86/DIoFe7MTsUJG+kUljLicU14Hxf1XXXxnx1VkRBVTXCJVWR8QLUleBKUEtMT7CuB5PqV8nmxtHWd/cw4PPbioO/WObIB9+z6SA+05GkZ+ic5CJ9q1uVIezpEHdSJkRGKio5x2E+PGh/hddGS5xGAREUZVwpKgSyoXQeJCIjaSe1daYTo6GDnpPN7avrN3Bsi1tZEvGSr7ViPGxCQVdXjg+nqtyjxfxvhO90QxSUgunmPXlBeDxPFRD+EixuVI7AAT/ZeEgpSiUMzTb+BgOkPh3V07j5gGRzRA35oaAq3Itbbi4dk8j2W0DK2USvLb1WyiRxkvxIQY84J06QyT/sBaS6IbVTkvKIk7w5g7yngn+q+UwoQhGkWQyRxJxSMboK5ugDquug/NO7cSZLKIGBuCXcjNWE9El4C49ycO10ippIxZxeNySERs0VikdaJ8jC4NVRJO0V5iDEGmgqZd26nO+gwZMvSIlaBbEpw8eTIbVj2FzviISVylEHeLKxMw6Wpd307XXCjL/66cmOyjkjpoy18Zb9hqY+todFeIL1JuXCQkqKzkzTXLOOvMid2p130fsGPHdhkxYgQ3Pvkcw04+k/aWZlQmiBXtskkcjirOVSVlYzruf4ibh8gFRiVhI112tYQX3THEcVBkIDekRDClIn3r6tn1xjoenXYuW7ZsZvToMb2LgOHDR6h77vopj990LZ3tB6io6YcUC2BMXJv/w4y6rGhHykeXIVxnF7G4iPWq5Xt7X5KovBrEEYkYgzEhRkL7NCFhqYSYEiIhoqC6voH2Pe/x2Hcu4967f9yt8v9N9P+Jq6+8XFa+sI65jz/L4Mbx5NrbKOU7LQeIYIzEHy8iho8/Zzgmj5sZT3dthqJqHjF+NF/bpycKtId4Gq01nlJ4KinJAhRzh1j37FOsnn87P/zu9Sy4/4Ee6dZjAwDcMe9H8stHH+OL51zChIuvYeiJowj6VOP7GXw/AHcbjLwqJsQY47xnn/ZzuEFEMGGIMYIxoZtTwpRCwrBIGJYIC3lK+QLFjsN0dh6m0JGj83A7nW1t5NtbKRxuJ9fWwqF9e2n959sMqvL4yV13MW36jB7rdVQGAFi/fp0sWnAfr274O4cKISaowMtUElRWov0AQYMYTKlIqZBHwiISGiQsubAOSb4LOEJzTxGDRuK2wtcevqcJAo9sJkM2CKiqrKCqqoqqqiqqq/tSW1PLwIEDmTDxNKZccvlR63PUC8qxedMbsndvE60tLbS1tdHZ0UEYGnzfI5PNks1myWYryGQzZDNZ/MDH9wN838fzPDzfw/d8vOi/5+EHAUFg52QzWYJslprqml7JmSJFihQpUqRIkSJFihQpUqRIkaIM/wItfqmNOho25QAAAABJRU5ErkJggg==" />
    <style>
        /* ========================================
           CSS Variables & Reset
           ======================================== */
        :root {
            --primary-color: #4a90d9;
            --primary-hover: #357abd;
            --bg-color: #f5f7fa;
            --node-bg: #ffffff;
            --node-border: #4a90d9;
            --node-selected: #e3f2fd;
            --text-color: #333333;
            --line-color: #999999;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
            --font-family: 'Meiryo UI', '„É°„Ç§„É™„Ç™', Meiryo, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            font-family: var(--font-family);
            background: var(--bg-color);
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        /* ========================================
           Canvas Container (Full Screen - No Toolbar)
           ======================================== */
        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            background: var(--bg-color);
            background-image:
                radial-gradient(circle, #ddd 1px, transparent 1px);
            background-size: 20px 20px;
            transition: left 0.15s ease, right 0.15s ease;
        }

        .canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: default;
        }

        .canvas.panning {
            cursor: grabbing;
        }

        .canvas-inner {
            position: absolute;
            transform-origin: 0 0;
        }

        /* ========================================
           SVG Lines
           ======================================== */
        .lines-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 10000px;
            height: 10000px;
            overflow: visible;
            transform: translate(-5000px, -5000px);
            pointer-events: none;
        }

        .connection-line {
            fill: none;
            stroke: var(--line-color);
            stroke-width: 2;
            stroke-linecap: round;
            pointer-events: none;
        }

        /* ========================================
           Node Styles
           ======================================== */
        .node {
            position: absolute;
            min-width: 120px;
            padding: 10px 16px;
            background: var(--node-bg);
            border: 2px solid var(--node-border);
            border-radius: 8px;
            box-shadow: var(--shadow);
            cursor: pointer;
            user-select: none;
            transition: box-shadow 0.2s;
            white-space: nowrap;
            box-sizing: border-box;
        }

        .node:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .node.selected {
            background: var(--node-selected);
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 144, 217, 0.3);
        }

        .node.root {
            font-size: 16px;
            font-weight: bold;
            border-width: 3px;
        }

        .node.editing {
            cursor: text;
        }

        .node.dragging {
            opacity: 0.4;
            z-index: 1000;
        }

        .node.drag-over-child {
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.5);
            border-color: #4caf50;
        }

        .node.drag-over-before {
            border-top: 4px solid #2196f3;
        }

        .node.drag-over-after {
            border-bottom: 4px solid #2196f3;
        }

        .node-text {
            outline: none;
            min-width: 50px;
            display: block;
            white-space: pre;
        }

        .node-text[contenteditable="true"] {
            cursor: text;
            background: rgba(255,255,255,0.8);
            padding: 2px 4px;
            margin: -2px -4px;
            border-radius: 3px;
        }

        /* ========================================
           Drag Ghost
           ======================================== */
        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 2000;
            opacity: 0.8;
            transform: rotate(2deg);
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        }

        /* ========================================
           Lasso Selection Rectangle
           ======================================== */
        .lasso-rect {
            position: fixed;
            border: 2px dashed var(--primary-color);
            background: rgba(74, 144, 217, 0.08);
            pointer-events: none;
            z-index: 900;
            display: none;
        }

        /* ========================================
           Left Sidebar (My Maps)
           ======================================== */
        .left-sidebar {
            position: fixed;
            top: 0;
            left: 0;
            height: 100%;
            background: #ffffff;
            border-right: 1px solid #e0e0e0;
            z-index: 600;
            display: flex;
            flex-direction: row;
            box-shadow: 2px 0 12px rgba(0,0,0,0.08);
        }

        .left-sidebar-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 0;
            order: 1;
        }

        .left-sidebar-resize-handle {
            width: 6px;
            cursor: col-resize;
            background: transparent;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
            transition: background 0.15s;
            order: 2;
        }

        .left-sidebar-resize-handle:hover,
        .left-sidebar-resize-handle.dragging {
            background: var(--primary-color);
        }

        .left-sidebar-toggle-btn {
            position: absolute;
            right: -14px;
            top: 50%;
            transform: translateY(-50%);
            width: 14px;
            height: 48px;
            background: #e8e8e8;
            border: 1px solid #d0d0d0;
            border-left: none;
            border-radius: 0 6px 6px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
            z-index: 11;
            transition: background 0.15s;
        }

        .left-sidebar-toggle-btn:hover {
            background: #ddd;
        }

        .left-sidebar-header {
            padding: 12px 14px 8px;
            font-size: 14px;
            font-weight: bold;
            color: var(--text-color);
            border-bottom: 1px solid #e8e8e8;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }

        .left-sidebar-new-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            width: 100%;
            padding: 8px 12px;
            margin: 8px 10px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            background: transparent;
            font-family: var(--font-family);
            font-size: 13px;
            color: #888;
            cursor: pointer;
            transition: all 0.15s;
            flex-shrink: 0;
        }

        .left-sidebar-new-btn:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
            background: #f0f7ff;
        }

        .left-sidebar-list {
            flex: 1;
            overflow-y: auto;
            padding: 4px 0;
        }

        .map-item {
            display: flex;
            align-items: center;
            padding: 8px 10px 8px 14px;
            cursor: pointer;
            transition: background 0.12s;
            gap: 6px;
            position: relative;
        }

        .map-item:hover {
            background: #f0f4f8;
        }

        .map-item.active {
            background: var(--node-selected);
            border-left: 3px solid var(--primary-color);
            padding-left: 11px;
        }

        .map-item-icon {
            flex-shrink: 0;
            font-size: 14px;
        }

        .map-item-name {
            flex: 1;
            font-size: 13px;
            color: var(--text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
        }

        .map-item-name[contenteditable="true"] {
            background: #fff;
            border: 1px solid var(--primary-color);
            border-radius: 3px;
            padding: 1px 4px;
            outline: none;
            white-space: nowrap;
            overflow: visible;
        }

        .map-item-menu-btn {
            flex-shrink: 0;
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            background: transparent;
            color: #999;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.12s, background 0.12s;
        }

        .map-item:hover .map-item-menu-btn,
        .map-item-menu-btn.open {
            opacity: 1;
        }

        .map-item-menu-btn:hover {
            background: #e0e0e0;
        }

        .left-sidebar.collapsed .left-sidebar-content {
            display: none;
        }

        /* Context menu */
        .ctx-menu {
            position: fixed;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            z-index: 5000;
            min-width: 160px;
            padding: 4px 0;
            display: none;
        }

        .ctx-menu.show {
            display: block;
        }

        .ctx-menu-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            font-size: 13px;
            font-family: var(--font-family);
            color: var(--text-color);
            cursor: pointer;
            transition: background 0.1s;
            white-space: nowrap;
        }

        .ctx-menu-item:hover {
            background: #f0f4f8;
        }

        .ctx-menu-item.danger {
            color: #e53935;
        }

        .ctx-menu-item.danger:hover {
            background: #ffeaea;
        }

        /* ========================================
           Right Sidebar
           ======================================== */
        .sidebar {
            position: fixed;
            top: 0;
            right: 0;
            height: 100%;
            background: #ffffff;
            border-left: 1px solid #e0e0e0;
            z-index: 600;
            display: flex;
            flex-direction: row;
            box-shadow: -2px 0 12px rgba(0,0,0,0.08);
        }

        .sidebar-toggle-btn {
            position: absolute;
            left: -14px;
            top: 50%;
            transform: translateY(-50%);
            width: 14px;
            height: 48px;
            background: #e8e8e8;
            border: 1px solid #d0d0d0;
            border-right: none;
            border-radius: 6px 0 0 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #666;
            z-index: 11;
            transition: background 0.15s;
        }

        .sidebar-toggle-btn:hover {
            background: #ddd;
        }

        .sidebar-resize-handle {
            width: 6px;
            cursor: col-resize;
            background: transparent;
            flex-shrink: 0;
            position: relative;
            z-index: 10;
            transition: background 0.15s;
        }

        .sidebar-resize-handle:hover,
        .sidebar-resize-handle.dragging {
            background: var(--primary-color);
        }

        .sidebar-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 0;
        }

        .sidebar-controls {
            padding: 10px 12px;
            border-bottom: 1px solid #e8e8e8;
            display: flex;
            flex-direction: column;
            gap: 6px;
            background: #f8f9fa;
            flex-shrink: 0;
        }

        .sidebar-controls-row {
            display: flex;
            gap: 6px;
        }

        .sidebar-controls select {
            font-family: var(--font-family);
            font-size: 12px;
            padding: 5px 6px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fff;
            color: var(--text-color);
            cursor: pointer;
            outline: none;
            flex: 1;
            min-width: 0;
        }

        .sidebar-controls select:focus {
            border-color: var(--primary-color);
        }

        .sidebar-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 6px 10px;
            border: none;
            border-radius: 6px;
            font-family: var(--font-family);
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            white-space: nowrap;
            flex: 1;
        }

        .sidebar-btn:active {
            transform: scale(0.97);
        }

        .sidebar-btn-copy {
            background: var(--primary-color);
            color: white;
        }

        .sidebar-btn-copy:hover {
            background: var(--primary-hover);
        }

        .sidebar-btn-reset {
            background: #e53935;
            color: white;
        }

        .sidebar-btn-reset:hover {
            background: #c62828;
        }

        .sidebar-tree {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
            padding: 8px 0;
        }

        .sidebar-preview {
            position: relative;
            font-family: 'Menlo', 'Consolas', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.0;
            padding: 6px 8px;
            white-space: pre;
            min-width: max-content;
        }

        .sidebar-preview-line {
            display: inline;
            cursor: pointer;
            border-radius: 2px;
        }

        .sidebar-preview-line:hover {
            background: #eef3fb;
        }

        .sidebar-preview-line.active {
            background: var(--node-selected);
            font-weight: bold;
        }

        /* Mini copy button shown when sidebar is collapsed */
        .sidebar-mini-btn {
            display: none;
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 6px;
            background: var(--primary-color);
            color: white;
            font-size: 16px;
            cursor: pointer;
            align-items: center;
            justify-content: center;
            margin: 8px auto;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .sidebar-mini-btn:hover {
            background: var(--primary-hover);
        }

        .sidebar.collapsed .sidebar-content {
            display: none;
        }

        .sidebar.collapsed .sidebar-mini-btn {
            display: flex;
        }

        /* ========================================
           Toast Notification
           ======================================== */
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 3000;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    </style>
</head>
<body>

    <!-- Left Sidebar (My Maps) -->
    <div class="left-sidebar" id="leftSidebar">
        <div class="left-sidebar-toggle-btn" id="leftSidebarToggle" title="„Éû„Ç§„Éû„ÉÉ„ÉóÈñãÈñâ">‚ñ∂</div>
        <div class="left-sidebar-content" id="leftSidebarContent">
            <div class="left-sidebar-header">üìÇ „Éû„Ç§„Éû„ÉÉ„Éó</div>
            <button class="left-sidebar-new-btn" id="newMapBtn">Ôºã Êñ∞Ë¶è‰ΩúÊàê</button>
            <div class="left-sidebar-list" id="mapList"></div>
        </div>
        <div class="left-sidebar-resize-handle" id="leftSidebarResizeHandle"></div>
    </div>

    <!-- Context Menu for Map Items -->
    <div class="ctx-menu" id="ctxMenu">
        <div class="ctx-menu-item" data-action="rename">‚úèÔ∏è ÂêçÂâçÂ§âÊõ¥</div>
        <div class="ctx-menu-item" data-action="duplicate">üìë Ë§áË£Ω</div>
        <div class="ctx-menu-item danger" data-action="delete">üóë ÂâäÈô§</div>
    </div>

    <!-- Canvas Container (Full Screen) -->
    <div class="canvas-container" id="canvasContainer">
        <div class="canvas" id="canvas">
            <div class="canvas-inner" id="canvasInner">
                <svg class="lines-svg" id="linesSvg"></svg>
            </div>
        </div>
    </div>

    <!-- Right Sidebar -->
    <div class="sidebar" id="sidebar">
        <div class="sidebar-toggle-btn" id="sidebarToggle" title="„Çµ„Ç§„Éâ„Éê„ÉºÈñãÈñâ">‚óÄ</div>
        <div class="sidebar-resize-handle" id="sidebarResizeHandle"></div>
        <button class="sidebar-mini-btn" id="sidebarMiniCopy" title="„Ç≥„Éî„Éº">üìã</button>
        <div class="sidebar-content" id="sidebarContent">
            <div class="sidebar-controls">
                <div class="sidebar-controls-row">
                    <select id="copyFormat" title="Âá∫ÂäõÂΩ¢Âºè">
                        <option value="simple">„Ç∑„É≥„Éó„É´</option>
                        <option value="hiyoko">„Å≤„Çà„Åì„É¢„Éº„Éâ üê•</option>
                        <option value="family">„Åã„Åû„Åè„É¢„Éº„Éâ üë∂</option>
                    </select>
                    <select id="copyBorder" title="ÁΩ´Á∑ö">
                        <option value="none">ÁΩ´Á∑ö„Å™„Åó</option>
                        <option value="border" selected>ÁΩ´Á∑ö„ÅÇ„Çä</option>
                    </select>
                </div>
                <div class="sidebar-controls-row">
                    <button class="sidebar-btn sidebar-btn-copy" id="copyBtn" title="„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº">üìã „Ç≥„Éî„Éº</button>
                    <button class="sidebar-btn sidebar-btn-reset" id="resetBtn" title="„Éû„ÉÉ„Éó„Çí„É™„Çª„ÉÉ„Éà">üóë „É™„Çª„ÉÉ„Éà</button>
                </div>
            </div>
            <div class="sidebar-tree" id="sidebarTree"></div>
        </div>
    </div>

    <!-- Lasso Selection Rectangle -->
    <div class="lasso-rect" id="lassoRect"></div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
    (function() {
        'use strict';

        // ========================================
        // Global State
        // ========================================

        const levelIcons = {
            hiyoko: { 1: 'üêî', 2: 'üê§', 3: 'üê£', 4: 'ü•ö' },
            family: { 1: 'üë¥', 2: 'üë®', 3: 'üë¶', 4: 'üë∂' }
        };

        let mindMapData = {
            root: {
                id: 'root',
                text: '‰∏≠ÂøÉ„ÉÜ„Éº„Éû',
                children: []
            }
        };

        let currentMapId = null; // Currently active map ID

        let selectedNodeIds = new Set();
        let lastSelectedNodeId = null;
        let selectionAnchorId = null; // Anchor node for Shift+Arrow range selection
        let editingNodeId = null;

        let viewState = {
            zoom: 1,
            panX: 0,
            panY: 0,
            isPanning: false,
            startX: 0,
            startY: 0
        };

        let undoHistory = [];
        let undoIndex = -1;
        const MAX_HISTORY = 50;

        let clipboard = null;
        let clipboardIsCut = false;

        let nodeIdCounter = 0;

        // Drag reparenting state
        let nodeDragState = {
            isDragging: false,
            didDrag: false,
            nodeId: null,
            draggedNodeIds: null,
            targetNodeId: null,
            targetPosition: null
        };

        // Lasso selection state
        let lassoState = {
            active: false,
            didSelect: false,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0
        };

        // Context menu state
        let ctxMenuTargetMapId = null;

        // ========================================
        // Utility Functions
        // ========================================

        function generateId() {
            return 'node_' + (++nodeIdCounter) + '_' + Date.now();
        }

        function deepClone(obj) {
            return JSON.parse(JSON.stringify(obj));
        }

        function showToast(message, duration) {
            duration = duration || 2000;
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            clearTimeout(toast._tid);
            toast._tid = setTimeout(function() {
                toast.classList.remove('show');
            }, duration);
        }

        // ========================================
        // Multi-Map Storage Layer
        // ========================================

        var META_KEY = 'mindmap-meta';
        var ID_COUNTER_KEY = 'mindmap-id-counter';
        var LAST_ACTIVE_KEY = 'mindmap-last-active-id';
        var OLD_STORAGE_KEY = 'mindmap_data_v2'; // legacy key for migration

        function getMapDataKey(mapId) {
            return 'mindmap-data-' + mapId;
        }

        function getMetaList() {
            try {
                var raw = localStorage.getItem(META_KEY);
                if (raw) return JSON.parse(raw);
            } catch(e) {}
            return [];
        }

        function saveMetaList(metaList) {
            try { localStorage.setItem(META_KEY, JSON.stringify(metaList)); } catch(e) {}
        }

        function getNextMapId() {
            var counter = parseInt(localStorage.getItem(ID_COUNTER_KEY), 10) || 0;
            counter++;
            try { localStorage.setItem(ID_COUNTER_KEY, String(counter)); } catch(e) {}
            return counter;
        }

        function setLastActiveId(mapId) {
            try { localStorage.setItem(LAST_ACTIVE_KEY, String(mapId)); } catch(e) {}
        }

        function getLastActiveId() {
            return parseInt(localStorage.getItem(LAST_ACTIVE_KEY), 10) || null;
        }

        function findMetaById(mapId) {
            var list = getMetaList();
            for (var i = 0; i < list.length; i++) {
                if (list[i].id === mapId) return list[i];
            }
            return null;
        }

        function nowISO() {
            return new Date().toISOString();
        }

        // ---- Migration from old single-map storage ----
        function migrateIfNeeded() {
            // If meta already exists, skip migration
            if (localStorage.getItem(META_KEY)) return;

            var oldData = null;
            try {
                var raw = localStorage.getItem(OLD_STORAGE_KEY);
                if (raw) {
                    var parsed = JSON.parse(raw);
                    if (parsed && parsed.root && parsed.root.id === 'root') {
                        oldData = parsed;
                    }
                }
            } catch(e) {}

            var now = nowISO();
            if (oldData) {
                // Migrate existing data as map ID 1
                var mapId = getNextMapId();
                var mapName = oldData.root.text || 'ÁÑ°È°å„ÅÆ„Éû„ÉÉ„Éó';
                var meta = { id: mapId, name: mapName, createdAt: now, updatedAt: now };
                saveMetaList([meta]);
                try { localStorage.setItem(getMapDataKey(mapId), JSON.stringify(oldData)); } catch(e) {}
                setLastActiveId(mapId);
                // Remove old key
                try { localStorage.removeItem(OLD_STORAGE_KEY); } catch(e) {}
            } else {
                // No existing data: create initial empty map
                var mapId = getNextMapId();
                var defaultData = { root: { id: 'root', text: '‰∏≠ÂøÉ„ÉÜ„Éº„Éû', children: [] } };
                var meta = { id: mapId, name: 'ÁÑ°È°å„ÅÆ„Éû„ÉÉ„Éó', createdAt: now, updatedAt: now };
                saveMetaList([meta]);
                try { localStorage.setItem(getMapDataKey(mapId), JSON.stringify(defaultData)); } catch(e) {}
                setLastActiveId(mapId);
            }
        }

        // ---- Save / Load for current map ----
        function saveToLocalStorage() {
            if (!currentMapId) return;
            try {
                localStorage.setItem(getMapDataKey(currentMapId), JSON.stringify(mindMapData));
            } catch(e) {}
            // Update meta updatedAt
            var metaList = getMetaList();
            for (var i = 0; i < metaList.length; i++) {
                if (metaList[i].id === currentMapId) {
                    metaList[i].updatedAt = nowISO();
                    break;
                }
            }
            saveMetaList(metaList);
        }

        function loadMapData(mapId) {
            try {
                var raw = localStorage.getItem(getMapDataKey(mapId));
                if (raw) {
                    var parsed = JSON.parse(raw);
                    if (parsed && parsed.root && parsed.root.id === 'root') {
                        return parsed;
                    }
                }
            } catch(e) {}
            return null;
        }

        // ========================================
        // History Management (Undo/Redo)
        // ========================================

        function saveState() {
            undoHistory = undoHistory.slice(0, undoIndex + 1);
            undoHistory.push(deepClone(mindMapData));
            if (undoHistory.length > MAX_HISTORY) {
                undoHistory.shift();
            } else {
                undoIndex++;
            }
        }

        function resetMindMap() {
            if (!confirm('„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü\n„Åô„Åπ„Å¶„ÅÆ„Éé„Éº„Éâ„ÅåÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ')) return;
            mindMapData = {
                root: { id: 'root', text: '‰∏≠ÂøÉ„ÉÜ„Éº„Éû', children: [] }
            };
            undoHistory = [];
            undoIndex = -1;
            selectedNodeIds.clear();
            lastSelectedNodeId = null;
            editingNodeId = null;
            clipboard = null;
            clipboardIsCut = false;
            saveState();
            render();
            resetView();
            selectNode('root');
            setTimeout(function() { startEditing('root'); }, 100);
            showToast('üóë „É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü');
        }

        function undo() {
            if (undoIndex > 0) {
                undoIndex--;
                mindMapData = deepClone(undoHistory[undoIndex]);
                render();
                showToast('ÂÖÉ„Å´Êàª„Åó„Åæ„Åó„Åü');
            }
        }

        function redo() {
            if (undoIndex < undoHistory.length - 1) {
                undoIndex++;
                mindMapData = deepClone(undoHistory[undoIndex]);
                render();
                showToast('„ÇÑ„ÇäÁõ¥„Åó„Åæ„Åó„Åü');
            }
        }

        // ========================================
        // Node Operations
        // ========================================

        function findNode(id, node, parent, index) {
            if (node === undefined) node = mindMapData.root;
            if (parent === undefined) parent = null;
            if (index === undefined) index = 0;
            if (node.id === id) return { node: node, parent: parent, index: index };
            for (var i = 0; i < node.children.length; i++) {
                var result = findNode(id, node.children[i], node, i);
                if (result) return result;
            }
            return null;
        }

        function getNodeLevel(id, node, level) {
            if (node === undefined) node = mindMapData.root;
            if (level === undefined) level = 1;
            if (node.id === id) return level;
            for (var i = 0; i < node.children.length; i++) {
                var result = getNodeLevel(id, node.children[i], level + 1);
                if (result) return result;
            }
            return null;
        }

        function getAllNodesInOrder(node, result) {
            if (node === undefined) node = mindMapData.root;
            if (result === undefined) result = [];
            result.push(node);
            for (var i = 0; i < node.children.length; i++) {
                getAllNodesInOrder(node.children[i], result);
            }
            return result;
        }

        function addChildNode(parentId, text, autoEdit) {
            if (text === undefined) text = 'Êñ∞„Åó„ÅÑ„Éé„Éº„Éâ';
            if (autoEdit === undefined) autoEdit = true;
            var result = findNode(parentId);
            if (!result) return null;
            saveState();
            var newNode = { id: generateId(), text: text, children: [] };
            result.node.children.push(newNode);
            render();
            selectNode(newNode.id);
            if (autoEdit) {
                setTimeout(function() { startEditing(newNode.id); }, 50);
            }
            return newNode;
        }

        function addSiblingNode(nodeId, text, autoEdit) {
            if (text === undefined) text = 'Êñ∞„Åó„ÅÑ„Éé„Éº„Éâ';
            if (autoEdit === undefined) autoEdit = true;
            var result = findNode(nodeId);
            if (!result || !result.parent) {
                return addChildNode(nodeId, text, autoEdit);
            }
            saveState();
            var newNode = { id: generateId(), text: text, children: [] };
            result.parent.children.splice(result.index + 1, 0, newNode);
            render();
            selectNode(newNode.id);
            if (autoEdit) {
                setTimeout(function() { startEditing(newNode.id); }, 50);
            }
            return newNode;
        }

        function deleteNode(nodeId) {
            if (nodeId === 'root') {
                showToast('„É´„Éº„Éà„Éé„Éº„Éâ„ÅØÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì');
                return false;
            }
            var result = findNode(nodeId);
            if (!result || !result.parent) return false;
            saveState();
            result.parent.children.splice(result.index, 1);
            if (result.parent.children.length > 0) {
                var idx = Math.min(result.index, result.parent.children.length - 1);
                selectNode(result.parent.children[idx].id);
            } else {
                selectNode(result.parent.id);
            }
            render();
            return true;
        }

        function deleteSelectedNodes() {
            if (selectedNodeIds.size === 0) return;
            var ids = [];
            selectedNodeIds.forEach(function(id) { if (id !== 'root') ids.push(id); });
            if (ids.length === 0) {
                showToast('„É´„Éº„Éà„Éé„Éº„Éâ„ÅØÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì');
                return;
            }
            var filtered = filterTopLevelNodes(ids);
            saveState();
            var lastParent = null;
            for (var i = 0; i < filtered.length; i++) {
                var r = findNode(filtered[i]);
                if (r && r.parent) {
                    lastParent = r.parent;
                    r.parent.children.splice(r.index, 1);
                }
            }
            selectedNodeIds.clear();
            if (lastParent && lastParent.children.length > 0) {
                selectNode(lastParent.children[0].id);
            } else if (lastParent) {
                selectNode(lastParent.id);
            } else {
                selectNode('root');
            }
            render();
            showToast(filtered.length + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
        }

        function updateNodeText(nodeId, newText) {
            var result = findNode(nodeId);
            if (result && result.node.text !== newText) {
                saveState();
                result.node.text = newText;
            }
        }

        function moveNodeUp(nodeId) {
            var result = findNode(nodeId);
            if (result && result.parent && result.index > 0) {
                saveState();
                var s = result.parent.children;
                var tmp = s[result.index - 1];
                s[result.index - 1] = s[result.index];
                s[result.index] = tmp;
                render();
            }
        }

        function moveNodeDown(nodeId) {
            var result = findNode(nodeId);
            if (result && result.parent && result.index < result.parent.children.length - 1) {
                saveState();
                var s = result.parent.children;
                var tmp = s[result.index];
                s[result.index] = s[result.index + 1];
                s[result.index + 1] = tmp;
                render();
            }
        }

        function promoteNode(nodeId) {
            var result = findNode(nodeId);
            if (!result || !result.parent || result.parent.id === 'root') return;
            var gpResult = findNode(result.parent.id);
            if (gpResult && gpResult.parent) {
                saveState();
                result.parent.children.splice(result.index, 1);
                gpResult.parent.children.splice(gpResult.index + 1, 0, result.node);
                render();
                selectNode(nodeId);
            }
        }

        function demoteNode(nodeId) {
            var result = findNode(nodeId);
            if (!result || !result.parent || result.index === 0) return;
            saveState();
            var prevSibling = result.parent.children[result.index - 1];
            result.parent.children.splice(result.index, 1);
            prevSibling.children.push(result.node);
            render();
            selectNode(nodeId);
        }

        // ========================================
        // Selection & Navigation
        // ========================================

        function selectNode(nodeId) {
            clearSelection();
            if (nodeId) {
                selectedNodeIds.add(nodeId);
                lastSelectedNodeId = nodeId;
                selectionAnchorId = nodeId;
                updateSelectionDisplay();
                scrollNodeIntoView(nodeId);
            }
        }

        function clearSelection() {
            selectedNodeIds.clear();
            lastSelectedNodeId = null;
            selectionAnchorId = null;
            document.querySelectorAll('.node.selected').forEach(function(el) {
                el.classList.remove('selected');
            });
            document.querySelectorAll('.sidebar-preview-line.active').forEach(function(el) {
                el.classList.remove('active');
            });
        }

        function updateSelectionDisplay() {
            document.querySelectorAll('.node').forEach(function(el) {
                el.classList.toggle('selected', selectedNodeIds.has(el.dataset.id));
            });
            // Sync sidebar preview highlight
            document.querySelectorAll('.sidebar-preview-line').forEach(function(el) {
                el.classList.toggle('active', selectedNodeIds.has(el.getAttribute('data-sid')));
            });
        }

        function toggleSelectNode(nodeId) {
            if (selectedNodeIds.has(nodeId)) {
                selectedNodeIds.delete(nodeId);
            } else {
                selectedNodeIds.add(nodeId);
            }
            lastSelectedNodeId = nodeId;
            updateSelectionDisplay();
        }

        function rangeSelectNode(nodeId) {
            if (!lastSelectedNodeId) { selectNode(nodeId); return; }
            // Preserve the anchor: if no anchor yet, use lastSelectedNodeId
            if (!selectionAnchorId) selectionAnchorId = lastSelectedNodeId;
            var allNodes = getAllNodesInOrder();
            var si = -1, ei = -1;
            for (var i = 0; i < allNodes.length; i++) {
                if (allNodes[i].id === selectionAnchorId) si = i;
                if (allNodes[i].id === nodeId) ei = i;
            }
            if (si === -1 || ei === -1) { selectNode(nodeId); return; }
            var mn = Math.min(si, ei), mx = Math.max(si, ei);
            selectedNodeIds.clear();
            for (var i = mn; i <= mx; i++) {
                selectedNodeIds.add(allNodes[i].id);
            }
            lastSelectedNodeId = nodeId;
            // Keep selectionAnchorId unchanged so further Shift+clicks extend from original anchor
            updateSelectionDisplay();
        }

        function getSelectedNodeId() {
            if (selectedNodeIds.size === 0) return null;
            return lastSelectedNodeId || selectedNodeIds.values().next().value;
        }

        function getSelectedNodes() {
            var nodes = [];
            selectedNodeIds.forEach(function(id) {
                var r = findNode(id);
                if (r) nodes.push(r.node);
            });
            return nodes;
        }

        // Collect all nodes at a given depth level in tree-walk (visual) order
        function getNodesAtLevel(targetLevel, node, currentLevel) {
            if (node === undefined) node = mindMapData.root;
            if (currentLevel === undefined) currentLevel = 1;
            var result = [];
            if (currentLevel === targetLevel) {
                result.push(node);
                return result;
            }
            for (var i = 0; i < node.children.length; i++) {
                var childResults = getNodesAtLevel(targetLevel, node.children[i], currentLevel + 1);
                for (var j = 0; j < childResults.length; j++) {
                    result.push(childResults[j]);
                }
            }
            return result;
        }

        // Navigate UP: cross-parent, same depth level
        function navigateUp() {
            var cid = getSelectedNodeId();
            if (!cid) { selectNode('root'); return; }
            var level = getNodeLevel(cid);
            if (!level || level <= 1) return; // root has no same-level peers
            var nodesAtLevel = getNodesAtLevel(level);
            var idx = -1;
            for (var i = 0; i < nodesAtLevel.length; i++) {
                if (nodesAtLevel[i].id === cid) { idx = i; break; }
            }
            if (idx > 0) {
                selectNode(nodesAtLevel[idx - 1].id);
            }
        }

        // Navigate DOWN: cross-parent, same depth level
        function navigateDown() {
            var cid = getSelectedNodeId();
            if (!cid) { selectNode('root'); return; }
            var level = getNodeLevel(cid);
            if (!level || level <= 1) return;
            var nodesAtLevel = getNodesAtLevel(level);
            var idx = -1;
            for (var i = 0; i < nodesAtLevel.length; i++) {
                if (nodesAtLevel[i].id === cid) { idx = i; break; }
            }
            if (idx >= 0 && idx < nodesAtLevel.length - 1) {
                selectNode(nodesAtLevel[idx + 1].id);
            }
        }

        // Shift+Arrow range selection: extend/shrink from anchor along same depth
        function shiftNavigateUp() {
            var cid = getSelectedNodeId();
            if (!cid) return;
            if (!selectionAnchorId) selectionAnchorId = cid;
            var level = getNodeLevel(cid);
            if (!level || level <= 1) return;
            var nodesAtLevel = getNodesAtLevel(level);
            var curIdx = -1;
            for (var i = 0; i < nodesAtLevel.length; i++) {
                if (nodesAtLevel[i].id === cid) { curIdx = i; break; }
            }
            if (curIdx <= 0) return;
            var newEndId = nodesAtLevel[curIdx - 1].id;
            applyRangeAtLevel(nodesAtLevel, selectionAnchorId, newEndId);
            lastSelectedNodeId = newEndId;
            scrollNodeIntoView(newEndId);
        }

        function shiftNavigateDown() {
            var cid = getSelectedNodeId();
            if (!cid) return;
            if (!selectionAnchorId) selectionAnchorId = cid;
            var level = getNodeLevel(cid);
            if (!level || level <= 1) return;
            var nodesAtLevel = getNodesAtLevel(level);
            var curIdx = -1;
            for (var i = 0; i < nodesAtLevel.length; i++) {
                if (nodesAtLevel[i].id === cid) { curIdx = i; break; }
            }
            if (curIdx < 0 || curIdx >= nodesAtLevel.length - 1) return;
            var newEndId = nodesAtLevel[curIdx + 1].id;
            applyRangeAtLevel(nodesAtLevel, selectionAnchorId, newEndId);
            lastSelectedNodeId = newEndId;
            scrollNodeIntoView(newEndId);
        }

        // Select all nodes between anchor and end within the given level-node list
        function applyRangeAtLevel(nodesAtLevel, anchorId, endId) {
            var ai = -1, ei = -1;
            for (var i = 0; i < nodesAtLevel.length; i++) {
                if (nodesAtLevel[i].id === anchorId) ai = i;
                if (nodesAtLevel[i].id === endId) ei = i;
            }
            if (ai === -1 || ei === -1) return;
            var mn = Math.min(ai, ei), mx = Math.max(ai, ei);
            selectedNodeIds.clear();
            for (var i = mn; i <= mx; i++) {
                selectedNodeIds.add(nodesAtLevel[i].id);
            }
            updateSelectionDisplay();
        }

        // Navigate LEFT: go to parent
        function navigateLeft() {
            var cid = getSelectedNodeId();
            if (!cid) { selectNode('root'); return; }
            var r = findNode(cid);
            if (r && r.parent) selectNode(r.parent.id);
        }

        // Navigate RIGHT: go to first child
        function navigateRight() {
            var cid = getSelectedNodeId();
            if (!cid) { selectNode('root'); return; }
            var r = findNode(cid);
            if (r && r.node.children.length > 0) {
                selectNode(r.node.children[0].id);
            }
        }

        function goToParent() {
            var cid = getSelectedNodeId();
            if (!cid || cid === 'root') return;
            var r = findNode(cid);
            if (r && r.parent) selectNode(r.parent.id);
        }

        function scrollNodeIntoView(nodeId) {
            var nodeEl = document.querySelector('[data-id="' + nodeId + '"]');
            if (!nodeEl) return;
            var container = document.getElementById('canvasContainer');
            var rect = nodeEl.getBoundingClientRect();
            var cRect = container.getBoundingClientRect();
            var margin = 60;
            var dx = 0, dy = 0;
            if (rect.left < cRect.left + margin) dx = cRect.left + margin - rect.left;
            else if (rect.right > cRect.right - margin) dx = cRect.right - margin - rect.right;
            if (rect.top < cRect.top + margin) dy = cRect.top + margin - rect.top;
            else if (rect.bottom > cRect.bottom - margin - 80) dy = cRect.bottom - margin - 80 - rect.bottom;
            if (dx !== 0 || dy !== 0) {
                viewState.panX += dx;
                viewState.panY += dy;
                updateView();
            }
        }

        // ========================================
        // Edit Mode
        // ========================================

        function startEditing(nodeId) {
            if (editingNodeId === nodeId) return;
            if (editingNodeId) finishEditing();
            editingNodeId = nodeId;
            // Select without clearing other selection state, just ensure this node is selected
            if (!selectedNodeIds.has(nodeId)) {
                selectNode(nodeId);
            }
            var nodeEl = document.querySelector('[data-id="' + nodeId + '"]');
            var textEl = nodeEl ? nodeEl.querySelector('.node-text') : null;
            if (textEl) {
                nodeEl.classList.add('editing');
                // Remove fixed width so node grows/shrinks with text in real-time
                nodeEl.style.width = 'auto';
                textEl.contentEditable = 'true';
                textEl.focus();
                var range = document.createRange();
                range.selectNodeContents(textEl);
                var sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
        }

        function finishEditing() {
            if (!editingNodeId) return;
            var prevEditingId = editingNodeId;
            var nodeEl = document.querySelector('[data-id="' + editingNodeId + '"]');
            var textEl = nodeEl ? nodeEl.querySelector('.node-text') : null;
            var textChanged = false;
            if (textEl) {
                // Convert innerHTML <br> tags to \n for storage
                var html = textEl.innerHTML;
                // Replace <br> variants with \n
                var newText = html.replace(/<br\s*\/?>/gi, '\n');
                // Strip any other HTML tags
                var tmp = document.createElement('div');
                tmp.innerHTML = newText;
                newText = tmp.textContent.replace(/\u200B/g, '').trim() || 'Á©∫„ÅÆ„Éé„Éº„Éâ';
                var result = findNode(editingNodeId);
                if (result && result.node.text !== newText) {
                    textChanged = true;
                }
                updateNodeText(editingNodeId, newText);
                textEl.contentEditable = 'false';
                nodeEl.classList.remove('editing');
            }
            editingNodeId = null;
            // Re-render to recalculate layout when text changed
            if (textChanged) {
                render();
                // Re-select the previously edited node
                selectNode(prevEditingId);
            }
        }

        // ========================================
        // Copy, Cut & Paste
        // ========================================

        function copySelectedNodes() {
            if (selectedNodeIds.size === 0) return;
            if (selectedNodeIds.size === 1) {
                var id = getSelectedNodeId();
                var r = findNode(id);
                if (r) {
                    clipboard = deepClone(r.node);
                    clipboardIsCut = false;
                    showToast('„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
                }
            } else {
                var topLevel = filterTopLevelNodes(Array.from(selectedNodeIds));
                var nodes = [];
                for (var i = 0; i < topLevel.length; i++) {
                    var r = findNode(topLevel[i]);
                    if (r) nodes.push(deepClone(r.node));
                }
                if (nodes.length > 0) {
                    clipboard = nodes;
                    clipboardIsCut = false;
                    showToast(nodes.length + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
                }
            }
        }

        function cutSelectedNodes() {
            if (selectedNodeIds.size === 0) return;
            var ids = [];
            selectedNodeIds.forEach(function(id) { if (id !== 'root') ids.push(id); });
            if (ids.length === 0) {
                showToast('„É´„Éº„Éà„Éé„Éº„Éâ„ÅØÂàá„ÇäÂèñ„Çå„Åæ„Åõ„Çì');
                return;
            }
            var topLevel = filterTopLevelNodes(ids);
            var nodes = [];
            for (var i = 0; i < topLevel.length; i++) {
                var r = findNode(topLevel[i]);
                if (r) nodes.push(deepClone(r.node));
            }
            if (nodes.length === 0) return;
            clipboard = nodes.length === 1 ? nodes[0] : nodes;
            clipboardIsCut = true;

            saveState();
            var lastParent = null;
            for (var i = 0; i < topLevel.length; i++) {
                var r = findNode(topLevel[i]);
                if (r && r.parent) {
                    lastParent = r.parent;
                    r.parent.children.splice(r.index, 1);
                }
            }
            selectedNodeIds.clear();
            if (lastParent && lastParent.children.length > 0) {
                selectNode(lastParent.children[0].id);
            } else if (lastParent) {
                selectNode(lastParent.id);
            } else {
                selectNode('root');
            }
            render();
            showToast(topLevel.length + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„ÇíÂàá„ÇäÂèñ„Çä„Åæ„Åó„Åü');
        }

        function pasteNode() {
            var cid = getSelectedNodeId();
            if (!clipboard || !cid) return;
            var r = findNode(cid);
            if (!r) return;
            saveState();
            function reassignIds(node) {
                node.id = generateId();
                if (node.children) {
                    for (var i = 0; i < node.children.length; i++) reassignIds(node.children[i]);
                }
            }
            if (Array.isArray(clipboard)) {
                for (var i = 0; i < clipboard.length; i++) {
                    var cloned = deepClone(clipboard[i]);
                    reassignIds(cloned);
                    r.node.children.push(cloned);
                }
                render();
                showToast(clipboard.length + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„Çí„Éö„Éº„Çπ„Éà„Åó„Åæ„Åó„Åü');
            } else {
                var cloned = deepClone(clipboard);
                reassignIds(cloned);
                r.node.children.push(cloned);
                render();
                selectNode(cloned.id);
                showToast('„Éö„Éº„Çπ„Éà„Åó„Åæ„Åó„Åü');
            }
            if (clipboardIsCut) {
                clipboard = null;
                clipboardIsCut = false;
            }
        }

        function selectAll() {
            var allNodes = getAllNodesInOrder();
            if (selectedNodeIds.size === allNodes.length) {
                clearSelection();
            } else {
                finishEditing();
                selectedNodeIds.clear();
                for (var i = 0; i < allNodes.length; i++) {
                    selectedNodeIds.add(allNodes[i].id);
                }
                lastSelectedNodeId = allNodes[0] ? allNodes[0].id : null;
                updateSelectionDisplay();
            }
        }

        function filterTopLevelNodes(nodeIds) {
            var result = [];
            for (var i = 0; i < nodeIds.length; i++) {
                var nid = nodeIds[i];
                if (nid === 'root') continue;
                var hasAncestor = false;
                for (var j = 0; j < nodeIds.length; j++) {
                    if (nodeIds[j] !== nid && isDescendant(nodeIds[j], nid)) {
                        hasAncestor = true;
                        break;
                    }
                }
                if (!hasAncestor) result.push(nid);
            }
            return result;
        }

        function isDescendant(ancestorId, nodeId) {
            var r = findNode(ancestorId);
            if (!r) return false;
            function check(node) {
                for (var i = 0; i < node.children.length; i++) {
                    if (node.children[i].id === nodeId) return true;
                    if (check(node.children[i])) return true;
                }
                return false;
            }
            return check(r.node);
        }

        // ========================================
        // Copy to Clipboard (Floating Button)
        // ========================================

        function getCurrentCopyText() {
            var format = document.getElementById('copyFormat').value;
            var border = document.getElementById('copyBorder').value;
            var useBorder = (border === 'border');
            return generateCopyText(mindMapData.root, 0, [], format, useBorder);
        }

        function copyToClipboard() {
            var text = getCurrentCopyText();

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(function() {
                    showToast('‚úÖ „Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
                }).catch(function() {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            var ta = document.createElement('textarea');
            ta.value = text;
            ta.style.cssText = 'position:fixed;opacity:0;left:-9999px;';
            document.body.appendChild(ta);
            ta.select();
            try { document.execCommand('copy'); } catch(e) {}
            document.body.removeChild(ta);
            showToast('‚úÖ „Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
        }



        function generateCopyText(node, level, parentContinues, format, useBorder) {
            var result = '';
            var iconLevel = Math.min(level + 1, 4);
            var icons = levelIcons[format];
            var icon = icons ? (icons[iconLevel] + ' ') : '';

            // ---- Root (level 0) ----
            if (level === 0) {
                result = icon + node.text + '\n';
            } else {
                // Build the prefix from ancestor continuation info
                var prefix = '';
                for (var i = 0; i < level - 1; i++) {
                    if (useBorder) {
                        prefix += parentContinues[i] ? '‚îÇ  ' : '   ';
                    } else {
                        prefix += '  ';
                    }
                }
                // Connector for this node
                var isLast = (parentContinues[level - 1] === false);
                var connector;
                if (useBorder) {
                    connector = isLast ? '‚îî‚îÄ ' : '‚îú‚îÄ ';
                } else {
                    connector = '  ';
                }
                result = prefix + connector + icon + node.text + '\n';
            }

            // ---- Children ----
            for (var i = 0; i < node.children.length; i++) {
                var isLastChild = (i === node.children.length - 1);
                var newContinues = parentContinues.slice();
                newContinues.push(!isLastChild);
                result += generateCopyText(node.children[i], level + 1, newContinues, format, useBorder);
            }

            // ---- Separator blank line between sibling groups (border mode only) ----
            // Add a continuation-bar blank line after a node that has children,
            // if it is NOT the last sibling at its level and border mode is on.
            if (useBorder && level > 0 && node.children.length > 0) {
                var amILast = (parentContinues[level - 1] === false);
                if (!amILast) {
                    var sep = '';
                    for (var i = 0; i < level - 1; i++) {
                        sep += parentContinues[i] ? '‚îÇ  ' : '   ';
                    }
                    sep += '‚îÇ';
                    result += sep + '\n';
                }
            }
            return result;
        }

        // ========================================
        // Node Drag & Drop (Reparenting)
        // ========================================

        function startNodeDrag(nodeId, clientX, clientY, nodeEl) {
            if (nodeId === 'root') return;
            var startTime = Date.now();
            nodeDragState.didDrag = false;

            function onMouseMove(e) {
                var moved = Math.abs(e.clientX - clientX) > 5 || Math.abs(e.clientY - clientY) > 5;
                var elapsed = Date.now() - startTime;
                if (moved && elapsed > 150 && !nodeDragState.isDragging) {
                    nodeDragState.isDragging = true;
                    nodeDragState.didDrag = true;
                    nodeDragState.nodeId = nodeId;
                    if (selectedNodeIds.has(nodeId) && selectedNodeIds.size > 1) {
                        var ids = [];
                        selectedNodeIds.forEach(function(id) { if (id !== 'root') ids.push(id); });
                        nodeDragState.draggedNodeIds = ids;
                    } else {
                        nodeDragState.draggedNodeIds = [nodeId];
                    }
                    createDragGhost(nodeEl, e.clientX, e.clientY, nodeDragState.draggedNodeIds.length);
                    nodeDragState.draggedNodeIds.forEach(function(id) {
                        var el = document.querySelector('[data-id="' + id + '"]');
                        if (el) el.classList.add('dragging');
                    });
                }
                if (nodeDragState.isDragging) {
                    updateNodeDrag(e.clientX, e.clientY);
                }
            }

            function onMouseUp(e) {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                if (nodeDragState.isDragging) {
                    endNodeDrag();
                }
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function createDragGhost(nodeEl, clientX, clientY, count) {
            var existing = document.querySelector('.drag-ghost');
            if (existing) existing.remove();
            var ghost = nodeEl.cloneNode(true);
            ghost.classList.add('drag-ghost');
            ghost.classList.remove('selected', 'dragging');
            ghost.style.left = clientX + 'px';
            ghost.style.top = clientY + 'px';
            ghost.style.transform = 'translate(-50%, -50%)';
            ghost.style.position = 'fixed';
            ghost.style.width = nodeEl.offsetWidth + 'px';
            if (count > 1) {
                var badge = document.createElement('span');
                badge.style.cssText = 'position:absolute;top:-8px;right:-8px;background:#e53935;color:white;border-radius:50%;width:24px;height:24px;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:bold;';
                badge.textContent = count;
                ghost.appendChild(badge);
            }
            document.body.appendChild(ghost);
        }

        function updateNodeDrag(clientX, clientY) {
            if (!nodeDragState.isDragging) return;
            var ghost = document.querySelector('.drag-ghost');
            if (ghost) { ghost.style.left = clientX + 'px'; ghost.style.top = clientY + 'px'; }
            document.querySelectorAll('.node').forEach(function(el) {
                el.classList.remove('drag-over-child', 'drag-over-before', 'drag-over-after');
            });
            var target = getDropTarget(clientX, clientY);
            nodeDragState.targetNodeId = target ? target.nodeId : null;
            nodeDragState.targetPosition = target ? target.position : null;
            if (target) {
                var tEl = document.querySelector('[data-id="' + target.nodeId + '"]');
                if (tEl) tEl.classList.add('drag-over-' + target.position);
            }
        }

        function getDropTarget(clientX, clientY) {
            var elements = document.elementsFromPoint(clientX, clientY);
            var draggedIds = nodeDragState.draggedNodeIds || [nodeDragState.nodeId];
            for (var i = 0; i < elements.length; i++) {
                var el = elements[i];
                if (!el.classList.contains('node') || el.classList.contains('drag-ghost')) continue;
                var tid = el.dataset.id;
                if (draggedIds.indexOf(tid) >= 0) continue;
                var isDesc = false;
                for (var j = 0; j < draggedIds.length; j++) {
                    if (isDescendant(draggedIds[j], tid)) { isDesc = true; break; }
                }
                if (isDesc) continue;
                var rect = el.getBoundingClientRect();
                var relY = clientY - rect.top;
                var h = rect.height;
                if (tid === 'root') return { nodeId: tid, position: 'child' };
                if (relY < h * 0.25) return { nodeId: tid, position: 'before' };
                if (relY > h * 0.75) return { nodeId: tid, position: 'after' };
                return { nodeId: tid, position: 'child' };
            }
            return null;
        }

        function endNodeDrag() {
            if (!nodeDragState.isDragging) return;
            var ghost = document.querySelector('.drag-ghost');
            if (ghost) ghost.remove();
            document.querySelectorAll('.node').forEach(function(el) {
                el.classList.remove('dragging', 'drag-over-child', 'drag-over-before', 'drag-over-after');
            });
            if (nodeDragState.targetNodeId && nodeDragState.targetPosition) {
                moveNodes(
                    nodeDragState.draggedNodeIds || [nodeDragState.nodeId],
                    nodeDragState.targetNodeId,
                    nodeDragState.targetPosition
                );
            }
            nodeDragState.isDragging = false;
            nodeDragState.nodeId = null;
            nodeDragState.draggedNodeIds = null;
            nodeDragState.targetNodeId = null;
            nodeDragState.targetPosition = null;
            render();
        }

        function moveNodes(nodeIds, targetId, position) {
            if (!nodeIds || nodeIds.length === 0) return;
            var targetResult = findNode(targetId);
            if (!targetResult) return;
            var filtered = filterTopLevelNodes(nodeIds);
            if (filtered.length === 0) return;
            saveState();
            var nodesToMove = [];
            for (var i = 0; i < filtered.length; i++) {
                var nr = findNode(filtered[i]);
                if (nr && nr.parent) nodesToMove.push({ id: filtered[i], data: nr.node, parent: nr.parent, index: nr.index });
            }
            nodesToMove.sort(function(a, b) { return a.parent === b.parent ? b.index - a.index : 0; });
            for (var i = 0; i < nodesToMove.length; i++) {
                var cur = findNode(nodesToMove[i].id);
                if (cur && cur.parent) cur.parent.children.splice(cur.index, 1);
            }
            nodesToMove.reverse();
            if (position === 'child') {
                for (var i = 0; i < nodesToMove.length; i++) {
                    var tr = findNode(targetId);
                    if (tr) tr.node.children.push(nodesToMove[i].data);
                }
            } else if (position === 'before') {
                for (var i = 0; i < nodesToMove.length; i++) {
                    var tr = findNode(targetId);
                    if (tr && tr.parent) tr.parent.children.splice(tr.index, 0, nodesToMove[i].data);
                }
            } else if (position === 'after') {
                nodesToMove.reverse();
                for (var i = 0; i < nodesToMove.length; i++) {
                    var tr = findNode(targetId);
                    if (tr && tr.parent) tr.parent.children.splice(tr.index + 1, 0, nodesToMove[i].data);
                }
            }
            selectedNodeIds.clear();
            for (var i = 0; i < nodesToMove.length; i++) selectedNodeIds.add(nodesToMove[i].id);
            lastSelectedNodeId = nodesToMove[0] ? nodesToMove[0].id : null;
        }

        // ========================================
        // Lasso (Rectangle) Selection
        // ========================================

        function startLasso(clientX, clientY) {
            lassoState.active = true;
            lassoState.didSelect = false;
            lassoState.startX = clientX;
            lassoState.startY = clientY;
            lassoState.currentX = clientX;
            lassoState.currentY = clientY;
            var rect = document.getElementById('lassoRect');
            rect.style.display = 'block';
            rect.style.left = clientX + 'px';
            rect.style.top = clientY + 'px';
            rect.style.width = '0px';
            rect.style.height = '0px';
        }

        function updateLasso(clientX, clientY) {
            if (!lassoState.active) return;
            lassoState.currentX = clientX;
            lassoState.currentY = clientY;
            var x = Math.min(lassoState.startX, clientX);
            var y = Math.min(lassoState.startY, clientY);
            var w = Math.abs(clientX - lassoState.startX);
            var h = Math.abs(clientY - lassoState.startY);
            var rect = document.getElementById('lassoRect');
            rect.style.left = x + 'px';
            rect.style.top = y + 'px';
            rect.style.width = w + 'px';
            rect.style.height = h + 'px';
        }

        function endLasso() {
            if (!lassoState.active) return;
            lassoState.active = false;
            var rect = document.getElementById('lassoRect');
            rect.style.display = 'none';

            var x1 = Math.min(lassoState.startX, lassoState.currentX);
            var y1 = Math.min(lassoState.startY, lassoState.currentY);
            var x2 = Math.max(lassoState.startX, lassoState.currentX);
            var y2 = Math.max(lassoState.startY, lassoState.currentY);

            // Require minimum size to avoid treating clicks as lasso
            if (Math.abs(x2 - x1) < 8 && Math.abs(y2 - y1) < 8) return;

            clearSelection();
            document.querySelectorAll('.node').forEach(function(el) {
                var r = el.getBoundingClientRect();
                var cx = r.left + r.width / 2;
                var cy = r.top + r.height / 2;
                if (cx >= x1 && cx <= x2 && cy >= y1 && cy <= y2) {
                    selectedNodeIds.add(el.dataset.id);
                }
            });
            if (selectedNodeIds.size > 0) {
                lastSelectedNodeId = selectedNodeIds.values().next().value;
                updateSelectionDisplay();
                lassoState.didSelect = true;
                showToast(selectedNodeIds.size + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„ÇíÈÅ∏Êäû„Åó„Åæ„Åó„Åü');
            }
        }

        // ========================================
        // Rendering
        // ========================================

        function render() {
            var container = document.getElementById('canvasInner');
            var svg = document.getElementById('linesSvg');
            container.querySelectorAll('.node').forEach(function(n) { n.remove(); });
            svg.innerHTML = '';

            // Pass 1: Measure actual node dimensions by creating temporary elements
            var nodeDims = measureNodeDimensions(mindMapData.root, container);

            // Pass 2: Layout with actual dimensions
            var positions = {};
            layoutNodes(mindMapData.root, positions, 0, 0, 1, nodeDims);

            // Pass 3: Render nodes and lines
            renderNodes(mindMapData.root, container, positions);
            renderLines(mindMapData.root, svg, positions);
            updateSelectionDisplay();
            updateView();
            // Auto-save to localStorage after every render (post-mutation state)
            saveToLocalStorage();
            // Update sidebar tree in real-time
            renderSidebarTree();
        }

        // Measure actual rendered width AND height of each node's text
        function measureNodeDimensions(rootNode, container) {
            var dims = {};
            // Create a measurer that exactly mirrors the .node DOM structure
            var measurer = document.createElement('div');
            measurer.className = 'node';
            measurer.style.position = 'absolute';
            measurer.style.visibility = 'hidden';
            measurer.style.pointerEvents = 'none';
            // Don't set transform since we just need dimensions
            var measurerText = document.createElement('span');
            measurerText.className = 'node-text';
            measurer.appendChild(measurerText);
            container.appendChild(measurer);

            function measure(node) {
                // Render \n as <br> for accurate measurement
                if (node.text.indexOf('\n') >= 0) {
                    measurerText.innerHTML = node.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
                } else {
                    measurerText.textContent = node.text;
                }
                // Root nodes have larger font
                if (node.id === 'root') {
                    measurer.classList.add('root');
                } else {
                    measurer.classList.remove('root');
                }
                dims[node.id] = { width: measurer.offsetWidth, height: measurer.offsetHeight };
                for (var i = 0; i < node.children.length; i++) {
                    measure(node.children[i]);
                }
            }
            measure(rootNode);
            container.removeChild(measurer);
            return dims;
        }

        function layoutNodes(node, positions, x, y, level, nodeDims) {
            if (x === undefined) x = 0;
            if (y === undefined) y = 0;
            if (level === undefined) level = 1;
            var dims = (nodeDims && nodeDims[node.id]) ? nodeDims[node.id] : { width: 150, height: 40 };
            var nodeWidth = dims.width;
            var nodeHeight = dims.height;
            var hGap = 40, vGap = 16;
            var totalH = 0, childHeights = [];
            for (var i = 0; i < node.children.length; i++) {
                var ch = calcSubtreeHeight(node.children[i], vGap, nodeDims);
                childHeights.push(ch);
                totalH += ch;
            }
            if (node.children.length > 1) totalH += (node.children.length - 1) * vGap;
            positions[node.id] = { x: x, y: y, width: nodeWidth, height: nodeHeight, level: level };
            var childX = x + nodeWidth + hGap;
            var childY = y - totalH / 2;
            for (var i = 0; i < node.children.length; i++) {
                var ch = childHeights[i];
                var centerY = childY + ch / 2;
                layoutNodes(node.children[i], positions, childX, centerY, level + 1, nodeDims);
                childY += ch + vGap;
            }
            return positions;
        }

        function calcSubtreeHeight(node, gap, nodeDims) {
            var dims = (nodeDims && nodeDims[node.id]) ? nodeDims[node.id] : { width: 150, height: 40 };
            var nodeHeight = dims.height;
            if (node.children.length === 0) return nodeHeight;
            var total = 0;
            for (var i = 0; i < node.children.length; i++) {
                total += calcSubtreeHeight(node.children[i], gap, nodeDims);
            }
            total += (node.children.length - 1) * gap;
            return Math.max(nodeHeight, total);
        }

        function renderNodes(node, container, positions) {
            var pos = positions[node.id];
            if (!pos) return;
            var el = document.createElement('div');
            el.className = 'node' + (node.id === 'root' ? ' root' : '');
            el.dataset.id = node.id;
            el.style.left = pos.x + 'px';
            el.style.top = pos.y + 'px';
            el.style.width = pos.width + 'px';
            el.style.transform = 'translateY(-50%)';
            var textEl = document.createElement('span');
            textEl.className = 'node-text';
            // Render \n as <br> for display
            if (node.text.indexOf('\n') >= 0) {
                textEl.innerHTML = node.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
            } else {
                textEl.textContent = node.text;
            }
            el.appendChild(textEl);

            // Use a closure to capture node reference
            (function(nodeData, nodeElement) {

                // Click handler: default to editing mode
                nodeElement.addEventListener('click', function(e) {
                    e.stopPropagation();

                    // If a drag just occurred, suppress click
                    if (nodeDragState.didDrag) {
                        nodeDragState.didDrag = false;
                        return;
                    }

                    var isMac = /Mac/.test(navigator.platform);
                    var cmdKey = isMac ? e.metaKey : e.ctrlKey;

                    if (cmdKey && e.shiftKey) {
                        finishEditing();
                        var allNodes = getAllNodesInOrder();
                        var si = -1, ei = -1;
                        for (var i = 0; i < allNodes.length; i++) {
                            if (allNodes[i].id === lastSelectedNodeId) si = i;
                            if (allNodes[i].id === nodeData.id) ei = i;
                        }
                        if (si !== -1 && ei !== -1) {
                            var mn = Math.min(si, ei), mx = Math.max(si, ei);
                            for (var i = mn; i <= mx; i++) selectedNodeIds.add(allNodes[i].id);
                            lastSelectedNodeId = nodeData.id;
                            updateSelectionDisplay();
                        }
                    } else if (e.shiftKey) {
                        finishEditing();
                        rangeSelectNode(nodeData.id);
                    } else if (cmdKey) {
                        finishEditing();
                        toggleSelectNode(nodeData.id);
                    } else {
                        // Normal click -> enter edit mode directly
                        if (editingNodeId === nodeData.id) return;
                        finishEditing();
                        selectNode(nodeData.id);
                        startEditing(nodeData.id);
                    }
                });

                // Double-click: enter edit mode (for when already selected but not editing)
                nodeElement.addEventListener('dblclick', function(e) {
                    e.stopPropagation();
                    startEditing(nodeData.id);
                });

                // Mousedown: start potential drag (only left button, no modifiers, not editing)
                nodeElement.addEventListener('mousedown', function(e) {
                    if (e.button !== 0) return;
                    if (editingNodeId) return;
                    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
                    e.preventDefault();
                    e.stopPropagation();
                    startNodeDrag(nodeData.id, e.clientX, e.clientY, nodeElement);
                });

            })(node, el);

            container.appendChild(el);
            for (var i = 0; i < node.children.length; i++) {
                renderNodes(node.children[i], container, positions);
            }
        }

        function renderLines(node, svg, positions) {
            var pp = positions[node.id];
            if (!pp) return;
            var off = 5000;
            for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];
                var cp = positions[child.id];
                if (!cp) continue;
                var sx = pp.x + pp.width + off, sy = pp.y + off;
                var ex = cp.x + off, ey = cp.y + off;
                var mx = sx + (ex - sx) / 2;
                var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'M ' + sx + ' ' + sy + ' C ' + mx + ' ' + sy + ', ' + mx + ' ' + ey + ', ' + ex + ' ' + ey);
                path.setAttribute('class', 'connection-line');
                svg.appendChild(path);
                renderLines(child, svg, positions);
            }
        }

        // ========================================
        // View Controls
        // ========================================

        function updateView() {
            var inner = document.getElementById('canvasInner');
            inner.style.transform = 'translate(' + viewState.panX + 'px, ' + viewState.panY + 'px) scale(' + viewState.zoom + ')';
        }

        function resetView() {
            var container = document.getElementById('canvasContainer');
            viewState.zoom = 1;
            viewState.panX = container.clientWidth / 2 - 75;
            viewState.panY = container.clientHeight / 2;
            updateView();
        }

        // ========================================
        // Keyboard Handler
        // ========================================

        function handleKeyDown(e) {
            var isMac = /Mac/.test(navigator.platform);
            var cmdKey = isMac ? e.metaKey : e.ctrlKey;

            // While editing
            if (editingNodeId) {
                // IMEÂÖ•Âäõ‰∏≠Ôºà„É≠„Éº„ÉûÂ≠ó‚ÜíÊó•Êú¨Ë™ûÂ§âÊèõÔºâ„ÅÆ„Ç≠„Éº„ÅØÁÑ°Ë¶ñ„Åô„Çã
                if (e.isComposing || e.keyCode === 229) return;

                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    finishEditing();
                } else if (e.key === 'Enter' && e.shiftKey) {
                    // Shift+Enter: insert line break
                    e.preventDefault();
                    var sel = window.getSelection();
                    if (sel.rangeCount) {
                        var range = sel.getRangeAt(0);
                        range.deleteContents();
                        var br = document.createElement('br');
                        range.insertNode(br);
                        // Insert a zero-width space after <br> so cursor has a text node to land in
                        var textNode = document.createTextNode('\u200B');
                        br.parentNode.insertBefore(textNode, br.nextSibling);
                        // Move cursor into the text node after <br>
                        range = document.createRange();
                        range.setStart(textNode, 1);
                        range.setEnd(textNode, 1);
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    finishEditing();
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    finishEditing();
                    if (e.shiftKey) { goToParent(); }
                    else { var cid = getSelectedNodeId(); if (cid) addChildNode(cid); }
                } else if (cmdKey && (e.key === 'z' || e.key === 'Z')) {
                    e.preventDefault(); finishEditing(); undo();
                } else if (cmdKey && (e.key === 'y' || e.key === 'Y')) {
                    e.preventDefault(); finishEditing(); redo();
                }
                return;
            }

            var currentId = getSelectedNodeId();

            switch (e.key) {
                case 'Enter':
                    e.preventDefault();
                    if (currentId) addSiblingNode(currentId);
                    break;
                case 'Tab':
                    e.preventDefault();
                    if (e.shiftKey) goToParent();
                    else if (currentId) addChildNode(currentId);
                    break;
                case 'Delete':
                case 'Backspace':
                    e.preventDefault();
                    if (selectedNodeIds.size > 1) deleteSelectedNodes();
                    else if (currentId && currentId !== 'root') deleteNode(currentId);
                    break;
                case 'F2':
                    e.preventDefault();
                    if (currentId) startEditing(currentId);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    if (cmdKey) { if (currentId) moveNodeUp(currentId); }
                    else if (e.shiftKey) { shiftNavigateUp(); }
                    else navigateUp();
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (cmdKey) { if (currentId) moveNodeDown(currentId); }
                    else if (e.shiftKey) { shiftNavigateDown(); }
                    else navigateDown();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (cmdKey) { if (currentId) promoteNode(currentId); }
                    else navigateLeft();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (cmdKey) { if (currentId) demoteNode(currentId); }
                    else navigateRight();
                    break;
                case 'z': case 'Z':
                    if (cmdKey) { e.preventDefault(); undo(); }
                    break;
                case 'y': case 'Y':
                    if (cmdKey) { e.preventDefault(); redo(); }
                    break;
                case 'a': case 'A':
                    if (cmdKey) { e.preventDefault(); selectAll(); }
                    break;
                case 'c': case 'C':
                    if (cmdKey) { e.preventDefault(); copySelectedNodes(); }
                    break;
                case 'v': case 'V':
                    if (cmdKey) { e.preventDefault(); pasteNode(); }
                    break;
                case 'x': case 'X':
                    if (cmdKey) { e.preventDefault(); cutSelectedNodes(); }
                    break;
                case 'Escape':
                    clearSelection();
                    break;
            }
        }

        // ========================================
        // Canvas Interaction: Pan, Zoom, Lasso
        // ========================================

        function initCanvasInteraction() {
            var canvas = document.getElementById('canvas');

            // --- Mousedown ---
            canvas.addEventListener('mousedown', function(e) {
                if (nodeDragState.isDragging) return;

                var isBackground = (e.target === canvas ||
                    e.target.id === 'canvasInner' ||
                    e.target.tagName === 'svg' ||
                    e.target.classList.contains('lines-svg'));

                if (!isBackground) return;

                // Right-click or middle-click: pan
                if (e.button === 2 || e.button === 1) {
                    e.preventDefault();
                    viewState.isPanning = true;
                    viewState.startX = e.clientX - viewState.panX;
                    viewState.startY = e.clientY - viewState.panY;
                    canvas.classList.add('panning');
                    return;
                }

                // Left-click on background: start lasso
                if (e.button === 0) {
                    finishEditing();
                    startLasso(e.clientX, e.clientY);
                }
            });

            // --- Mousemove ---
            canvas.addEventListener('mousemove', function(e) {
                if (nodeDragState.isDragging) return;
                if (viewState.isPanning) {
                    viewState.panX = e.clientX - viewState.startX;
                    viewState.panY = e.clientY - viewState.startY;
                    updateView();
                    return;
                }
                if (lassoState.active) {
                    updateLasso(e.clientX, e.clientY);
                }
            });

            // --- Mouseup ---
            canvas.addEventListener('mouseup', function(e) {
                if (viewState.isPanning) {
                    viewState.isPanning = false;
                    canvas.classList.remove('panning');
                    return;
                }
                if (lassoState.active) {
                    endLasso();
                }
            });

            // --- Click on background: clear selection ---
            canvas.addEventListener('click', function(e) {
                var isBackground = (e.target === canvas ||
                    e.target.id === 'canvasInner' ||
                    e.target.tagName === 'svg' ||
                    e.target.classList.contains('lines-svg'));

                if (!isBackground) return;

                // Don't clear if lasso just selected nodes
                if (lassoState.didSelect) {
                    lassoState.didSelect = false;
                    return;
                }
                finishEditing();
                clearSelection();
            });

            // --- Mouseleave ---
            canvas.addEventListener('mouseleave', function() {
                if (viewState.isPanning) {
                    viewState.isPanning = false;
                    canvas.classList.remove('panning');
                }
                if (lassoState.active) endLasso();
                if (nodeDragState.isDragging) endNodeDrag();
            });

            // --- Context menu prevention ---
            canvas.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });

            // --- Wheel: zoom (mouse scroll wheel) / pan (trackpad 2-finger) ---
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                var container = document.getElementById('canvasContainer');
                var rect = container.getBoundingClientRect();
                var mouseX = e.clientX - rect.left;
                var mouseY = e.clientY - rect.top;

                // ctrlKey is set by browser during trackpad pinch gesture
                if (e.ctrlKey) {
                    // Pinch zoom
                    var zoomDelta = -e.deltaY * 0.01;
                    applyZoom(mouseX, mouseY, zoomDelta);
                    return;
                }

                // Trackpad 2-finger scroll ‚Üí pan
                // Mouse scroll wheel ‚Üí zoom (deltaMode = 1 for line-based, or large deltaY)
                if (e.deltaMode === 0 && (Math.abs(e.deltaX) > 1 || Math.abs(e.deltaY) < 80)) {
                    // Likely trackpad: pan
                    viewState.panX -= e.deltaX;
                    viewState.panY -= e.deltaY;
                    updateView();
                } else {
                    // Mouse scroll wheel: zoom
                    var zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
                    applyZoom(mouseX, mouseY, zoomDelta);
                }
            }, { passive: false });

            // --- Touch events for pinch-zoom ---
            var lastTouchDist = 0;
            var lastTouchCenter = { x: 0, y: 0 };

            canvas.addEventListener('touchstart', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    var t1 = e.touches[0], t2 = e.touches[1];
                    lastTouchDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                    lastTouchCenter = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    var t1 = e.touches[0], t2 = e.touches[1];
                    var dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                    var center = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
                    var scale = dist / lastTouchDist;
                    var oldZoom = viewState.zoom;
                    var newZoom = Math.max(0.2, Math.min(3, oldZoom * scale));
                    var actualScale = newZoom / oldZoom;
                    viewState.panX = center.x - actualScale * (center.x - viewState.panX);
                    viewState.panY = center.y - actualScale * (center.y - viewState.panY);
                    viewState.zoom = newZoom;
                    viewState.panX += center.x - lastTouchCenter.x;
                    viewState.panY += center.y - lastTouchCenter.y;
                    lastTouchDist = dist;
                    lastTouchCenter = center;
                    updateView();
                }
            }, { passive: false });
        }

        function applyZoom(mouseX, mouseY, zoomDelta) {
            var oldZoom = viewState.zoom;
            var newZoom = Math.max(0.2, Math.min(3, oldZoom + zoomDelta));
            var scale = newZoom / oldZoom;
            viewState.panX = mouseX - scale * (mouseX - viewState.panX);
            viewState.panY = mouseY - scale * (mouseY - viewState.panY);
            viewState.zoom = newZoom;
            updateView();
        }

        // ========================================
        // Initialization
        // ========================================

        function init() {
            // Run migration from old storage format
            migrateIfNeeded();

            // Determine which map to load
            var urlParams = new URLSearchParams(window.location.search);
            var requestedId = urlParams.get('id') ? parseInt(urlParams.get('id'), 10) : null;
            var lastId = getLastActiveId();
            var metaList = getMetaList();

            if (requestedId && findMetaById(requestedId)) {
                currentMapId = requestedId;
            } else if (lastId && findMetaById(lastId)) {
                currentMapId = lastId;
            } else if (metaList.length > 0) {
                // Sort by updatedAt desc, pick first
                metaList.sort(function(a, b) { return (b.updatedAt || '').localeCompare(a.updatedAt || ''); });
                currentMapId = metaList[0].id;
            } else {
                // No maps exist at all, create one
                var newId = getNextMapId();
                var now = nowISO();
                var defaultData = { root: { id: 'root', text: '‰∏≠ÂøÉ„ÉÜ„Éº„Éû', children: [] } };
                saveMetaList([{ id: newId, name: 'ÁÑ°È°å„ÅÆ„Éû„ÉÉ„Éó', createdAt: now, updatedAt: now }]);
                try { localStorage.setItem(getMapDataKey(newId), JSON.stringify(defaultData)); } catch(e) {}
                currentMapId = newId;
            }

            // Load map data
            var saved = loadMapData(currentMapId);
            if (saved) {
                mindMapData = saved;
            }
            setLastActiveId(currentMapId);
            updateUrlParam(currentMapId);
            updatePageTitle();

            saveState();
            document.addEventListener('keydown', handleKeyDown);
            initCanvasInteraction();
            document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
            document.getElementById('resetBtn').addEventListener('click', resetMindMap);
            document.getElementById('sidebarMiniCopy').addEventListener('click', function(e) {
                e.stopPropagation();
                copyToClipboard();
            });

            // Persist format/border selection
            var savedFormat = localStorage.getItem('mindmap_copyFormat');
            var savedBorder = localStorage.getItem('mindmap_copyBorder');
            if (savedFormat) document.getElementById('copyFormat').value = savedFormat;
            document.getElementById('copyBorder').value = savedBorder || 'border';
            document.getElementById('copyFormat').addEventListener('change', function() {
                try { localStorage.setItem('mindmap_copyFormat', this.value); } catch(e) {}
                renderSidebarTree();
            });
            document.getElementById('copyBorder').addEventListener('change', function() {
                try { localStorage.setItem('mindmap_copyBorder', this.value); } catch(e) {}
                renderSidebarTree();
            });

            // Right sidebar resize & toggle
            initSidebar();
            // Left sidebar
            initLeftSidebar();
            // Adjust canvas for both sidebars
            adjustCanvasForSidebars();
            resetView();
            render();
            renderMapList();
            selectNode('root');
            setTimeout(function() { startEditing('root'); }, 100);

            // Close context menu on any click outside
            document.addEventListener('click', function(e) {
                var cm = document.getElementById('ctxMenu');
                if (cm && !cm.contains(e.target)) {
                    cm.classList.remove('show');
                    ctxMenuTargetMapId = null;
                }
            });
        }

        function updateUrlParam(mapId) {
            var url = new URL(window.location);
            url.searchParams.set('id', mapId);
            history.replaceState(null, '', url);
        }

        function updatePageTitle() {
            var meta = findMetaById(currentMapId);
            document.title = meta ? meta.name + ' - „Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó' : '„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó';
        }

        document.addEventListener('DOMContentLoaded', init);

        // ========================================
        // Right Sidebar: Resize, Tree Rendering, Focus
        // ========================================

        var SIDEBAR_MIN = 36;
        var SIDEBAR_OPEN_MIN = 200;
        var SIDEBAR_DEFAULT = 260;
        var SIDEBAR_KEY = 'mindmap_sidebar_width';

        function initSidebar() {
            var sidebar = document.getElementById('sidebar');
            var handle = document.getElementById('sidebarResizeHandle');
            var savedW = parseInt(localStorage.getItem(SIDEBAR_KEY), 10);
            var initialW = (savedW && savedW >= SIDEBAR_MIN) ? savedW : SIDEBAR_MIN;
            applySidebarWidth(initialW);

            var toggleBtn = document.getElementById('sidebarToggle');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    var currentW = parseInt(sidebar.style.width, 10) || SIDEBAR_MIN;
                    var newW = (currentW <= SIDEBAR_MIN) ? SIDEBAR_DEFAULT : SIDEBAR_MIN;
                    applySidebarWidth(newW);
                    try { localStorage.setItem(SIDEBAR_KEY, newW); } catch(ex) {}
                    renderSidebarTree();
                });
            }

            var dragging = false;
            handle.addEventListener('mousedown', function(e) {
                e.preventDefault();
                dragging = true;
                handle.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });
            document.addEventListener('mousemove', function(e) {
                if (!dragging) return;
                var w = window.innerWidth - e.clientX;
                if (w < (SIDEBAR_MIN + SIDEBAR_OPEN_MIN) / 2) {
                    w = SIDEBAR_MIN;
                } else if (w < SIDEBAR_OPEN_MIN) {
                    w = SIDEBAR_OPEN_MIN;
                } else if (w > window.innerWidth * 0.6) {
                    w = Math.floor(window.innerWidth * 0.6);
                }
                applySidebarWidth(w);
            });
            document.addEventListener('mouseup', function() {
                if (!dragging) return;
                dragging = false;
                handle.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                var currentW = parseInt(sidebar.style.width, 10) || SIDEBAR_MIN;
                try { localStorage.setItem(SIDEBAR_KEY, currentW); } catch(e) {}
                renderSidebarTree();
            });
        }

        function applySidebarWidth(w) {
            var sidebar = document.getElementById('sidebar');
            sidebar.style.width = w + 'px';
            var toggle = document.getElementById('sidebarToggle');
            if (w <= SIDEBAR_MIN) {
                sidebar.classList.add('collapsed');
                if (toggle) toggle.textContent = '‚óÄ';
            } else {
                sidebar.classList.remove('collapsed');
                if (toggle) toggle.textContent = '‚ñ∂';
            }
            adjustCanvasForSidebars();
        }

        function adjustCanvasForSidebars() {
            var rightSidebar = document.getElementById('sidebar');
            var leftSidebar = document.getElementById('leftSidebar');
            var container = document.getElementById('canvasContainer');
            if (container) {
                container.style.right = rightSidebar ? rightSidebar.offsetWidth + 'px' : '0';
                container.style.left = leftSidebar ? leftSidebar.offsetWidth + 'px' : '0';
            }
        }

        function renderSidebarTree() {
            var tree = document.getElementById('sidebarTree');
            if (!tree) return;
            var sidebar = document.getElementById('sidebar');
            if (sidebar && sidebar.classList.contains('collapsed')) {
                tree.innerHTML = '';
                return;
            }

            var format = document.getElementById('copyFormat').value;
            var border = document.getElementById('copyBorder').value;
            var useBorder = (border === 'border');
            var lines = [];
            generatePreviewLines(mindMapData.root, 0, [], format, useBorder, lines);

            var displayLines = [];
            for (var i = 0; i < lines.length; i++) {
                if (!lines[i].isSep) displayLines.push(lines[i]);
            }

            var html = '<pre class="sidebar-preview">';
            for (var i = 0; i < displayLines.length; i++) {
                var line = displayLines[i];
                var isSelected = selectedNodeIds.has(line.nodeId);
                var cls = 'sidebar-preview-line' + (isSelected ? ' active' : '');
                var escaped = line.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                html += '<span class="' + cls + '" data-sid="' + line.nodeId + '">' + escaped + '</span>';
                if (i < displayLines.length - 1) html += '\n';
            }
            html += '</pre>';
            tree.innerHTML = html;

            tree.querySelectorAll('.sidebar-preview-line').forEach(function(el) {
                el.addEventListener('click', function() {
                    var nid = el.getAttribute('data-sid');
                    if (nid) focusNodeFromSidebar(nid);
                });
            });

            var activeEl = tree.querySelector('.sidebar-preview-line.active');
            if (activeEl) {
                activeEl.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
            }
        }

        function generatePreviewLines(node, level, parentContinues, format, useBorder, lines) {
            var iconLevel = Math.min(level + 1, 4);
            var icons = levelIcons[format];
            var icon = icons ? (icons[iconLevel] + ' ') : '';

            var lineText = '';
            if (level === 0) {
                lineText = icon + node.text;
            } else {
                var prefix = '';
                for (var i = 0; i < level - 1; i++) {
                    if (useBorder) {
                        prefix += parentContinues[i] ? '‚îÇ  ' : '   ';
                    } else {
                        prefix += '  ';
                    }
                }
                var isLast = (parentContinues[level - 1] === false);
                var connector;
                if (useBorder) {
                    connector = isLast ? '‚îî‚îÄ ' : '‚îú‚îÄ ';
                } else {
                    connector = '  ';
                }
                lineText = prefix + connector + icon + node.text;
            }
            lineText = lineText.replace(/\n/g, ' ');
            lines.push({ text: lineText, nodeId: node.id });

            for (var i = 0; i < node.children.length; i++) {
                var isLastChild = (i === node.children.length - 1);
                var newContinues = parentContinues.slice();
                newContinues.push(!isLastChild);
                generatePreviewLines(node.children[i], level + 1, newContinues, format, useBorder, lines);
            }

            if (useBorder && level > 0 && node.children.length > 0) {
                var amILast = (parentContinues[level - 1] === false);
                if (!amILast) {
                    var sep = '';
                    for (var i = 0; i < level - 1; i++) {
                        sep += parentContinues[i] ? '‚îÇ  ' : '   ';
                    }
                    sep += '‚îÇ';
                    lines.push({ text: sep, nodeId: '', isSep: true });
                }
            }
        }

        function focusNodeFromSidebar(nodeId) {
            selectNode(nodeId);
            var nodeEl = document.querySelector('[data-id="' + nodeId + '"]');
            if (!nodeEl) return;
            var container = document.getElementById('canvasContainer');
            var sidebar = document.getElementById('sidebar');
            var sidebarW = sidebar ? sidebar.offsetWidth : 0;
            var rect = nodeEl.getBoundingClientRect();
            var cRect = container.getBoundingClientRect();
            var availableW = cRect.width - sidebarW;
            var targetX = cRect.left + availableW / 2;
            var targetY = cRect.top + cRect.height / 2;
            var dx = targetX - (rect.left + rect.width / 2);
            var dy = targetY - (rect.top + rect.height / 2);
            viewState.panX += dx;
            viewState.panY += dy;
            updateView();
            renderSidebarTree();
        }

        // ========================================
        // Left Sidebar: My Maps Management
        // ========================================

        var LEFT_SIDEBAR_MIN = 36;
        var LEFT_SIDEBAR_OPEN_MIN = 200;
        var LEFT_SIDEBAR_DEFAULT = 240;
        var LEFT_SIDEBAR_KEY = 'mindmap_left_sidebar_width';

        function initLeftSidebar() {
            var sidebar = document.getElementById('leftSidebar');
            var handle = document.getElementById('leftSidebarResizeHandle');
            var savedW = parseInt(localStorage.getItem(LEFT_SIDEBAR_KEY), 10);
            var initialW = (savedW && savedW >= LEFT_SIDEBAR_MIN) ? savedW : LEFT_SIDEBAR_MIN;
            applyLeftSidebarWidth(initialW);

            var toggleBtn = document.getElementById('leftSidebarToggle');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    var currentW = parseInt(sidebar.style.width, 10) || LEFT_SIDEBAR_MIN;
                    var newW = (currentW <= LEFT_SIDEBAR_MIN) ? LEFT_SIDEBAR_DEFAULT : LEFT_SIDEBAR_MIN;
                    applyLeftSidebarWidth(newW);
                    try { localStorage.setItem(LEFT_SIDEBAR_KEY, newW); } catch(ex) {}
                    renderMapList();
                });
            }

            // New map button
            document.getElementById('newMapBtn').addEventListener('click', function(e) {
                e.stopPropagation();
                createNewMap();
            });

            // Context menu actions
            document.getElementById('ctxMenu').addEventListener('click', function(e) {
                var action = e.target.getAttribute('data-action');
                if (!action || !ctxMenuTargetMapId) return;
                var cm = document.getElementById('ctxMenu');
                cm.classList.remove('show');
                var targetId = ctxMenuTargetMapId;
                ctxMenuTargetMapId = null;

                if (action === 'rename') {
                    startInlineRename(targetId);
                } else if (action === 'duplicate') {
                    duplicateMap(targetId);
                } else if (action === 'delete') {
                    deleteMap(targetId);
                }
            });

            // Resize handle
            var dragging = false;
            handle.addEventListener('mousedown', function(e) {
                e.preventDefault();
                dragging = true;
                handle.classList.add('dragging');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });
            document.addEventListener('mousemove', function(e) {
                if (!dragging) return;
                var w = e.clientX;
                if (w < (LEFT_SIDEBAR_MIN + LEFT_SIDEBAR_OPEN_MIN) / 2) {
                    w = LEFT_SIDEBAR_MIN;
                } else if (w < LEFT_SIDEBAR_OPEN_MIN) {
                    w = LEFT_SIDEBAR_OPEN_MIN;
                } else if (w > window.innerWidth * 0.4) {
                    w = Math.floor(window.innerWidth * 0.4);
                }
                applyLeftSidebarWidth(w);
            });
            document.addEventListener('mouseup', function() {
                if (!dragging) return;
                dragging = false;
                handle.classList.remove('dragging');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                var currentW = parseInt(sidebar.style.width, 10) || LEFT_SIDEBAR_MIN;
                try { localStorage.setItem(LEFT_SIDEBAR_KEY, currentW); } catch(e) {}
            });
        }

        function applyLeftSidebarWidth(w) {
            var sidebar = document.getElementById('leftSidebar');
            sidebar.style.width = w + 'px';
            var toggle = document.getElementById('leftSidebarToggle');
            if (w <= LEFT_SIDEBAR_MIN) {
                sidebar.classList.add('collapsed');
                if (toggle) toggle.textContent = '‚ñ∂';
            } else {
                sidebar.classList.remove('collapsed');
                if (toggle) toggle.textContent = '‚óÄ';
            }
            adjustCanvasForSidebars();
        }

        // ---- Render Map List ----
        function renderMapList() {
            var list = document.getElementById('mapList');
            if (!list) return;
            var metaList = getMetaList();
            // Sort by updatedAt desc
            metaList.sort(function(a, b) { return (b.updatedAt || '').localeCompare(a.updatedAt || ''); });

            list.innerHTML = '';
            for (var i = 0; i < metaList.length; i++) {
                var meta = metaList[i];
                var isActive = (meta.id === currentMapId);
                var item = document.createElement('div');
                item.className = 'map-item' + (isActive ? ' active' : '');
                item.dataset.mapId = meta.id;

                var icon = document.createElement('span');
                icon.className = 'map-item-icon';
                icon.textContent = isActive ? 'üìå' : 'üìÑ';

                var name = document.createElement('span');
                name.className = 'map-item-name';
                name.textContent = meta.name;
                name.title = meta.name;

                var menuBtn = document.createElement('button');
                menuBtn.className = 'map-item-menu-btn';
                menuBtn.textContent = '‚ãØ';
                menuBtn.title = '„É°„Éã„É•„Éº';

                item.appendChild(icon);
                item.appendChild(name);
                item.appendChild(menuBtn);

                // Click on item -> switch map
                (function(mapId) {
                    item.addEventListener('click', function(e) {
                        if (e.target === menuBtn || e.target.classList.contains('map-item-menu-btn')) return;
                        if (e.target.contentEditable === 'true') return;
                        switchToMap(mapId);
                    });
                    menuBtn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        showContextMenu(mapId, menuBtn);
                    });
                })(meta.id);

                list.appendChild(item);
            }
        }

        // ---- Context Menu ----
        function showContextMenu(mapId, anchorEl) {
            ctxMenuTargetMapId = mapId;
            var cm = document.getElementById('ctxMenu');
            var rect = anchorEl.getBoundingClientRect();
            cm.style.top = rect.bottom + 4 + 'px';
            cm.style.left = rect.left + 'px';
            // Ensure it doesn't go off-screen
            cm.classList.add('show');
            var cmRect = cm.getBoundingClientRect();
            if (cmRect.right > window.innerWidth) {
                cm.style.left = (window.innerWidth - cmRect.width - 8) + 'px';
            }
            if (cmRect.bottom > window.innerHeight) {
                cm.style.top = (rect.top - cmRect.height - 4) + 'px';
            }
            // Mark the menu button as open
            document.querySelectorAll('.map-item-menu-btn.open').forEach(function(el) { el.classList.remove('open'); });
            anchorEl.classList.add('open');
        }

        // ---- Map CRUD ----
        function createNewMap() {
            // Save current map first
            saveToLocalStorage();

            var newId = getNextMapId();
            var now = nowISO();
            var defaultData = { root: { id: 'root', text: '‰∏≠ÂøÉ„ÉÜ„Éº„Éû', children: [] } };
            var meta = { id: newId, name: 'ÁÑ°È°å„ÅÆ„Éû„ÉÉ„Éó', createdAt: now, updatedAt: now };

            var metaList = getMetaList();
            metaList.push(meta);
            saveMetaList(metaList);
            try { localStorage.setItem(getMapDataKey(newId), JSON.stringify(defaultData)); } catch(e) {}

            switchToMap(newId);
            showToast('üìÑ Êñ∞„Åó„ÅÑ„Éû„ÉÉ„Éó„Çí‰ΩúÊàê„Åó„Åæ„Åó„Åü');
        }

        function switchToMap(mapId) {
            if (mapId === currentMapId) return;

            // Save current map
            saveToLocalStorage();

            // Load new map
            var data = loadMapData(mapId);
            if (!data) {
                showToast('„Éû„ÉÉ„Éó„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì');
                return;
            }

            // Reset state
            finishEditing();
            selectedNodeIds.clear();
            lastSelectedNodeId = null;
            selectionAnchorId = null;
            editingNodeId = null;
            undoHistory = [];
            undoIndex = -1;
            clipboard = null;
            clipboardIsCut = false;

            currentMapId = mapId;
            mindMapData = data;
            setLastActiveId(mapId);
            updateUrlParam(mapId);
            updatePageTitle();

            saveState();
            render();
            resetView();
            renderMapList();
            selectNode('root');
        }

        function duplicateMap(mapId) {
            var srcMeta = findMetaById(mapId);
            if (!srcMeta) return;

            var srcData = loadMapData(mapId);
            if (!srcData) return;

            var newId = getNextMapId();
            var now = nowISO();
            var newMeta = {
                id: newId,
                name: srcMeta.name + ' „ÅÆ„Ç≥„Éî„Éº',
                createdAt: now,
                updatedAt: now
            };

            var metaList = getMetaList();
            metaList.push(newMeta);
            saveMetaList(metaList);
            try { localStorage.setItem(getMapDataKey(newId), JSON.stringify(deepClone(srcData))); } catch(e) {}

            renderMapList();
            showToast('üìë „Éû„ÉÉ„Éó„ÇíË§áË£Ω„Åó„Åæ„Åó„Åü');
        }

        function deleteMap(mapId) {
            var metaList = getMetaList();
            if (metaList.length <= 1) {
                showToast('‚ö†Ô∏è ÊúÄÂæå„ÅÆ„Éû„ÉÉ„Éó„ÅØÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì');
                return;
            }
            if (!confirm('„Åì„ÅÆ„Éû„ÉÉ„Éó„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) return;

            // Remove from meta
            var newMeta = [];
            for (var i = 0; i < metaList.length; i++) {
                if (metaList[i].id !== mapId) newMeta.push(metaList[i]);
            }
            saveMetaList(newMeta);
            try { localStorage.removeItem(getMapDataKey(mapId)); } catch(e) {}

            if (mapId === currentMapId) {
                // Switch to first available
                newMeta.sort(function(a, b) { return (b.updatedAt || '').localeCompare(a.updatedAt || ''); });
                switchToMap(newMeta[0].id);
            } else {
                renderMapList();
            }
            showToast('üóë „Éû„ÉÉ„Éó„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
        }

        function startInlineRename(mapId) {
            var item = document.querySelector('.map-item[data-map-id="' + mapId + '"]');
            if (!item) return;
            var nameEl = item.querySelector('.map-item-name');
            if (!nameEl) return;

            nameEl.contentEditable = 'true';
            nameEl.focus();
            // Select all text
            var range = document.createRange();
            range.selectNodeContents(nameEl);
            var sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);

            function finish() {
                nameEl.contentEditable = 'false';
                var newName = nameEl.textContent.trim() || 'ÁÑ°È°å„ÅÆ„Éû„ÉÉ„Éó';
                nameEl.textContent = newName;

                var metaList = getMetaList();
                for (var i = 0; i < metaList.length; i++) {
                    if (metaList[i].id === mapId) {
                        metaList[i].name = newName;
                        metaList[i].updatedAt = nowISO();
                        break;
                    }
                }
                saveMetaList(metaList);
                if (mapId === currentMapId) updatePageTitle();
                renderMapList();
                nameEl.removeEventListener('blur', finish);
                nameEl.removeEventListener('keydown', onKey);
            }

            function onKey(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finish();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    nameEl.contentEditable = 'false';
                    renderMapList(); // revert
                    nameEl.removeEventListener('blur', finish);
                    nameEl.removeEventListener('keydown', onKey);
                }
            }

            nameEl.addEventListener('blur', finish);
            nameEl.addEventListener('keydown', onKey);
        }

        // Expose for testing/integration
        window.getCurrentCopyText = getCurrentCopyText;
        window.getSelectedNodeIds = function() { return selectedNodeIds; };
        window.getMindMapData = function() { return mindMapData; };
        window.getCurrentMapId = function() { return currentMapId; };
        window.getMetaList = getMetaList;
        window.switchToMap = switchToMap;
        window.createNewMap = createNewMap;

    })();
    </script>
</body>
</html>
