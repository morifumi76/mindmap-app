<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó</title>
    <link rel="icon" type="image/png" href="data:image/png;base64,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" />
    <style>
        /* ========================================
           CSS Variables & Reset
           ======================================== */
        :root {
            --primary-color: #4a90d9;
            --primary-hover: #357abd;
            --bg-color: #f5f7fa;
            --node-bg: #ffffff;
            --node-border: #4a90d9;
            --node-selected: #e3f2fd;
            --text-color: #333333;
            --line-color: #999999;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
            --font-family: 'Meiryo UI', '„É°„Ç§„É™„Ç™', Meiryo, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            font-family: var(--font-family);
            background: var(--bg-color);
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        /* ========================================
           Canvas Container (Full Screen - No Toolbar)
           ======================================== */
        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            background: var(--bg-color);
            background-image:
                radial-gradient(circle, #ddd 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: default;
        }

        .canvas.panning {
            cursor: grabbing;
        }

        .canvas-inner {
            position: absolute;
            transform-origin: 0 0;
        }

        /* ========================================
           SVG Lines
           ======================================== */
        .lines-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 10000px;
            height: 10000px;
            overflow: visible;
            transform: translate(-5000px, -5000px);
            pointer-events: none;
        }

        .connection-line {
            fill: none;
            stroke: var(--line-color);
            stroke-width: 2;
            stroke-linecap: round;
            pointer-events: none;
        }

        /* ========================================
           Node Styles
           ======================================== */
        .node {
            position: absolute;
            min-width: 120px;
            max-width: 300px;
            padding: 10px 16px;
            background: var(--node-bg);
            border: 2px solid var(--node-border);
            border-radius: 8px;
            box-shadow: var(--shadow);
            cursor: pointer;
            user-select: none;
            transition: box-shadow 0.2s;
            white-space: normal;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .node:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .node.selected {
            background: var(--node-selected);
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 144, 217, 0.3);
        }

        .node.root {
            font-size: 16px;
            font-weight: bold;
            border-width: 3px;
        }

        .node.editing {
            cursor: text;
        }

        .node.dragging {
            opacity: 0.4;
            z-index: 1000;
        }

        .node.drag-over-child {
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.5);
            border-color: #4caf50;
        }

        .node.drag-over-before {
            border-top: 4px solid #2196f3;
        }

        .node.drag-over-after {
            border-bottom: 4px solid #2196f3;
        }

        .node-text {
            outline: none;
            min-width: 50px;
            display: block;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .node-text[contenteditable="true"] {
            cursor: text;
            background: rgba(255,255,255,0.8);
            padding: 2px 4px;
            margin: -2px -4px;
            border-radius: 3px;
        }

        /* ========================================
           Drag Ghost
           ======================================== */
        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 2000;
            opacity: 0.8;
            transform: rotate(2deg);
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        }

        /* ========================================
           Lasso Selection Rectangle
           ======================================== */
        .lasso-rect {
            position: fixed;
            border: 2px dashed var(--primary-color);
            background: rgba(74, 144, 217, 0.08);
            pointer-events: none;
            z-index: 900;
            display: none;
        }

        /* ========================================
           Copy Button (Floating, Bottom-Right)
           ======================================== */
        .copy-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            z-index: 500;
            background: #ffffff;
            padding: 10px 14px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            border: 1px solid #e0e0e0;
        }

        .copy-panel select {
            font-family: var(--font-family);
            font-size: 13px;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #f9f9f9;
            color: var(--text-color);
            cursor: pointer;
            outline: none;
            transition: border-color 0.2s;
        }

        .copy-panel select:focus {
            border-color: var(--primary-color);
        }

        .copy-btn, .preview-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            background: var(--primary-color);
            color: white;
            font-family: var(--font-family);
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            white-space: nowrap;
        }

        .preview-btn {
            background: #6c757d;
        }

        .preview-btn:hover {
            background: #5a6268;
        }

        .copy-btn:hover {
            background: var(--primary-hover);
        }

        .copy-btn:active, .preview-btn:active, .reset-btn:active {
            transform: scale(0.97);
        }

        .reset-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            background: #e53935;
            color: white;
            font-family: var(--font-family);
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            white-space: nowrap;
        }

        .reset-btn:hover {
            background: #c62828;
        }

        /* ========================================
           Preview Modal
           ======================================== */
        .preview-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .preview-overlay.show {
            display: flex;
        }

        .preview-modal {
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            width: 90%;
            max-width: 680px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .preview-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f9fa;
        }

        .preview-header h3 {
            font-size: 15px;
            color: var(--text-color);
            font-family: var(--font-family);
        }

        .preview-header-btns {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .preview-copy-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 6px 14px;
            border: none;
            border-radius: 6px;
            background: var(--primary-color);
            color: white;
            font-family: var(--font-family);
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        .preview-copy-btn:hover {
            background: var(--primary-hover);
        }

        .preview-close-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            background: transparent;
            color: #666;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .preview-close-btn:hover {
            background: #e0e0e0;
        }

        .preview-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .preview-body pre {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.7;
            color: var(--text-color);
            background: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 8px;
            padding: 16px 20px;
            white-space: pre;
            overflow-x: auto;
            margin: 0;
        }

        /* ========================================
           Toast Notification
           ======================================== */
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 3000;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    </style>
</head>
<body>

    <!-- Canvas Container (Full Screen) -->
    <div class="canvas-container" id="canvasContainer">
        <div class="canvas" id="canvas">
            <div class="canvas-inner" id="canvasInner">
                <svg class="lines-svg" id="linesSvg"></svg>
            </div>
        </div>
    </div>

    <!-- Copy Panel (Floating Bottom-Right) -->
    <div class="copy-panel" id="copyPanel">
        <select id="copyFormat" title="Âá∫ÂäõÂΩ¢Âºè">
            <option value="simple">„Ç∑„É≥„Éó„É´</option>
            <option value="hiyoko">„Å≤„Çà„Åì„É¢„Éº„Éâ üêî</option>
        </select>
        <select id="copyBorder" title="ÁΩ´Á∑ö">
            <option value="none">ÁΩ´Á∑ö„Å™„Åó</option>
            <option value="border">ÁΩ´Á∑ö„ÅÇ„Çä</option>
        </select>
        <button class="preview-btn" id="previewBtn" title="„Éó„É¨„Éì„É•„Éº">
            üëÅ „Éó„É¨„Éì„É•„Éº
        </button>
        <button class="copy-btn" id="copyBtn" title="„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº">
            üìã „Ç≥„Éî„Éº
        </button>
        <button class="reset-btn" id="resetBtn" title="„Éû„ÉÉ„Éó„Çí„É™„Çª„ÉÉ„Éà">
            üóë „É™„Çª„ÉÉ„Éà
        </button>
    </div>

    <!-- Preview Modal -->
    <div class="preview-overlay" id="previewOverlay">
        <div class="preview-modal">
            <div class="preview-header">
                <h3>üìÑ „Ç≥„Éî„ÉºÂÜÖÂÆπ„Éó„É¨„Éì„É•„Éº</h3>
                <div class="preview-header-btns">
                    <button class="preview-copy-btn" id="previewCopyBtn">üìã „Ç≥„Éî„Éº</button>
                    <button class="preview-close-btn" id="previewCloseBtn">&times;</button>
                </div>
            </div>
            <div class="preview-body">
                <pre id="previewContent"></pre>
            </div>
        </div>
    </div>

    <!-- Lasso Selection Rectangle -->
    <div class="lasso-rect" id="lassoRect"></div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
    (function() {
        'use strict';

        // ========================================
        // Global State
        // ========================================

        const levelIcons = { 1: 'üêî', 2: 'üê§', 3: 'üê£', 4: 'ü•ö' };

        let mindMapData = {
            root: {
                id: 'root',
                text: '‰∏≠ÂøÉ„ÉÜ„Éº„Éû',
                children: []
            }
        };

        let selectedNodeIds = new Set();
        let lastSelectedNodeId = null;
        let editingNodeId = null;

        let viewState = {
            zoom: 1,
            panX: 0,
            panY: 0,
            isPanning: false,
            startX: 0,
            startY: 0
        };

        let undoHistory = [];
        let undoIndex = -1;
        const MAX_HISTORY = 50;

        let clipboard = null;
        let clipboardIsCut = false;

        let nodeIdCounter = 0;

        // Drag reparenting state
        let nodeDragState = {
            isDragging: false,
            didDrag: false,     // true if actual drag occurred (to suppress click)
            nodeId: null,
            draggedNodeIds: null,
            targetNodeId: null,
            targetPosition: null
        };

        // Lasso selection state
        let lassoState = {
            active: false,
            didSelect: false,   // true if lasso selected nodes (to suppress click clear)
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0
        };

        // ========================================
        // Utility Functions
        // ========================================

        function generateId() {
            return 'node_' + (++nodeIdCounter) + '_' + Date.now();
        }

        function deepClone(obj) {
            return JSON.parse(JSON.stringify(obj));
        }

        function showToast(message, duration) {
            duration = duration || 2000;
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            clearTimeout(toast._tid);
            toast._tid = setTimeout(function() {
                toast.classList.remove('show');
            }, duration);
        }

        // ========================================
        // History Management (Undo/Redo)
        // ========================================

        const STORAGE_KEY = 'mindmap_data_v2';

        function saveState() {
            undoHistory = undoHistory.slice(0, undoIndex + 1);
            undoHistory.push(deepClone(mindMapData));
            if (undoHistory.length > MAX_HISTORY) {
                undoHistory.shift();
            } else {
                undoIndex++;
            }
            // Auto-save to localStorage
            saveToLocalStorage();
        }

        function saveToLocalStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(mindMapData));
            } catch(e) { /* quota exceeded or private mode */ }
        }

        function loadFromLocalStorage() {
            try {
                var data = localStorage.getItem(STORAGE_KEY);
                if (data) {
                    var parsed = JSON.parse(data);
                    if (parsed && parsed.root && parsed.root.id === 'root') {
                        return parsed;
                    }
                }
            } catch(e) { /* invalid data */ }
            return null;
        }

        function resetMindMap() {
            if (!confirm('„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü\n„Åô„Åπ„Å¶„ÅÆ„Éé„Éº„Éâ„ÅåÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ')) return;
            mindMapData = {
                root: { id: 'root', text: '‰∏≠ÂøÉ„ÉÜ„Éº„Éû', children: [] }
            };
            undoHistory = [];
            undoIndex = -1;
            selectedNodeIds.clear();
            lastSelectedNodeId = null;
            editingNodeId = null;
            clipboard = null;
            clipboardIsCut = false;
            try { localStorage.removeItem(STORAGE_KEY); } catch(e) {}
            saveState();
            render();
            resetView();
            selectNode('root');
            setTimeout(function() { startEditing('root'); }, 100);
            showToast('üóë „É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü');
        }

        function undo() {
            if (undoIndex > 0) {
                undoIndex--;
                mindMapData = deepClone(undoHistory[undoIndex]);
                render();
                showToast('ÂÖÉ„Å´Êàª„Åó„Åæ„Åó„Åü');
            }
        }

        function redo() {
            if (undoIndex < undoHistory.length - 1) {
                undoIndex++;
                mindMapData = deepClone(undoHistory[undoIndex]);
                render();
                showToast('„ÇÑ„ÇäÁõ¥„Åó„Åæ„Åó„Åü');
            }
        }

        // ========================================
        // Node Operations
        // ========================================

        function findNode(id, node, parent, index) {
            if (node === undefined) node = mindMapData.root;
            if (parent === undefined) parent = null;
            if (index === undefined) index = 0;
            if (node.id === id) return { node: node, parent: parent, index: index };
            for (var i = 0; i < node.children.length; i++) {
                var result = findNode(id, node.children[i], node, i);
                if (result) return result;
            }
            return null;
        }

        function getNodeLevel(id, node, level) {
            if (node === undefined) node = mindMapData.root;
            if (level === undefined) level = 1;
            if (node.id === id) return level;
            for (var i = 0; i < node.children.length; i++) {
                var result = getNodeLevel(id, node.children[i], level + 1);
                if (result) return result;
            }
            return null;
        }

        function getAllNodesInOrder(node, result) {
            if (node === undefined) node = mindMapData.root;
            if (result === undefined) result = [];
            result.push(node);
            for (var i = 0; i < node.children.length; i++) {
                getAllNodesInOrder(node.children[i], result);
            }
            return result;
        }

        function addChildNode(parentId, text, autoEdit) {
            if (text === undefined) text = 'Êñ∞„Åó„ÅÑ„Éé„Éº„Éâ';
            if (autoEdit === undefined) autoEdit = true;
            var result = findNode(parentId);
            if (!result) return null;
            saveState();
            var newNode = { id: generateId(), text: text, children: [] };
            result.node.children.push(newNode);
            render();
            selectNode(newNode.id);
            if (autoEdit) {
                setTimeout(function() { startEditing(newNode.id); }, 50);
            }
            return newNode;
        }

        function addSiblingNode(nodeId, text, autoEdit) {
            if (text === undefined) text = 'Êñ∞„Åó„ÅÑ„Éé„Éº„Éâ';
            if (autoEdit === undefined) autoEdit = true;
            var result = findNode(nodeId);
            if (!result || !result.parent) {
                return addChildNode(nodeId, text, autoEdit);
            }
            saveState();
            var newNode = { id: generateId(), text: text, children: [] };
            result.parent.children.splice(result.index + 1, 0, newNode);
            render();
            selectNode(newNode.id);
            if (autoEdit) {
                setTimeout(function() { startEditing(newNode.id); }, 50);
            }
            return newNode;
        }

        function deleteNode(nodeId) {
            if (nodeId === 'root') {
                showToast('„É´„Éº„Éà„Éé„Éº„Éâ„ÅØÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì');
                return false;
            }
            var result = findNode(nodeId);
            if (!result || !result.parent) return false;
            saveState();
            result.parent.children.splice(result.index, 1);
            if (result.parent.children.length > 0) {
                var idx = Math.min(result.index, result.parent.children.length - 1);
                selectNode(result.parent.children[idx].id);
            } else {
                selectNode(result.parent.id);
            }
            render();
            return true;
        }

        function deleteSelectedNodes() {
            if (selectedNodeIds.size === 0) return;
            var ids = [];
            selectedNodeIds.forEach(function(id) { if (id !== 'root') ids.push(id); });
            if (ids.length === 0) {
                showToast('„É´„Éº„Éà„Éé„Éº„Éâ„ÅØÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì');
                return;
            }
            var filtered = filterTopLevelNodes(ids);
            saveState();
            var lastParent = null;
            for (var i = 0; i < filtered.length; i++) {
                var r = findNode(filtered[i]);
                if (r && r.parent) {
                    lastParent = r.parent;
                    r.parent.children.splice(r.index, 1);
                }
            }
            selectedNodeIds.clear();
            if (lastParent && lastParent.children.length > 0) {
                selectNode(lastParent.children[0].id);
            } else if (lastParent) {
                selectNode(lastParent.id);
            } else {
                selectNode('root');
            }
            render();
            showToast(filtered.length + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
        }

        function updateNodeText(nodeId, newText) {
            var result = findNode(nodeId);
            if (result && result.node.text !== newText) {
                saveState();
                result.node.text = newText;
            }
        }

        function moveNodeUp(nodeId) {
            var result = findNode(nodeId);
            if (result && result.parent && result.index > 0) {
                saveState();
                var s = result.parent.children;
                var tmp = s[result.index - 1];
                s[result.index - 1] = s[result.index];
                s[result.index] = tmp;
                render();
            }
        }

        function moveNodeDown(nodeId) {
            var result = findNode(nodeId);
            if (result && result.parent && result.index < result.parent.children.length - 1) {
                saveState();
                var s = result.parent.children;
                var tmp = s[result.index];
                s[result.index] = s[result.index + 1];
                s[result.index + 1] = tmp;
                render();
            }
        }

        function promoteNode(nodeId) {
            var result = findNode(nodeId);
            if (!result || !result.parent || result.parent.id === 'root') return;
            var gpResult = findNode(result.parent.id);
            if (gpResult && gpResult.parent) {
                saveState();
                result.parent.children.splice(result.index, 1);
                gpResult.parent.children.splice(gpResult.index + 1, 0, result.node);
                render();
                selectNode(nodeId);
            }
        }

        function demoteNode(nodeId) {
            var result = findNode(nodeId);
            if (!result || !result.parent || result.index === 0) return;
            saveState();
            var prevSibling = result.parent.children[result.index - 1];
            result.parent.children.splice(result.index, 1);
            prevSibling.children.push(result.node);
            render();
            selectNode(nodeId);
        }

        // ========================================
        // Selection & Navigation
        // ========================================

        function selectNode(nodeId) {
            clearSelection();
            if (nodeId) {
                selectedNodeIds.add(nodeId);
                lastSelectedNodeId = nodeId;
                updateSelectionDisplay();
                scrollNodeIntoView(nodeId);
            }
        }

        function clearSelection() {
            selectedNodeIds.clear();
            lastSelectedNodeId = null;
            document.querySelectorAll('.node.selected').forEach(function(el) {
                el.classList.remove('selected');
            });
        }

        function updateSelectionDisplay() {
            document.querySelectorAll('.node').forEach(function(el) {
                el.classList.toggle('selected', selectedNodeIds.has(el.dataset.id));
            });
        }

        function toggleSelectNode(nodeId) {
            if (selectedNodeIds.has(nodeId)) {
                selectedNodeIds.delete(nodeId);
            } else {
                selectedNodeIds.add(nodeId);
            }
            lastSelectedNodeId = nodeId;
            updateSelectionDisplay();
        }

        function rangeSelectNode(nodeId) {
            if (!lastSelectedNodeId) { selectNode(nodeId); return; }
            var allNodes = getAllNodesInOrder();
            var si = -1, ei = -1;
            for (var i = 0; i < allNodes.length; i++) {
                if (allNodes[i].id === lastSelectedNodeId) si = i;
                if (allNodes[i].id === nodeId) ei = i;
            }
            if (si === -1 || ei === -1) { selectNode(nodeId); return; }
            var mn = Math.min(si, ei), mx = Math.max(si, ei);
            clearSelection();
            for (var i = mn; i <= mx; i++) {
                selectedNodeIds.add(allNodes[i].id);
            }
            lastSelectedNodeId = nodeId;
            updateSelectionDisplay();
        }

        function getSelectedNodeId() {
            if (selectedNodeIds.size === 0) return null;
            return lastSelectedNodeId || selectedNodeIds.values().next().value;
        }

        function getSelectedNodes() {
            var nodes = [];
            selectedNodeIds.forEach(function(id) {
                var r = findNode(id);
                if (r) nodes.push(r.node);
            });
            return nodes;
        }

        // Navigate UP: same-level siblings only
        function navigateUp() {
            var cid = getSelectedNodeId();
            if (!cid) { selectNode('root'); return; }
            var r = findNode(cid);
            if (r && r.parent && r.index > 0) {
                selectNode(r.parent.children[r.index - 1].id);
            }
        }

        // Navigate DOWN: same-level siblings only
        function navigateDown() {
            var cid = getSelectedNodeId();
            if (!cid) { selectNode('root'); return; }
            var r = findNode(cid);
            if (r && r.parent && r.index < r.parent.children.length - 1) {
                selectNode(r.parent.children[r.index + 1].id);
            }
        }

        // Navigate LEFT: go to parent
        function navigateLeft() {
            var cid = getSelectedNodeId();
            if (!cid) { selectNode('root'); return; }
            var r = findNode(cid);
            if (r && r.parent) selectNode(r.parent.id);
        }

        // Navigate RIGHT: go to first child
        function navigateRight() {
            var cid = getSelectedNodeId();
            if (!cid) { selectNode('root'); return; }
            var r = findNode(cid);
            if (r && r.node.children.length > 0) {
                selectNode(r.node.children[0].id);
            }
        }

        function goToParent() {
            var cid = getSelectedNodeId();
            if (!cid || cid === 'root') return;
            var r = findNode(cid);
            if (r && r.parent) selectNode(r.parent.id);
        }

        function scrollNodeIntoView(nodeId) {
            var nodeEl = document.querySelector('[data-id="' + nodeId + '"]');
            if (!nodeEl) return;
            var container = document.getElementById('canvasContainer');
            var rect = nodeEl.getBoundingClientRect();
            var cRect = container.getBoundingClientRect();
            var margin = 60;
            var dx = 0, dy = 0;
            if (rect.left < cRect.left + margin) dx = cRect.left + margin - rect.left;
            else if (rect.right > cRect.right - margin) dx = cRect.right - margin - rect.right;
            if (rect.top < cRect.top + margin) dy = cRect.top + margin - rect.top;
            else if (rect.bottom > cRect.bottom - margin - 80) dy = cRect.bottom - margin - 80 - rect.bottom;
            if (dx !== 0 || dy !== 0) {
                viewState.panX += dx;
                viewState.panY += dy;
                updateView();
            }
        }

        // ========================================
        // Edit Mode
        // ========================================

        function startEditing(nodeId) {
            if (editingNodeId === nodeId) return;
            if (editingNodeId) finishEditing();
            editingNodeId = nodeId;
            // Select without clearing other selection state, just ensure this node is selected
            if (!selectedNodeIds.has(nodeId)) {
                selectNode(nodeId);
            }
            var nodeEl = document.querySelector('[data-id="' + nodeId + '"]');
            var textEl = nodeEl ? nodeEl.querySelector('.node-text') : null;
            if (textEl) {
                nodeEl.classList.add('editing');
                textEl.contentEditable = 'true';
                textEl.focus();
                var range = document.createRange();
                range.selectNodeContents(textEl);
                var sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
        }

        function finishEditing() {
            if (!editingNodeId) return;
            var prevEditingId = editingNodeId;
            var nodeEl = document.querySelector('[data-id="' + editingNodeId + '"]');
            var textEl = nodeEl ? nodeEl.querySelector('.node-text') : null;
            var textChanged = false;
            if (textEl) {
                var newText = textEl.textContent.trim() || 'Á©∫„ÅÆ„Éé„Éº„Éâ';
                var result = findNode(editingNodeId);
                if (result && result.node.text !== newText) {
                    textChanged = true;
                }
                updateNodeText(editingNodeId, newText);
                textEl.contentEditable = 'false';
                nodeEl.classList.remove('editing');
            }
            editingNodeId = null;
            // Re-render to recalculate layout when text changed
            if (textChanged) {
                render();
                // Re-select the previously edited node
                selectNode(prevEditingId);
            }
        }

        // ========================================
        // Copy, Cut & Paste
        // ========================================

        function copySelectedNodes() {
            if (selectedNodeIds.size === 0) return;
            if (selectedNodeIds.size === 1) {
                var id = getSelectedNodeId();
                var r = findNode(id);
                if (r) {
                    clipboard = deepClone(r.node);
                    clipboardIsCut = false;
                    showToast('„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
                }
            } else {
                var topLevel = filterTopLevelNodes(Array.from(selectedNodeIds));
                var nodes = [];
                for (var i = 0; i < topLevel.length; i++) {
                    var r = findNode(topLevel[i]);
                    if (r) nodes.push(deepClone(r.node));
                }
                if (nodes.length > 0) {
                    clipboard = nodes;
                    clipboardIsCut = false;
                    showToast(nodes.length + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
                }
            }
        }

        function cutSelectedNodes() {
            if (selectedNodeIds.size === 0) return;
            var ids = [];
            selectedNodeIds.forEach(function(id) { if (id !== 'root') ids.push(id); });
            if (ids.length === 0) {
                showToast('„É´„Éº„Éà„Éé„Éº„Éâ„ÅØÂàá„ÇäÂèñ„Çå„Åæ„Åõ„Çì');
                return;
            }
            var topLevel = filterTopLevelNodes(ids);
            var nodes = [];
            for (var i = 0; i < topLevel.length; i++) {
                var r = findNode(topLevel[i]);
                if (r) nodes.push(deepClone(r.node));
            }
            if (nodes.length === 0) return;
            clipboard = nodes.length === 1 ? nodes[0] : nodes;
            clipboardIsCut = true;

            saveState();
            var lastParent = null;
            for (var i = 0; i < topLevel.length; i++) {
                var r = findNode(topLevel[i]);
                if (r && r.parent) {
                    lastParent = r.parent;
                    r.parent.children.splice(r.index, 1);
                }
            }
            selectedNodeIds.clear();
            if (lastParent && lastParent.children.length > 0) {
                selectNode(lastParent.children[0].id);
            } else if (lastParent) {
                selectNode(lastParent.id);
            } else {
                selectNode('root');
            }
            render();
            showToast(topLevel.length + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„ÇíÂàá„ÇäÂèñ„Çä„Åæ„Åó„Åü');
        }

        function pasteNode() {
            var cid = getSelectedNodeId();
            if (!clipboard || !cid) return;
            var r = findNode(cid);
            if (!r) return;
            saveState();
            function reassignIds(node) {
                node.id = generateId();
                if (node.children) {
                    for (var i = 0; i < node.children.length; i++) reassignIds(node.children[i]);
                }
            }
            if (Array.isArray(clipboard)) {
                for (var i = 0; i < clipboard.length; i++) {
                    var cloned = deepClone(clipboard[i]);
                    reassignIds(cloned);
                    r.node.children.push(cloned);
                }
                render();
                showToast(clipboard.length + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„Çí„Éö„Éº„Çπ„Éà„Åó„Åæ„Åó„Åü');
            } else {
                var cloned = deepClone(clipboard);
                reassignIds(cloned);
                r.node.children.push(cloned);
                render();
                selectNode(cloned.id);
                showToast('„Éö„Éº„Çπ„Éà„Åó„Åæ„Åó„Åü');
            }
            if (clipboardIsCut) {
                clipboard = null;
                clipboardIsCut = false;
            }
        }

        function selectAll() {
            var allNodes = getAllNodesInOrder();
            if (selectedNodeIds.size === allNodes.length) {
                clearSelection();
            } else {
                finishEditing();
                selectedNodeIds.clear();
                for (var i = 0; i < allNodes.length; i++) {
                    selectedNodeIds.add(allNodes[i].id);
                }
                lastSelectedNodeId = allNodes[0] ? allNodes[0].id : null;
                updateSelectionDisplay();
            }
        }

        function filterTopLevelNodes(nodeIds) {
            var result = [];
            for (var i = 0; i < nodeIds.length; i++) {
                var nid = nodeIds[i];
                if (nid === 'root') continue;
                var hasAncestor = false;
                for (var j = 0; j < nodeIds.length; j++) {
                    if (nodeIds[j] !== nid && isDescendant(nodeIds[j], nid)) {
                        hasAncestor = true;
                        break;
                    }
                }
                if (!hasAncestor) result.push(nid);
            }
            return result;
        }

        function isDescendant(ancestorId, nodeId) {
            var r = findNode(ancestorId);
            if (!r) return false;
            function check(node) {
                for (var i = 0; i < node.children.length; i++) {
                    if (node.children[i].id === nodeId) return true;
                    if (check(node.children[i])) return true;
                }
                return false;
            }
            return check(r.node);
        }

        // ========================================
        // Copy to Clipboard (Floating Button)
        // ========================================

        function getCurrentCopyText() {
            var format = document.getElementById('copyFormat').value;
            var border = document.getElementById('copyBorder').value;
            var useEmoji = (format === 'hiyoko');
            var useBorder = (border === 'border');
            return generateCopyText(mindMapData.root, 0, [], useEmoji, useBorder);
        }

        function copyToClipboard() {
            var text = getCurrentCopyText();

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(function() {
                    showToast('‚úÖ „Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
                }).catch(function() {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            var ta = document.createElement('textarea');
            ta.value = text;
            ta.style.cssText = 'position:fixed;opacity:0;left:-9999px;';
            document.body.appendChild(ta);
            ta.select();
            try { document.execCommand('copy'); } catch(e) {}
            document.body.removeChild(ta);
            showToast('‚úÖ „Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
        }

        function showPreview() {
            var text = getCurrentCopyText();
            document.getElementById('previewContent').textContent = text;
            document.getElementById('previewOverlay').classList.add('show');
        }

        function hidePreview() {
            document.getElementById('previewOverlay').classList.remove('show');
        }

        function generateCopyText(node, level, parentContinues, useEmoji, useBorder) {
            var result = '';
            var iconLevel = Math.min(level + 1, 4);
            var icon = useEmoji ? (levelIcons[iconLevel] + ' ') : '';

            // ---- Root (level 0) ----
            if (level === 0) {
                result = icon + node.text + '\n';
            } else {
                // Build the prefix from ancestor continuation info
                var prefix = '';
                for (var i = 0; i < level - 1; i++) {
                    if (useBorder) {
                        prefix += parentContinues[i] ? '‚îÇ  ' : '   ';
                    } else {
                        prefix += '  ';
                    }
                }
                // Connector for this node
                var isLast = (parentContinues[level - 1] === false);
                var connector;
                if (useBorder) {
                    connector = isLast ? '‚îî‚îÄ ' : '‚îú‚îÄ ';
                } else {
                    connector = '  ';
                }
                result = prefix + connector + icon + node.text + '\n';
            }

            // ---- Children ----
            for (var i = 0; i < node.children.length; i++) {
                var isLastChild = (i === node.children.length - 1);
                var newContinues = parentContinues.slice();
                newContinues.push(!isLastChild);
                result += generateCopyText(node.children[i], level + 1, newContinues, useEmoji, useBorder);
            }

            // ---- Separator blank line between sibling groups (border mode only) ----
            // Add a continuation-bar blank line after a node that has children,
            // if it is NOT the last sibling at its level and border mode is on.
            if (useBorder && level > 0 && node.children.length > 0) {
                var amILast = (parentContinues[level - 1] === false);
                if (!amILast) {
                    var sep = '';
                    for (var i = 0; i < level - 1; i++) {
                        sep += parentContinues[i] ? '‚îÇ  ' : '   ';
                    }
                    sep += '‚îÇ';
                    result += sep + '\n';
                }
            }
            return result;
        }

        // ========================================
        // Node Drag & Drop (Reparenting)
        // ========================================

        function startNodeDrag(nodeId, clientX, clientY, nodeEl) {
            if (nodeId === 'root') return;
            var startTime = Date.now();
            nodeDragState.didDrag = false;

            function onMouseMove(e) {
                var moved = Math.abs(e.clientX - clientX) > 5 || Math.abs(e.clientY - clientY) > 5;
                var elapsed = Date.now() - startTime;
                if (moved && elapsed > 150 && !nodeDragState.isDragging) {
                    nodeDragState.isDragging = true;
                    nodeDragState.didDrag = true;
                    nodeDragState.nodeId = nodeId;
                    if (selectedNodeIds.has(nodeId) && selectedNodeIds.size > 1) {
                        var ids = [];
                        selectedNodeIds.forEach(function(id) { if (id !== 'root') ids.push(id); });
                        nodeDragState.draggedNodeIds = ids;
                    } else {
                        nodeDragState.draggedNodeIds = [nodeId];
                    }
                    createDragGhost(nodeEl, e.clientX, e.clientY, nodeDragState.draggedNodeIds.length);
                    nodeDragState.draggedNodeIds.forEach(function(id) {
                        var el = document.querySelector('[data-id="' + id + '"]');
                        if (el) el.classList.add('dragging');
                    });
                }
                if (nodeDragState.isDragging) {
                    updateNodeDrag(e.clientX, e.clientY);
                }
            }

            function onMouseUp(e) {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                if (nodeDragState.isDragging) {
                    endNodeDrag();
                }
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function createDragGhost(nodeEl, clientX, clientY, count) {
            var existing = document.querySelector('.drag-ghost');
            if (existing) existing.remove();
            var ghost = nodeEl.cloneNode(true);
            ghost.classList.add('drag-ghost');
            ghost.classList.remove('selected', 'dragging');
            ghost.style.left = clientX + 'px';
            ghost.style.top = clientY + 'px';
            ghost.style.transform = 'translate(-50%, -50%)';
            ghost.style.position = 'fixed';
            ghost.style.width = nodeEl.offsetWidth + 'px';
            if (count > 1) {
                var badge = document.createElement('span');
                badge.style.cssText = 'position:absolute;top:-8px;right:-8px;background:#e53935;color:white;border-radius:50%;width:24px;height:24px;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:bold;';
                badge.textContent = count;
                ghost.appendChild(badge);
            }
            document.body.appendChild(ghost);
        }

        function updateNodeDrag(clientX, clientY) {
            if (!nodeDragState.isDragging) return;
            var ghost = document.querySelector('.drag-ghost');
            if (ghost) { ghost.style.left = clientX + 'px'; ghost.style.top = clientY + 'px'; }
            document.querySelectorAll('.node').forEach(function(el) {
                el.classList.remove('drag-over-child', 'drag-over-before', 'drag-over-after');
            });
            var target = getDropTarget(clientX, clientY);
            nodeDragState.targetNodeId = target ? target.nodeId : null;
            nodeDragState.targetPosition = target ? target.position : null;
            if (target) {
                var tEl = document.querySelector('[data-id="' + target.nodeId + '"]');
                if (tEl) tEl.classList.add('drag-over-' + target.position);
            }
        }

        function getDropTarget(clientX, clientY) {
            var elements = document.elementsFromPoint(clientX, clientY);
            var draggedIds = nodeDragState.draggedNodeIds || [nodeDragState.nodeId];
            for (var i = 0; i < elements.length; i++) {
                var el = elements[i];
                if (!el.classList.contains('node') || el.classList.contains('drag-ghost')) continue;
                var tid = el.dataset.id;
                if (draggedIds.indexOf(tid) >= 0) continue;
                var isDesc = false;
                for (var j = 0; j < draggedIds.length; j++) {
                    if (isDescendant(draggedIds[j], tid)) { isDesc = true; break; }
                }
                if (isDesc) continue;
                var rect = el.getBoundingClientRect();
                var relY = clientY - rect.top;
                var h = rect.height;
                if (tid === 'root') return { nodeId: tid, position: 'child' };
                if (relY < h * 0.25) return { nodeId: tid, position: 'before' };
                if (relY > h * 0.75) return { nodeId: tid, position: 'after' };
                return { nodeId: tid, position: 'child' };
            }
            return null;
        }

        function endNodeDrag() {
            if (!nodeDragState.isDragging) return;
            var ghost = document.querySelector('.drag-ghost');
            if (ghost) ghost.remove();
            document.querySelectorAll('.node').forEach(function(el) {
                el.classList.remove('dragging', 'drag-over-child', 'drag-over-before', 'drag-over-after');
            });
            if (nodeDragState.targetNodeId && nodeDragState.targetPosition) {
                moveNodes(
                    nodeDragState.draggedNodeIds || [nodeDragState.nodeId],
                    nodeDragState.targetNodeId,
                    nodeDragState.targetPosition
                );
            }
            nodeDragState.isDragging = false;
            nodeDragState.nodeId = null;
            nodeDragState.draggedNodeIds = null;
            nodeDragState.targetNodeId = null;
            nodeDragState.targetPosition = null;
            render();
        }

        function moveNodes(nodeIds, targetId, position) {
            if (!nodeIds || nodeIds.length === 0) return;
            var targetResult = findNode(targetId);
            if (!targetResult) return;
            var filtered = filterTopLevelNodes(nodeIds);
            if (filtered.length === 0) return;
            saveState();
            var nodesToMove = [];
            for (var i = 0; i < filtered.length; i++) {
                var nr = findNode(filtered[i]);
                if (nr && nr.parent) nodesToMove.push({ id: filtered[i], data: nr.node, parent: nr.parent, index: nr.index });
            }
            nodesToMove.sort(function(a, b) { return a.parent === b.parent ? b.index - a.index : 0; });
            for (var i = 0; i < nodesToMove.length; i++) {
                var cur = findNode(nodesToMove[i].id);
                if (cur && cur.parent) cur.parent.children.splice(cur.index, 1);
            }
            nodesToMove.reverse();
            if (position === 'child') {
                for (var i = 0; i < nodesToMove.length; i++) {
                    var tr = findNode(targetId);
                    if (tr) tr.node.children.push(nodesToMove[i].data);
                }
            } else if (position === 'before') {
                for (var i = 0; i < nodesToMove.length; i++) {
                    var tr = findNode(targetId);
                    if (tr && tr.parent) tr.parent.children.splice(tr.index, 0, nodesToMove[i].data);
                }
            } else if (position === 'after') {
                nodesToMove.reverse();
                for (var i = 0; i < nodesToMove.length; i++) {
                    var tr = findNode(targetId);
                    if (tr && tr.parent) tr.parent.children.splice(tr.index + 1, 0, nodesToMove[i].data);
                }
            }
            selectedNodeIds.clear();
            for (var i = 0; i < nodesToMove.length; i++) selectedNodeIds.add(nodesToMove[i].id);
            lastSelectedNodeId = nodesToMove[0] ? nodesToMove[0].id : null;
        }

        // ========================================
        // Lasso (Rectangle) Selection
        // ========================================

        function startLasso(clientX, clientY) {
            lassoState.active = true;
            lassoState.didSelect = false;
            lassoState.startX = clientX;
            lassoState.startY = clientY;
            lassoState.currentX = clientX;
            lassoState.currentY = clientY;
            var rect = document.getElementById('lassoRect');
            rect.style.display = 'block';
            rect.style.left = clientX + 'px';
            rect.style.top = clientY + 'px';
            rect.style.width = '0px';
            rect.style.height = '0px';
        }

        function updateLasso(clientX, clientY) {
            if (!lassoState.active) return;
            lassoState.currentX = clientX;
            lassoState.currentY = clientY;
            var x = Math.min(lassoState.startX, clientX);
            var y = Math.min(lassoState.startY, clientY);
            var w = Math.abs(clientX - lassoState.startX);
            var h = Math.abs(clientY - lassoState.startY);
            var rect = document.getElementById('lassoRect');
            rect.style.left = x + 'px';
            rect.style.top = y + 'px';
            rect.style.width = w + 'px';
            rect.style.height = h + 'px';
        }

        function endLasso() {
            if (!lassoState.active) return;
            lassoState.active = false;
            var rect = document.getElementById('lassoRect');
            rect.style.display = 'none';

            var x1 = Math.min(lassoState.startX, lassoState.currentX);
            var y1 = Math.min(lassoState.startY, lassoState.currentY);
            var x2 = Math.max(lassoState.startX, lassoState.currentX);
            var y2 = Math.max(lassoState.startY, lassoState.currentY);

            // Require minimum size to avoid treating clicks as lasso
            if (Math.abs(x2 - x1) < 8 && Math.abs(y2 - y1) < 8) return;

            clearSelection();
            document.querySelectorAll('.node').forEach(function(el) {
                var r = el.getBoundingClientRect();
                var cx = r.left + r.width / 2;
                var cy = r.top + r.height / 2;
                if (cx >= x1 && cx <= x2 && cy >= y1 && cy <= y2) {
                    selectedNodeIds.add(el.dataset.id);
                }
            });
            if (selectedNodeIds.size > 0) {
                lastSelectedNodeId = selectedNodeIds.values().next().value;
                updateSelectionDisplay();
                lassoState.didSelect = true;
                showToast(selectedNodeIds.size + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„ÇíÈÅ∏Êäû„Åó„Åæ„Åó„Åü');
            }
        }

        // ========================================
        // Rendering
        // ========================================

        function render() {
            var container = document.getElementById('canvasInner');
            var svg = document.getElementById('linesSvg');
            container.querySelectorAll('.node').forEach(function(n) { n.remove(); });
            svg.innerHTML = '';

            // Pass 1: Measure actual node dimensions by creating temporary elements
            var nodeDims = measureNodeDimensions(mindMapData.root, container);

            // Pass 2: Layout with actual dimensions
            var positions = {};
            layoutNodes(mindMapData.root, positions, 0, 0, 1, nodeDims);

            // Pass 3: Render nodes and lines
            renderNodes(mindMapData.root, container, positions);
            renderLines(mindMapData.root, svg, positions);
            updateSelectionDisplay();
            updateView();
        }

        // Measure actual rendered width AND height of each node's text
        function measureNodeDimensions(rootNode, container) {
            var dims = {};
            // Create a measurer that exactly mirrors the .node DOM structure
            var measurer = document.createElement('div');
            measurer.className = 'node';
            measurer.style.position = 'absolute';
            measurer.style.visibility = 'hidden';
            measurer.style.pointerEvents = 'none';
            // Don't set transform since we just need dimensions
            var measurerText = document.createElement('span');
            measurerText.className = 'node-text';
            measurer.appendChild(measurerText);
            container.appendChild(measurer);

            function measure(node) {
                measurerText.textContent = node.text;
                // Root nodes have larger font
                if (node.id === 'root') {
                    measurer.classList.add('root');
                } else {
                    measurer.classList.remove('root');
                }
                dims[node.id] = { width: measurer.offsetWidth, height: measurer.offsetHeight };
                for (var i = 0; i < node.children.length; i++) {
                    measure(node.children[i]);
                }
            }
            measure(rootNode);
            container.removeChild(measurer);
            return dims;
        }

        function layoutNodes(node, positions, x, y, level, nodeDims) {
            if (x === undefined) x = 0;
            if (y === undefined) y = 0;
            if (level === undefined) level = 1;
            var dims = (nodeDims && nodeDims[node.id]) ? nodeDims[node.id] : { width: 150, height: 40 };
            var nodeWidth = dims.width;
            var nodeHeight = dims.height;
            var hGap = 40, vGap = 16;
            var totalH = 0, childHeights = [];
            for (var i = 0; i < node.children.length; i++) {
                var ch = calcSubtreeHeight(node.children[i], vGap, nodeDims);
                childHeights.push(ch);
                totalH += ch;
            }
            if (node.children.length > 1) totalH += (node.children.length - 1) * vGap;
            positions[node.id] = { x: x, y: y, width: nodeWidth, height: nodeHeight, level: level };
            var childX = x + nodeWidth + hGap;
            var childY = y - totalH / 2;
            for (var i = 0; i < node.children.length; i++) {
                var ch = childHeights[i];
                var centerY = childY + ch / 2;
                layoutNodes(node.children[i], positions, childX, centerY, level + 1, nodeDims);
                childY += ch + vGap;
            }
            return positions;
        }

        function calcSubtreeHeight(node, gap, nodeDims) {
            var dims = (nodeDims && nodeDims[node.id]) ? nodeDims[node.id] : { width: 150, height: 40 };
            var nodeHeight = dims.height;
            if (node.children.length === 0) return nodeHeight;
            var total = 0;
            for (var i = 0; i < node.children.length; i++) {
                total += calcSubtreeHeight(node.children[i], gap, nodeDims);
            }
            total += (node.children.length - 1) * gap;
            return Math.max(nodeHeight, total);
        }

        function renderNodes(node, container, positions) {
            var pos = positions[node.id];
            if (!pos) return;
            var el = document.createElement('div');
            el.className = 'node' + (node.id === 'root' ? ' root' : '');
            el.dataset.id = node.id;
            el.style.left = pos.x + 'px';
            el.style.top = pos.y + 'px';
            el.style.width = pos.width + 'px';
            el.style.transform = 'translateY(-50%)';
            var textEl = document.createElement('span');
            textEl.className = 'node-text';
            textEl.textContent = node.text;
            el.appendChild(textEl);

            // Use a closure to capture node reference
            (function(nodeData, nodeElement) {

                // Click handler: default to editing mode
                nodeElement.addEventListener('click', function(e) {
                    e.stopPropagation();

                    // If a drag just occurred, suppress click
                    if (nodeDragState.didDrag) {
                        nodeDragState.didDrag = false;
                        return;
                    }

                    var isMac = /Mac/.test(navigator.platform);
                    var cmdKey = isMac ? e.metaKey : e.ctrlKey;

                    if (cmdKey && e.shiftKey) {
                        finishEditing();
                        var allNodes = getAllNodesInOrder();
                        var si = -1, ei = -1;
                        for (var i = 0; i < allNodes.length; i++) {
                            if (allNodes[i].id === lastSelectedNodeId) si = i;
                            if (allNodes[i].id === nodeData.id) ei = i;
                        }
                        if (si !== -1 && ei !== -1) {
                            var mn = Math.min(si, ei), mx = Math.max(si, ei);
                            for (var i = mn; i <= mx; i++) selectedNodeIds.add(allNodes[i].id);
                            lastSelectedNodeId = nodeData.id;
                            updateSelectionDisplay();
                        }
                    } else if (e.shiftKey) {
                        finishEditing();
                        rangeSelectNode(nodeData.id);
                    } else if (cmdKey) {
                        finishEditing();
                        toggleSelectNode(nodeData.id);
                    } else {
                        // Normal click -> enter edit mode directly
                        if (editingNodeId === nodeData.id) return;
                        finishEditing();
                        selectNode(nodeData.id);
                        startEditing(nodeData.id);
                    }
                });

                // Double-click: enter edit mode (for when already selected but not editing)
                nodeElement.addEventListener('dblclick', function(e) {
                    e.stopPropagation();
                    startEditing(nodeData.id);
                });

                // Mousedown: start potential drag (only left button, no modifiers, not editing)
                nodeElement.addEventListener('mousedown', function(e) {
                    if (e.button !== 0) return;
                    if (editingNodeId) return;
                    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
                    e.preventDefault();
                    e.stopPropagation();
                    startNodeDrag(nodeData.id, e.clientX, e.clientY, nodeElement);
                });

            })(node, el);

            container.appendChild(el);
            for (var i = 0; i < node.children.length; i++) {
                renderNodes(node.children[i], container, positions);
            }
        }

        function renderLines(node, svg, positions) {
            var pp = positions[node.id];
            if (!pp) return;
            var off = 5000;
            for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];
                var cp = positions[child.id];
                if (!cp) continue;
                var sx = pp.x + pp.width + off, sy = pp.y + off;
                var ex = cp.x + off, ey = cp.y + off;
                var mx = sx + (ex - sx) / 2;
                var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'M ' + sx + ' ' + sy + ' C ' + mx + ' ' + sy + ', ' + mx + ' ' + ey + ', ' + ex + ' ' + ey);
                path.setAttribute('class', 'connection-line');
                svg.appendChild(path);
                renderLines(child, svg, positions);
            }
        }

        // ========================================
        // View Controls
        // ========================================

        function updateView() {
            var inner = document.getElementById('canvasInner');
            inner.style.transform = 'translate(' + viewState.panX + 'px, ' + viewState.panY + 'px) scale(' + viewState.zoom + ')';
        }

        function resetView() {
            var container = document.getElementById('canvasContainer');
            viewState.zoom = 1;
            viewState.panX = container.clientWidth / 2 - 75;
            viewState.panY = container.clientHeight / 2;
            updateView();
        }

        // ========================================
        // Keyboard Handler
        // ========================================

        function handleKeyDown(e) {
            var isMac = /Mac/.test(navigator.platform);
            var cmdKey = isMac ? e.metaKey : e.ctrlKey;

            // While editing
            if (editingNodeId) {
                // IMEÂÖ•Âäõ‰∏≠Ôºà„É≠„Éº„ÉûÂ≠ó‚ÜíÊó•Êú¨Ë™ûÂ§âÊèõÔºâ„ÅÆ„Ç≠„Éº„ÅØÁÑ°Ë¶ñ„Åô„Çã
                if (e.isComposing || e.keyCode === 229) return;

                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    finishEditing();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    finishEditing();
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    finishEditing();
                    if (e.shiftKey) { goToParent(); }
                    else { var cid = getSelectedNodeId(); if (cid) addChildNode(cid); }
                } else if (cmdKey && (e.key === 'z' || e.key === 'Z')) {
                    e.preventDefault(); finishEditing(); undo();
                } else if (cmdKey && (e.key === 'y' || e.key === 'Y')) {
                    e.preventDefault(); finishEditing(); redo();
                }
                return;
            }

            var currentId = getSelectedNodeId();

            switch (e.key) {
                case 'Enter':
                    e.preventDefault();
                    if (currentId) addSiblingNode(currentId);
                    break;
                case 'Tab':
                    e.preventDefault();
                    if (e.shiftKey) goToParent();
                    else if (currentId) addChildNode(currentId);
                    break;
                case 'Delete':
                case 'Backspace':
                    e.preventDefault();
                    if (selectedNodeIds.size > 1) deleteSelectedNodes();
                    else if (currentId && currentId !== 'root') deleteNode(currentId);
                    break;
                case 'F2':
                    e.preventDefault();
                    if (currentId) startEditing(currentId);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    if (cmdKey) { if (currentId) moveNodeUp(currentId); }
                    else navigateUp();
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (cmdKey) { if (currentId) moveNodeDown(currentId); }
                    else navigateDown();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (cmdKey) { if (currentId) promoteNode(currentId); }
                    else navigateLeft();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (cmdKey) { if (currentId) demoteNode(currentId); }
                    else navigateRight();
                    break;
                case 'z': case 'Z':
                    if (cmdKey) { e.preventDefault(); undo(); }
                    break;
                case 'y': case 'Y':
                    if (cmdKey) { e.preventDefault(); redo(); }
                    break;
                case 'a': case 'A':
                    if (cmdKey) { e.preventDefault(); selectAll(); }
                    break;
                case 'c': case 'C':
                    if (cmdKey) { e.preventDefault(); copySelectedNodes(); }
                    break;
                case 'v': case 'V':
                    if (cmdKey) { e.preventDefault(); pasteNode(); }
                    break;
                case 'x': case 'X':
                    if (cmdKey) { e.preventDefault(); cutSelectedNodes(); }
                    break;
                case 'Escape':
                    clearSelection();
                    break;
            }
        }

        // ========================================
        // Canvas Interaction: Pan, Zoom, Lasso
        // ========================================

        function initCanvasInteraction() {
            var canvas = document.getElementById('canvas');

            // --- Mousedown ---
            canvas.addEventListener('mousedown', function(e) {
                if (nodeDragState.isDragging) return;

                var isBackground = (e.target === canvas ||
                    e.target.id === 'canvasInner' ||
                    e.target.tagName === 'svg' ||
                    e.target.classList.contains('lines-svg'));

                if (!isBackground) return;

                // Right-click or middle-click: pan
                if (e.button === 2 || e.button === 1) {
                    e.preventDefault();
                    viewState.isPanning = true;
                    viewState.startX = e.clientX - viewState.panX;
                    viewState.startY = e.clientY - viewState.panY;
                    canvas.classList.add('panning');
                    return;
                }

                // Left-click on background: start lasso
                if (e.button === 0) {
                    finishEditing();
                    startLasso(e.clientX, e.clientY);
                }
            });

            // --- Mousemove ---
            canvas.addEventListener('mousemove', function(e) {
                if (nodeDragState.isDragging) return;
                if (viewState.isPanning) {
                    viewState.panX = e.clientX - viewState.startX;
                    viewState.panY = e.clientY - viewState.startY;
                    updateView();
                    return;
                }
                if (lassoState.active) {
                    updateLasso(e.clientX, e.clientY);
                }
            });

            // --- Mouseup ---
            canvas.addEventListener('mouseup', function(e) {
                if (viewState.isPanning) {
                    viewState.isPanning = false;
                    canvas.classList.remove('panning');
                    return;
                }
                if (lassoState.active) {
                    endLasso();
                }
            });

            // --- Click on background: clear selection ---
            canvas.addEventListener('click', function(e) {
                var isBackground = (e.target === canvas ||
                    e.target.id === 'canvasInner' ||
                    e.target.tagName === 'svg' ||
                    e.target.classList.contains('lines-svg'));

                if (!isBackground) return;

                // Don't clear if lasso just selected nodes
                if (lassoState.didSelect) {
                    lassoState.didSelect = false;
                    return;
                }
                finishEditing();
                clearSelection();
            });

            // --- Mouseleave ---
            canvas.addEventListener('mouseleave', function() {
                if (viewState.isPanning) {
                    viewState.isPanning = false;
                    canvas.classList.remove('panning');
                }
                if (lassoState.active) endLasso();
                if (nodeDragState.isDragging) endNodeDrag();
            });

            // --- Context menu prevention ---
            canvas.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });

            // --- Wheel: zoom (mouse scroll wheel) / pan (trackpad 2-finger) ---
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                var container = document.getElementById('canvasContainer');
                var rect = container.getBoundingClientRect();
                var mouseX = e.clientX - rect.left;
                var mouseY = e.clientY - rect.top;

                // ctrlKey is set by browser during trackpad pinch gesture
                if (e.ctrlKey) {
                    // Pinch zoom
                    var zoomDelta = -e.deltaY * 0.01;
                    applyZoom(mouseX, mouseY, zoomDelta);
                    return;
                }

                // Trackpad 2-finger scroll ‚Üí pan
                // Mouse scroll wheel ‚Üí zoom (deltaMode = 1 for line-based, or large deltaY)
                if (e.deltaMode === 0 && (Math.abs(e.deltaX) > 1 || Math.abs(e.deltaY) < 80)) {
                    // Likely trackpad: pan
                    viewState.panX -= e.deltaX;
                    viewState.panY -= e.deltaY;
                    updateView();
                } else {
                    // Mouse scroll wheel: zoom
                    var zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
                    applyZoom(mouseX, mouseY, zoomDelta);
                }
            }, { passive: false });

            // --- Touch events for pinch-zoom ---
            var lastTouchDist = 0;
            var lastTouchCenter = { x: 0, y: 0 };

            canvas.addEventListener('touchstart', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    var t1 = e.touches[0], t2 = e.touches[1];
                    lastTouchDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                    lastTouchCenter = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    var t1 = e.touches[0], t2 = e.touches[1];
                    var dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                    var center = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
                    var scale = dist / lastTouchDist;
                    var oldZoom = viewState.zoom;
                    var newZoom = Math.max(0.2, Math.min(3, oldZoom * scale));
                    var actualScale = newZoom / oldZoom;
                    viewState.panX = center.x - actualScale * (center.x - viewState.panX);
                    viewState.panY = center.y - actualScale * (center.y - viewState.panY);
                    viewState.zoom = newZoom;
                    viewState.panX += center.x - lastTouchCenter.x;
                    viewState.panY += center.y - lastTouchCenter.y;
                    lastTouchDist = dist;
                    lastTouchCenter = center;
                    updateView();
                }
            }, { passive: false });
        }

        function applyZoom(mouseX, mouseY, zoomDelta) {
            var oldZoom = viewState.zoom;
            var newZoom = Math.max(0.2, Math.min(3, oldZoom + zoomDelta));
            var scale = newZoom / oldZoom;
            viewState.panX = mouseX - scale * (mouseX - viewState.panX);
            viewState.panY = mouseY - scale * (mouseY - viewState.panY);
            viewState.zoom = newZoom;
            updateView();
        }

        // ========================================
        // Initialization
        // ========================================

        function init() {
            // Restore from localStorage if available
            var saved = loadFromLocalStorage();
            if (saved) {
                mindMapData = saved;
            }
            saveState();
            document.addEventListener('keydown', handleKeyDown);
            initCanvasInteraction();
            document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
            document.getElementById('resetBtn').addEventListener('click', resetMindMap);
            document.getElementById('previewBtn').addEventListener('click', showPreview);
            document.getElementById('previewCopyBtn').addEventListener('click', function() {
                copyToClipboard();
            });
            document.getElementById('previewCloseBtn').addEventListener('click', hidePreview);
            document.getElementById('previewOverlay').addEventListener('click', function(e) {
                if (e.target === this) hidePreview();
            });
            // Update preview in real-time when dropdowns change while preview is open
            document.getElementById('copyFormat').addEventListener('change', function() {
                if (document.getElementById('previewOverlay').classList.contains('show')) showPreview();
            });
            document.getElementById('copyBorder').addEventListener('change', function() {
                if (document.getElementById('previewOverlay').classList.contains('show')) showPreview();
            });
            resetView();
            render();
            selectNode('root');
            // Start editing root on first load
            setTimeout(function() { startEditing('root'); }, 100);
        }

        document.addEventListener('DOMContentLoaded', init);

        // Expose for testing/integration
        window.getCurrentCopyText = getCurrentCopyText;

    })();
    </script>
</body>
</html>
