<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚·ãƒ³ãƒ—ãƒ«ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ãƒ„ãƒ¼ãƒ«</title>
    <style>
        /* ========================================
           CSS Variables & Reset
           ======================================== */
        :root {
            --primary-color: #4a90d9;
            --primary-hover: #357abd;
            --bg-color: #f5f7fa;
            --toolbar-bg: #ffffff;
            --node-bg: #ffffff;
            --node-border: #4a90d9;
            --node-selected: #e3f2fd;
            --text-color: #333333;
            --line-color: #666666;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
            --font-family: 'Meiryo UI', 'ãƒ¡ã‚¤ãƒªã‚ª', Meiryo, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-family);
            background: var(--bg-color);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* ========================================
           Toolbar Styles
           ======================================== */
        .toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: var(--toolbar-bg);
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            padding: 0 16px;
            gap: 8px;
            z-index: 1000;
        }

        .toolbar-title {
            font-size: 16px;
            font-weight: bold;
            color: var(--primary-color);
            margin-right: 16px;
        }

        .toolbar-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
            color: var(--text-color);
            font-family: var(--font-family);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .toolbar-btn:active {
            transform: scale(0.98);
        }

        .toolbar-separator {
            width: 1px;
            height: 30px;
            background: #ddd;
            margin: 0 8px;
        }

        .toolbar-hint {
            margin-left: auto;
            font-size: 12px;
            color: #888;
        }

        /* ========================================
           Style Dropdown
           ======================================== */
        .style-dropdown-wrapper {
            position: relative;
            display: inline-block;
        }

        .style-dropdown-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
            color: var(--text-color);
            font-family: var(--font-family);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .style-dropdown-btn:hover {
            background: #f5f5f5;
            border-color: var(--primary-color);
        }

        .style-dropdown-btn.active {
            background: #e3f2fd;
            border-color: var(--primary-color);
        }

        .color-indicator {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        .line-indicator {
            width: 20px;
            height: 4px;
            background: var(--line-color);
            border-radius: 2px;
        }

        .grayout-indicator {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            background: #e0e0e0;
            border: 1px solid #bdbdbd;
        }

        .style-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 4px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            padding: 12px;
            z-index: 1500;
            display: none;
            min-width: 200px;
        }

        .style-dropdown.active {
            display: block;
        }

        .style-dropdown-title {
            font-size: 12px;
            font-weight: bold;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .color-presets {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        .color-preset {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-preset:hover {
            transform: scale(1.1);
            border-color: var(--primary-color);
        }

        .color-preset.selected {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(74, 144, 217, 0.3);
        }

        .color-picker-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding-top: 8px;
            border-top: 1px solid #eee;
        }

        .color-picker-label {
            font-size: 12px;
            color: #666;
        }

        .color-picker-input {
            width: 40px;
            height: 28px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            padding: 2px;
        }

        .color-picker-input::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker-input::-webkit-color-swatch {
            border: none;
            border-radius: 2px;
        }

        .line-presets {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .line-preset {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            padding: 8px 12px;
            border: 2px solid transparent;
            border-radius: 6px;
            background: #f5f5f5;
            cursor: pointer;
            transition: all 0.2s;
        }

        .line-preset:hover {
            background: #e3f2fd;
        }

        .line-preset.selected {
            border-color: var(--primary-color);
            background: #e3f2fd;
        }

        .line-preview {
            width: 40px;
            border-radius: 2px;
        }

        .line-preset-label {
            font-size: 11px;
            color: #666;
        }

        /* ========================================
           Canvas Container
           ======================================== */
        .canvas-container {
            position: fixed;
            top: 50px;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            background: var(--bg-color);
            background-image: 
                radial-gradient(circle, #ddd 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        .canvas.panning {
            cursor: grabbing;
        }

        .canvas-inner {
            position: absolute;
            transform-origin: 0 0;
        }

        /* ========================================
           SVG Lines
           ======================================== */
        .lines-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 10000px;
            height: 10000px;
            overflow: visible;
            transform: translate(-5000px, -5000px);
        }
        
        .link-group {
            pointer-events: auto;
        }
        
        .link-group:hover .link-line {
            stroke-width: 3px;
        }
        
        .dots-svg {
            z-index: 100;
            pointer-events: none;
        }
        
        .dot-group {
            pointer-events: auto;
        }

        .connection-line {
            fill: none;
            stroke: var(--line-color);
            stroke-width: 2;
            stroke-linecap: round;
            pointer-events: none;
        }

        .link-line {
            fill: none;
            stroke: #e53935;
            stroke-width: 2;
            stroke-dasharray: 6, 4;
            stroke-linecap: round;
        }

        .link-line-preview {
            fill: none;
            stroke: #e53935;
            stroke-width: 2;
            stroke-dasharray: 6, 4;
            stroke-linecap: round;
            opacity: 0.6;
        }

        .node.link-target {
            box-shadow: 0 0 0 4px rgba(229, 57, 53, 0.4);
        }

        .node.dragging {
            opacity: 0.5;
            z-index: 1000;
        }

        .node.drag-over-child {
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.5);
            border-color: #4caf50;
        }

        .node.drag-over-before {
            border-top: 4px solid #2196f3;
        }

        .node.drag-over-after {
            border-bottom: 4px solid #2196f3;
        }

        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 2000;
            opacity: 0.8;
            transform: rotate(2deg);
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        }

        /* ========================================
           Node Styles
           ======================================== */
        .node {
            position: absolute;
            min-width: 120px;
            max-width: 300px;
            padding: 10px 16px;
            background: var(--node-bg);
            border: 2px solid var(--node-border);
            border-radius: 8px;
            box-shadow: var(--shadow);
            cursor: pointer;
            user-select: none;
            transition: box-shadow 0.2s, transform 0.2s;
            white-space: nowrap;
        }

        .node:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .node.selected {
            background: var(--node-selected);
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 144, 217, 0.3);
        }

        .node.root {
            font-size: 16px;
            font-weight: bold;
            border-width: 3px;
        }

        .node.editing {
            cursor: text;
        }

        .node-text {
            outline: none;
            min-width: 50px;
            display: inline-block;
        }

        .node-text[contenteditable="true"] {
            cursor: text;
            background: rgba(255,255,255,0.8);
            padding: 2px 4px;
            margin: -2px -4px;
            border-radius: 3px;
        }

        /* ========================================
           Modal Styles
           ======================================== */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.2);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 18px;
            font-weight: bold;
            color: var(--text-color);
        }

        .modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: none;
            font-size: 24px;
            cursor: pointer;
            color: #888;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal-close:hover {
            background: #f0f0f0;
            color: #333;
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid #eee;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .modal-btn {
            padding: 10px 20px;
            border-radius: 6px;
            font-family: var(--font-family);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .modal-btn-primary {
            background: var(--primary-color);
            color: white;
            border: none;
        }

        .modal-btn-primary:hover {
            background: var(--primary-hover);
        }

        .modal-btn-secondary {
            background: white;
            color: var(--text-color);
            border: 1px solid #ddd;
        }

        .modal-btn-secondary:hover {
            background: #f5f5f5;
        }

        .modal-textarea {
            width: 100%;
            height: 300px;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-family: var(--font-family);
            font-size: 13px;
            line-height: 1.6;
            resize: vertical;
        }

        .modal-textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 144, 217, 0.1);
        }

        /* ========================================
           Zoom Controls
           ======================================== */
        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow);
            transition: all 0.2s;
        }

        .zoom-btn:hover {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .zoom-level {
            padding: 0 12px;
            height: 40px;
            display: flex;
            align-items: center;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 13px;
            box-shadow: var(--shadow);
        }

        /* ========================================
           Keyboard Shortcuts Help
           ======================================== */
        .shortcuts-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: #f9f9f9;
            border-radius: 6px;
        }

        .shortcut-key {
            font-family: monospace;
            background: #e8e8e8;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* ========================================
           Toast Notification
           ======================================== */
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 3000;
            opacity: 0;
            transition: all 0.3s;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    </style>
</head>
<body>
    <!-- Toolbar -->
    <div class="toolbar">
        <span class="toolbar-title">ğŸ§  ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—</span>
        
        <button class="toolbar-btn" onclick="exportText()" title="ãƒ—ãƒ¬ãƒ¼ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¨ã—ã¦å‡ºåŠ›">
            ğŸ“„ ãƒ†ã‚­ã‚¹ãƒˆå‡ºåŠ›
        </button>
        
        <button class="toolbar-btn" onclick="showImportModal()" title="ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰èª­ã¿è¾¼ã¿">
            ğŸ“¥ ãƒ†ã‚­ã‚¹ãƒˆèª­è¾¼
        </button>
        
        <div class="toolbar-separator"></div>
        
        <button class="toolbar-btn" onclick="undo()" title="å…ƒã«æˆ»ã™ (Cmd+Z)">
            â†©ï¸ æˆ»ã™
        </button>
        
        <button class="toolbar-btn" onclick="redo()" title="ã‚„ã‚Šç›´ã— (Cmd+Y)">
            â†ªï¸ ã‚„ã‚Šç›´ã—
        </button>
        
        <div class="toolbar-separator"></div>
        
        <!-- ãƒãƒ¼ãƒ‰èƒŒæ™¯è‰² -->
        <div class="style-dropdown-wrapper">
            <button class="style-dropdown-btn" onclick="toggleStyleDropdown('bgColor')" title="ãƒãƒ¼ãƒ‰èƒŒæ™¯è‰² (Cmd+Opt+Y)">
                <span class="color-indicator" id="bgColorIndicator" style="background: #fff;"></span>
                èƒŒæ™¯è‰²
            </button>
            <div class="style-dropdown" id="bgColorDropdown">
                <div class="style-dropdown-title">ãƒ—ãƒªã‚»ãƒƒãƒˆ</div>
                <div class="color-presets" id="bgColorPresets">
                    <div class="color-preset" style="background: #ffffff;" data-color="#ffffff" onclick="setBgColor('#ffffff')" title="ç™½"></div>
                    <div class="color-preset" style="background: #fff9c4;" data-color="#fff9c4" onclick="setBgColor('#fff9c4')" title="é»„è‰²"></div>
                    <div class="color-preset" style="background: #e0f7fa;" data-color="#e0f7fa" onclick="setBgColor('#e0f7fa')" title="æ°´è‰²"></div>
                    <div class="color-preset" style="background: #f3e5f5;" data-color="#f3e5f5" onclick="setBgColor('#f3e5f5')" title="ç´«"></div>
                    <div class="color-preset" style="background: #e8f5e9;" data-color="#e8f5e9" onclick="setBgColor('#e8f5e9')" title="ç·‘"></div>
                    <div class="color-preset" style="background: #ffebee;" data-color="#ffebee" onclick="setBgColor('#ffebee')" title="èµ¤"></div>
                    <div class="color-preset" style="background: #fff3e0;" data-color="#fff3e0" onclick="setBgColor('#fff3e0')" title="ã‚ªãƒ¬ãƒ³ã‚¸"></div>
                    <div class="color-preset" style="background: #e0e0e0;" data-color="#e0e0e0" onclick="setBgColor('#e0e0e0')" title="ã‚°ãƒ¬ãƒ¼"></div>
                </div>
                <div class="color-picker-row">
                    <span class="color-picker-label">ã‚«ã‚¹ã‚¿ãƒ :</span>
                    <input type="color" class="color-picker-input" id="bgColorPicker" value="#ffffff" onchange="setBgColor(this.value)">
                </div>
            </div>
        </div>
        
        <!-- ãƒãƒ¼ãƒ‰æ–‡å­—è‰² -->
        <div class="style-dropdown-wrapper">
            <button class="style-dropdown-btn" onclick="toggleStyleDropdown('textColor')" title="ãƒãƒ¼ãƒ‰æ–‡å­—è‰² (Cmd+Opt+A)">
                <span class="color-indicator" id="textColorIndicator" style="background: #333;"></span>
                æ–‡å­—è‰²
            </button>
            <div class="style-dropdown" id="textColorDropdown">
                <div class="style-dropdown-title">ãƒ—ãƒªã‚»ãƒƒãƒˆ</div>
                <div class="color-presets" id="textColorPresets">
                    <div class="color-preset" style="background: #333333;" data-color="#333333" onclick="setTextColor('#333333')" title="é»’"></div>
                    <div class="color-preset" style="background: #e53935;" data-color="#e53935" onclick="setTextColor('#e53935')" title="èµ¤"></div>
                    <div class="color-preset" style="background: #1e88e5;" data-color="#1e88e5" onclick="setTextColor('#1e88e5')" title="é’"></div>
                    <div class="color-preset" style="background: #43a047;" data-color="#43a047" onclick="setTextColor('#43a047')" title="ç·‘"></div>
                    <div class="color-preset" style="background: #fb8c00;" data-color="#fb8c00" onclick="setTextColor('#fb8c00')" title="ã‚ªãƒ¬ãƒ³ã‚¸"></div>
                    <div class="color-preset" style="background: #8e24aa;" data-color="#8e24aa" onclick="setTextColor('#8e24aa')" title="ç´«"></div>
                    <div class="color-preset" style="background: #9e9e9e;" data-color="#9e9e9e" onclick="setTextColor('#9e9e9e')" title="ã‚°ãƒ¬ãƒ¼"></div>
                    <div class="color-preset" style="background: #ffffff; border: 1px solid #ccc;" data-color="#ffffff" onclick="setTextColor('#ffffff')" title="ç™½"></div>
                </div>
                <div class="color-picker-row">
                    <span class="color-picker-label">ã‚«ã‚¹ã‚¿ãƒ :</span>
                    <input type="color" class="color-picker-input" id="textColorPicker" value="#333333" onchange="setTextColor(this.value)">
                </div>
            </div>
        </div>
        
        <!-- æ¥ç¶šç·šã®è‰² -->
        <div class="style-dropdown-wrapper">
            <button class="style-dropdown-btn" onclick="toggleStyleDropdown('lineColor')" title="æ¥ç¶šç·šã®è‰²">
                <span class="line-indicator" id="lineColorIndicator"></span>
                ç·šè‰²
            </button>
            <div class="style-dropdown" id="lineColorDropdown">
                <div class="style-dropdown-title">ãƒ—ãƒªã‚»ãƒƒãƒˆ</div>
                <div class="color-presets" id="lineColorPresets">
                    <div class="color-preset" style="background: #999999;" data-color="#999999" onclick="setLineColor('#999999')" title="ã‚°ãƒ¬ãƒ¼ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰"></div>
                    <div class="color-preset" style="background: #333333;" data-color="#333333" onclick="setLineColor('#333333')" title="é»’"></div>
                    <div class="color-preset" style="background: #e53935;" data-color="#e53935" onclick="setLineColor('#e53935')" title="èµ¤"></div>
                    <div class="color-preset" style="background: #1e88e5;" data-color="#1e88e5" onclick="setLineColor('#1e88e5')" title="é’"></div>
                    <div class="color-preset" style="background: #43a047;" data-color="#43a047" onclick="setLineColor('#43a047')" title="ç·‘"></div>
                    <div class="color-preset" style="background: #fb8c00;" data-color="#fb8c00" onclick="setLineColor('#fb8c00')" title="ã‚ªãƒ¬ãƒ³ã‚¸"></div>
                    <div class="color-preset" style="background: #8e24aa;" data-color="#8e24aa" onclick="setLineColor('#8e24aa')" title="ç´«"></div>
                    <div class="color-preset" style="background: #cccccc;" data-color="#cccccc" onclick="setLineColor('#cccccc')" title="è–„ã„ã‚°ãƒ¬ãƒ¼"></div>
                </div>
                <div class="color-picker-row">
                    <span class="color-picker-label">ã‚«ã‚¹ã‚¿ãƒ :</span>
                    <input type="color" class="color-picker-input" id="lineColorPicker" value="#999999" onchange="setLineColor(this.value)">
                </div>
                <div class="style-dropdown-title" style="margin-top: 12px;">ç·šã®å¤ªã•</div>
                <div class="line-presets">
                    <div class="line-preset" onclick="setLineThickness(false)" id="lineThicknessNormal">
                        <div class="line-preview" style="height: 2px; background: #999;"></div>
                        <span class="line-preset-label">é€šå¸¸</span>
                    </div>
                    <div class="line-preset" onclick="setLineThickness(true)" id="lineThicknessThick">
                        <div class="line-preview" style="height: 4px; background: #999;"></div>
                        <span class="line-preset-label">å¤ªç·š</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆ -->
        <button class="style-dropdown-btn" onclick="toggleGrayout()" title="ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆ (Cmd+Opt+G)">
            <span class="grayout-indicator" id="grayoutIndicator"></span>
            ã‚°ãƒ¬ãƒ¼
        </button>
        
        <div class="toolbar-separator"></div>
        
        <button class="toolbar-btn" onclick="showHelpModal()" title="ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆä¸€è¦§">
            â“ ãƒ˜ãƒ«ãƒ—
        </button>
        
        <span class="toolbar-hint">ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦Enterï¼ˆåŒéšå±¤è¿½åŠ ï¼‰/ Tabï¼ˆå­è¿½åŠ ï¼‰</span>
    </div>

    <!-- Canvas Container -->
    <div class="canvas-container" id="canvasContainer">
        <div class="canvas" id="canvas">
            <div class="canvas-inner" id="canvasInner">
                <svg class="lines-svg" id="linesSvg"></svg>
                <!-- ä¸¸ãƒãƒç”¨ã®å‰é¢SVGãƒ¬ã‚¤ãƒ¤ãƒ¼ -->
                <svg class="lines-svg dots-svg" id="dotsSvg"></svg>
            </div>
        </div>
    </div>

    <!-- Zoom Controls -->
    <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomIn()" title="æ‹¡å¤§">+</button>
        <span class="zoom-level" id="zoomLevel">100%</span>
        <button class="zoom-btn" onclick="zoomOut()" title="ç¸®å°">âˆ’</button>
        <button class="zoom-btn" onclick="resetView()" title="ãƒªã‚»ãƒƒãƒˆ">âŸ²</button>
    </div>

    <!-- Import Modal -->
    <div class="modal-overlay" id="importModal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">ğŸ“¥ ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰èª­ã¿è¾¼ã¿</span>
                <button class="modal-close" onclick="closeImportModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom: 12px; color: #666; font-size: 13px;">
                    ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆï¼ˆã‚¿ãƒ–ã¾ãŸã¯ã‚¹ãƒšãƒ¼ã‚¹ï¼‰ã§éšå±¤ã‚’è¡¨ç¾ã—ãŸãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚<br>
                    ç½«ç·šè¨˜å·ï¼ˆâ”œâ”€ â””â”€ï¼‰ã‚„çµµæ–‡å­—ã¯è‡ªå‹•çš„ã«é™¤å»ã•ã‚Œã¾ã™ã€‚
                </p>
                <textarea class="modal-textarea" id="importTextarea" placeholder="ä¾‹ï¼š
ä¸­å¿ƒãƒ†ãƒ¼ãƒ
    å­ãƒãƒ¼ãƒ‰1
        å­«ãƒãƒ¼ãƒ‰1-1
        å­«ãƒãƒ¼ãƒ‰1-2
    å­ãƒãƒ¼ãƒ‰2
        å­«ãƒãƒ¼ãƒ‰2-1"></textarea>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeImportModal()">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
                <button class="modal-btn modal-btn-primary" onclick="importText()">èª­ã¿è¾¼ã¿</button>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal-overlay" id="exportModal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">ğŸ“„ ãƒ†ã‚­ã‚¹ãƒˆå‡ºåŠ›</span>
                <button class="modal-close" onclick="closeExportModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <div style="margin-bottom: 12px; display: flex; gap: 20px;">
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                        <input type="checkbox" id="exportShowEmoji" checked onchange="updateExportPreview()">
                        <span>çµµæ–‡å­—ã‚’è¡¨ç¤º</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                        <input type="checkbox" id="exportShowLines" checked onchange="updateExportPreview()">
                        <span>ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆç·šã‚’è¡¨ç¤º</span>
                    </label>
                </div>
                <textarea class="modal-textarea" id="exportTextarea" readonly></textarea>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-secondary" onclick="closeExportModal()">é–‰ã˜ã‚‹</button>
                <button class="modal-btn modal-btn-primary" onclick="copyExportText()">ğŸ“‹ ã‚³ãƒ”ãƒ¼</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">â“ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ</span>
                <button class="modal-close" onclick="closeHelpModal()">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="shortcuts-list">
                    <div class="shortcut-item">
                        <span>åŒéšå±¤ã«ãƒãƒ¼ãƒ‰è¿½åŠ </span>
                        <span class="shortcut-key">Enter</span>
                    </div>
                    <div class="shortcut-item">
                        <span>å­ãƒãƒ¼ãƒ‰è¿½åŠ </span>
                        <span class="shortcut-key">Tab</span>
                    </div>
                    <div class="shortcut-item">
                        <span>è¦ªéšå±¤ã«æˆ»ã‚‹</span>
                        <span class="shortcut-key">Shift + Tab</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ãƒãƒ¼ãƒ‰å‰Šé™¤</span>
                        <span class="shortcut-key">Delete / Backspace</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ç·¨é›†ãƒ¢ãƒ¼ãƒ‰</span>
                        <span class="shortcut-key">F2 / ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ãƒãƒ¼ãƒ‰é–“ç§»å‹•</span>
                        <span class="shortcut-key">â†‘ â†“ â† â†’</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ä¸¦ã³æ›¿ãˆï¼ˆä¸Šä¸‹ï¼‰</span>
                        <span class="shortcut-key">Cmd + â†‘ / â†“</span>
                    </div>
                    <div class="shortcut-item">
                        <span>éšå±¤ç§»å‹•</span>
                        <span class="shortcut-key">Cmd + â† / â†’</span>
                    </div>
                    <div class="shortcut-item">
                        <span>å…ƒã«æˆ»ã™</span>
                        <span class="shortcut-key">Cmd + Z</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ã‚„ã‚Šç›´ã—</span>
                        <span class="shortcut-key">Cmd + Y</span>
                    </div>
                    <div class="shortcut-item">
                        <span>å…¨é¸æŠ</span>
                        <span class="shortcut-key">Cmd + A</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ã‚³ãƒ”ãƒ¼</span>
                        <span class="shortcut-key">Cmd + C</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ãƒšãƒ¼ã‚¹ãƒˆ</span>
                        <span class="shortcut-key">Cmd + V</span>
                    </div>
                    <div class="shortcut-item">
                        <span>å¤ªå­—ãƒˆã‚°ãƒ«</span>
                        <span class="shortcut-key">Cmd + B</span>
                    </div>
                    <div class="shortcut-item">
                        <span>æ–‡å­—è‰²ãƒˆã‚°ãƒ«</span>
                        <span class="shortcut-key">Cmd + Opt + A</span>
                    </div>
                    <div class="shortcut-item">
                        <span>èƒŒæ™¯è‰²ãƒˆã‚°ãƒ«</span>
                        <span class="shortcut-key">Cmd + Opt + Y</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ç·šã®å¤ªã•ãƒˆã‚°ãƒ«</span>
                        <span class="shortcut-key">Cmd + Opt + S</span>
                    </div>
                    <div class="shortcut-item">
                        <span>ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆ</span>
                        <span class="shortcut-key">Cmd + Opt + G</span>
                    </div>
                </div>
                <p style="margin-top: 16px; color: #888; font-size: 12px;">
                    â€» Macã§ã¯ Cmdã€Windowsã§ã¯ Ctrl ã‚­ãƒ¼ã‚’ä½¿ç”¨<br>
                    â€» Option+ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒãƒ¼ãƒ‰é–“ãƒªãƒ³ã‚¯ï¼ˆèµ¤è‰²ç‚¹ç·šï¼‰ä½œæˆ
                </p>
            </div>
            <div class="modal-footer">
                <button class="modal-btn modal-btn-primary" onclick="closeHelpModal()">é–‰ã˜ã‚‹</button>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
        // ========================================
        // Global State
        // ========================================
        
        // éšå±¤åˆ¥ã‚¢ã‚¤ã‚³ãƒ³è¨­å®š
        const levelIcons = {
            1: 'ğŸ”',
            2: 'ğŸ¤',
            3: 'ğŸ£',
            4: 'ğŸ¥š'
        };

        // ãƒã‚¤ãƒ³ãƒ‰ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿æ§‹é€ 
        let mindMapData = {
            root: {
                id: 'root',
                text: 'ä¸­å¿ƒãƒ†ãƒ¼ãƒ',
                children: [],
                // ã‚¹ã‚¿ã‚¤ãƒ«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
                bold: false,
                textColor: '#333333',
                bgColor: '#ffffff',
                lineColor: '#999999',
                thickLine: false,
                grayout: false
            }
        };

        // ã‚¹ã‚¿ã‚¤ãƒ«ã®ãƒˆã‚°ãƒ«è¨­å®š
        const textColors = ['#333333', '#e53935', '#1e88e5']; // é»’ã€èµ¤ã€é’
        const bgColors = ['#ffffff', '#fff9c4', '#e0f7fa']; // ç™½ã€é»„è‰²ã€æ°´è‰²

        // é¸æŠçŠ¶æ…‹ï¼ˆè¤‡æ•°é¸æŠå¯¾å¿œï¼‰
        let selectedNodeIds = new Set(); // é¸æŠä¸­ã®ãƒãƒ¼ãƒ‰IDç¾¤
        let lastSelectedNodeId = null;   // æœ€å¾Œã«é¸æŠã—ãŸãƒãƒ¼ãƒ‰ï¼ˆç¯„å›²é¸æŠã®èµ·ç‚¹ï¼‰
        let editingNodeId = null;

        // ãƒ“ãƒ¥ãƒ¼çŠ¶æ…‹
        let viewState = {
            zoom: 1,
            panX: 0,
            panY: 0,
            isPanning: false,
            startX: 0,
            startY: 0
        };

        // Undo/Redoå±¥æ­´
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;

        // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰
        let clipboard = null;

        // IDç”Ÿæˆç”¨ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
        let nodeIdCounter = 0;

        // ãƒ†ã‚­ã‚¹ãƒˆå‡ºåŠ›ã‚ªãƒ—ã‚·ãƒ§ãƒ³
        let exportOptions = {
            showEmoji: true,
            showIndentLines: true
        };

        // ãƒãƒ¼ãƒ‰é–“ãƒªãƒ³ã‚¯ï¼ˆèµ¤è‰²ç‚¹ç·šï¼‰
        let nodeLinks = []; // { fromId, toId }
        
        // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®çŠ¶æ…‹ï¼ˆOption+ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒªãƒ³ã‚¯ä½œæˆç”¨ï¼‰
        let dragState = {
            isDragging: false,
            fromNodeId: null,
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0
        };
        
        // ãƒãƒ¼ãƒ‰ç§»å‹•ãƒ‰ãƒ©ãƒƒã‚°ã®çŠ¶æ…‹ï¼ˆé€šå¸¸ãƒ‰ãƒ©ãƒƒã‚°ã§è¦ªå­é–¢ä¿‚å¤‰æ›´ç”¨ï¼‰
        let nodeDragState = {
            isDragging: false,
            nodeId: null,
            draggedNodeIds: null, // è¤‡æ•°ãƒãƒ¼ãƒ‰ãƒ‰ãƒ©ãƒƒã‚°ç”¨
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            offsetX: 0,
            offsetY: 0,
            targetNodeId: null,
            targetPosition: null // 'child', 'before', 'after'
        };

        // ========================================
        // Utility Functions
        // ========================================

        function generateId() {
            return 'node_' + (++nodeIdCounter) + '_' + Date.now();
        }

        function deepClone(obj) {
            return JSON.parse(JSON.stringify(obj));
        }

        function showToast(message, duration = 2000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, duration);
        }

        // ========================================
        // History Management (Undo/Redo)
        // ========================================

        function saveState() {
            // ç¾åœ¨ä½ç½®ã‚ˆã‚Šå¾Œã®å±¥æ­´ã‚’å‰Šé™¤
            history = history.slice(0, historyIndex + 1);
            
            // æ–°ã—ã„çŠ¶æ…‹ã‚’è¿½åŠ 
            history.push(deepClone(mindMapData));
            
            // æœ€å¤§å±¥æ­´æ•°ã‚’è¶…ãˆãŸã‚‰å¤ã„ã‚‚ã®ã‚’å‰Šé™¤
            if (history.length > MAX_HISTORY) {
                history.shift();
            } else {
                historyIndex++;
            }
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                mindMapData = deepClone(history[historyIndex]);
                render();
                showToast('å…ƒã«æˆ»ã—ã¾ã—ãŸ');
            } else {
                showToast('ã“ã‚Œä»¥ä¸Šæˆ»ã›ã¾ã›ã‚“');
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                mindMapData = deepClone(history[historyIndex]);
                render();
                showToast('ã‚„ã‚Šç›´ã—ã¾ã—ãŸ');
            } else {
                showToast('ã“ã‚Œä»¥ä¸Šã‚„ã‚Šç›´ã›ã¾ã›ã‚“');
            }
        }

        // ========================================
        // Node Operations
        // ========================================

        function findNode(id, node = mindMapData.root, parent = null, index = 0) {
            if (node.id === id) {
                return { node, parent, index };
            }
            for (let i = 0; i < node.children.length; i++) {
                const result = findNode(id, node.children[i], node, i);
                if (result) return result;
            }
            return null;
        }

        function getNodeLevel(id, node = mindMapData.root, level = 1) {
            if (node.id === id) return level;
            for (const child of node.children) {
                const result = getNodeLevel(id, child, level + 1);
                if (result) return result;
            }
            return null;
        }

        function getAllNodes(node = mindMapData.root, result = []) {
            result.push(node);
            for (const child of node.children) {
                getAllNodes(child, result);
            }
            return result;
        }

        function addChildNode(parentId, text = 'æ–°ã—ã„ãƒãƒ¼ãƒ‰', autoEdit = true) {
            const result = findNode(parentId);
            if (result) {
                saveState();
                const newNode = {
                    id: generateId(),
                    text: text,
                    children: [],
                    bold: false,
                    textColor: '#333333',
                    bgColor: '#ffffff',
                    lineColor: '#999999',
                    thickLine: false,
                    grayout: false
                };
                result.node.children.push(newNode);
                render();
                selectNode(newNode.id);
                // è‡ªå‹•çš„ã«ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã«å…¥ã‚‹
                if (autoEdit) {
                    setTimeout(() => startEditing(newNode.id), 50);
                }
                return newNode;
            }
            return null;
        }

        function addSiblingNode(nodeId, text = 'æ–°ã—ã„ãƒãƒ¼ãƒ‰', autoEdit = true) {
            const result = findNode(nodeId);
            if (!result || !result.parent) {
                // ãƒ«ãƒ¼ãƒˆãƒãƒ¼ãƒ‰ã®å ´åˆã¯å­ãƒãƒ¼ãƒ‰ã‚’è¿½åŠ 
                return addChildNode(nodeId, text, autoEdit);
            }
            
            saveState();
            const newNode = {
                id: generateId(),
                text: text,
                children: [],
                bold: false,
                textColor: '#333333',
                bgColor: '#ffffff',
                lineColor: '#999999',
                thickLine: false,
                grayout: false
            };
            result.parent.children.splice(result.index + 1, 0, newNode);
            render();
            selectNode(newNode.id);
            // è‡ªå‹•çš„ã«ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ã«å…¥ã‚‹
            if (autoEdit) {
                setTimeout(() => startEditing(newNode.id), 50);
            }
            return newNode;
        }

        function deleteNode(nodeId) {
            if (nodeId === 'root') {
                showToast('ãƒ«ãƒ¼ãƒˆãƒãƒ¼ãƒ‰ã¯å‰Šé™¤ã§ãã¾ã›ã‚“');
                return false;
            }
            
            const result = findNode(nodeId);
            if (result && result.parent) {
                saveState();
                result.parent.children.splice(result.index, 1);
                
                // é¸æŠã‚’è¦ªã¾ãŸã¯å…„å¼Ÿã«ç§»å‹•
                if (result.parent.children.length > 0) {
                    const newIndex = Math.min(result.index, result.parent.children.length - 1);
                    selectNode(result.parent.children[newIndex].id);
                } else {
                    selectNode(result.parent.id);
                }
                
                render();
                return true;
            }
            return false;
        }

        function updateNodeText(nodeId, newText) {
            const result = findNode(nodeId);
            if (result && result.node.text !== newText) {
                saveState();
                result.node.text = newText;
            }
        }

        function moveNodeUp(nodeId) {
            const result = findNode(nodeId);
            if (result && result.parent && result.index > 0) {
                saveState();
                const siblings = result.parent.children;
                [siblings[result.index - 1], siblings[result.index]] = 
                [siblings[result.index], siblings[result.index - 1]];
                render();
                showToast('ãƒãƒ¼ãƒ‰ã‚’ä¸Šã«ç§»å‹•ã—ã¾ã—ãŸ');
            }
        }

        function moveNodeDown(nodeId) {
            const result = findNode(nodeId);
            if (result && result.parent && result.index < result.parent.children.length - 1) {
                saveState();
                const siblings = result.parent.children;
                [siblings[result.index], siblings[result.index + 1]] = 
                [siblings[result.index + 1], siblings[result.index]];
                render();
                showToast('ãƒãƒ¼ãƒ‰ã‚’ä¸‹ã«ç§»å‹•ã—ã¾ã—ãŸ');
            }
        }

        function promoteNode(nodeId) {
            // è¦ªã®å…„å¼Ÿã«ã™ã‚‹ï¼ˆéšå±¤ã‚’ä¸Šã’ã‚‹ï¼‰
            const result = findNode(nodeId);
            if (!result || !result.parent || result.parent.id === 'root') {
                showToast('ã“ã‚Œä»¥ä¸Šéšå±¤ã‚’ä¸Šã’ã‚‰ã‚Œã¾ã›ã‚“');
                return;
            }
            
            const grandparentResult = findNode(result.parent.id);
            if (grandparentResult && grandparentResult.parent) {
                saveState();
                // ç¾åœ¨ã®è¦ªã‹ã‚‰å‰Šé™¤
                result.parent.children.splice(result.index, 1);
                // ç¥–çˆ¶æ¯ã®å­ã¨ã—ã¦è¿½åŠ ï¼ˆè¦ªã®æ¬¡ã®ä½ç½®ï¼‰
                grandparentResult.parent.children.splice(grandparentResult.index + 1, 0, result.node);
                render();
                selectNode(nodeId);
                showToast('éšå±¤ã‚’ä¸Šã’ã¾ã—ãŸ');
            }
        }

        function demoteNode(nodeId) {
            // å‰ã®å…„å¼Ÿã®å­ã«ã™ã‚‹ï¼ˆéšå±¤ã‚’ä¸‹ã’ã‚‹ï¼‰
            const result = findNode(nodeId);
            if (!result || !result.parent || result.index === 0) {
                showToast('ã“ã‚Œä»¥ä¸Šéšå±¤ã‚’ä¸‹ã’ã‚‰ã‚Œã¾ã›ã‚“');
                return;
            }
            
            saveState();
            const prevSibling = result.parent.children[result.index - 1];
            // ç¾åœ¨ã®è¦ªã‹ã‚‰å‰Šé™¤
            result.parent.children.splice(result.index, 1);
            // å‰ã®å…„å¼Ÿã®å­ã¨ã—ã¦è¿½åŠ 
            prevSibling.children.push(result.node);
            render();
            selectNode(nodeId);
            showToast('éšå±¤ã‚’ä¸‹ã’ã¾ã—ãŸ');
        }

        // ========================================
        // Selection & Navigation
        // ========================================

        // å˜ä¸€é¸æŠï¼ˆå¾“æ¥ã®å‹•ä½œï¼‰
        function selectNode(nodeId) {
            clearSelection();
            if (nodeId) {
                selectedNodeIds.add(nodeId);
                lastSelectedNodeId = nodeId;
                updateSelectionDisplay();
            }
        }

        // é¸æŠã‚’ã‚¯ãƒªã‚¢
        function clearSelection() {
            selectedNodeIds.clear();
            lastSelectedNodeId = null;
            selectedLinkIndex = null; // ãƒªãƒ³ã‚¯ã®é¸æŠã‚‚è§£é™¤
            document.querySelectorAll('.node.selected').forEach(el => {
                el.classList.remove('selected');
            });
            render(); // ãƒªãƒ³ã‚¯ã®é¸æŠè¡¨ç¤ºã‚’æ›´æ–°
        }

        // é¸æŠçŠ¶æ…‹ã®è¡¨ç¤ºã‚’æ›´æ–°
        function updateSelectionDisplay() {
            document.querySelectorAll('.node').forEach(el => {
                if (selectedNodeIds.has(el.dataset.id)) {
                    el.classList.add('selected');
                } else {
                    el.classList.remove('selected');
                }
            });
        }

        // Cmd+ã‚¯ãƒªãƒƒã‚¯: ãƒˆã‚°ãƒ«é¸æŠ
        function toggleSelectNode(nodeId) {
            if (selectedNodeIds.has(nodeId)) {
                selectedNodeIds.delete(nodeId);
            } else {
                selectedNodeIds.add(nodeId);
            }
            lastSelectedNodeId = nodeId;
            updateSelectionDisplay();
        }

        // Shift+ã‚¯ãƒªãƒƒã‚¯: ç¯„å›²é¸æŠ
        function rangeSelectNode(nodeId) {
            if (!lastSelectedNodeId) {
                selectNode(nodeId);
                return;
            }
            
            const allNodes = getAllNodesInOrder();
            const startIndex = allNodes.findIndex(n => n.id === lastSelectedNodeId);
            const endIndex = allNodes.findIndex(n => n.id === nodeId);
            
            if (startIndex === -1 || endIndex === -1) {
                selectNode(nodeId);
                return;
            }
            
            // ç¯„å›²å†…ã®ãƒãƒ¼ãƒ‰ã‚’ã™ã¹ã¦é¸æŠ
            const minIndex = Math.min(startIndex, endIndex);
            const maxIndex = Math.max(startIndex, endIndex);
            
            clearSelection();
            for (let i = minIndex; i <= maxIndex; i++) {
                selectedNodeIds.add(allNodes[i].id);
            }
            lastSelectedNodeId = nodeId;
            updateSelectionDisplay();
        }

        // Cmd+Shift+ã‚¯ãƒªãƒƒã‚¯: ç¯„å›²è¿½åŠ é¸æŠ
        function rangeAddSelectNode(nodeId) {
            if (!lastSelectedNodeId) {
                toggleSelectNode(nodeId);
                return;
            }
            
            const allNodes = getAllNodesInOrder();
            const startIndex = allNodes.findIndex(n => n.id === lastSelectedNodeId);
            const endIndex = allNodes.findIndex(n => n.id === nodeId);
            
            if (startIndex === -1 || endIndex === -1) {
                toggleSelectNode(nodeId);
                return;
            }
            
            // ç¯„å›²å†…ã®ãƒãƒ¼ãƒ‰ã‚’è¿½åŠ é¸æŠï¼ˆæ—¢å­˜ã®é¸æŠã¯ç¶­æŒï¼‰
            const minIndex = Math.min(startIndex, endIndex);
            const maxIndex = Math.max(startIndex, endIndex);
            
            for (let i = minIndex; i <= maxIndex; i++) {
                selectedNodeIds.add(allNodes[i].id);
            }
            lastSelectedNodeId = nodeId;
            updateSelectionDisplay();
        }

        // ãƒãƒ¼ãƒ‰ã‚’æ·±ã•å„ªå…ˆé †ã§å–å¾—
        function getAllNodesInOrder(node = mindMapData.root, result = []) {
            result.push(node);
            for (const child of node.children) {
                getAllNodesInOrder(child, result);
            }
            return result;
        }

        // é¸æŠä¸­ã®ãƒãƒ¼ãƒ‰ã‚’å–å¾—ï¼ˆäº’æ›æ€§ã®ãŸã‚ï¼‰
        function getSelectedNodeId() {
            if (selectedNodeIds.size === 0) return null;
            return lastSelectedNodeId || selectedNodeIds.values().next().value;
        }

        // é¸æŠä¸­ã®ãƒãƒ¼ãƒ‰ç¾¤ã‚’å–å¾—
        function getSelectedNodes() {
            const nodes = [];
            for (const id of selectedNodeIds) {
                const result = findNode(id);
                if (result) nodes.push(result.node);
            }
            return nodes;
        }

        function navigateUp() {
            const currentId = getSelectedNodeId();
            if (!currentId) {
                selectNode('root');
                return;
            }
            
            const result = findNode(currentId);
            if (result && result.parent && result.index > 0) {
                // å‰ã®å…„å¼Ÿã®æœ€å¾Œã®å­å­«ã‚’é¸æŠ
                let target = result.parent.children[result.index - 1];
                while (target.children.length > 0) {
                    target = target.children[target.children.length - 1];
                }
                selectNode(target.id);
            } else if (result && result.parent) {
                selectNode(result.parent.id);
            }
        }

        function navigateDown() {
            const currentId = getSelectedNodeId();
            if (!currentId) {
                selectNode('root');
                return;
            }
            
            const result = findNode(currentId);
            if (!result) return;
            
            // ã¾ãšå­ãŒã‚ã‚Œã°æœ€åˆã®å­ã¸
            if (result.node.children.length > 0) {
                selectNode(result.node.children[0].id);
                return;
            }
            
            // æ¬¡ã®å…„å¼Ÿã‚’æ¢ã™
            let current = result;
            while (current.parent) {
                if (current.index < current.parent.children.length - 1) {
                    selectNode(current.parent.children[current.index + 1].id);
                    return;
                }
                current = findNode(current.parent.id);
            }
        }

        function navigateLeft() {
            const currentId = getSelectedNodeId();
            if (!currentId) {
                selectNode('root');
                return;
            }
            
            const result = findNode(currentId);
            if (result && result.parent) {
                selectNode(result.parent.id);
            }
        }

        function navigateRight() {
            const currentId = getSelectedNodeId();
            if (!currentId) {
                selectNode('root');
                return;
            }
            
            const result = findNode(currentId);
            if (result && result.node.children.length > 0) {
                selectNode(result.node.children[0].id);
            }
        }

        function goToParent() {
            const currentId = getSelectedNodeId();
            if (!currentId || currentId === 'root') return;
            
            const result = findNode(currentId);
            if (result && result.parent) {
                selectNode(result.parent.id);
            }
        }

        // ========================================
        // Edit Mode
        // ========================================

        function startEditing(nodeId) {
            if (editingNodeId) {
                finishEditing();
            }
            
            editingNodeId = nodeId;
            selectNode(nodeId);
            
            const nodeEl = document.querySelector(`[data-id="${nodeId}"]`);
            const textEl = nodeEl?.querySelector('.node-text');
            
            if (textEl) {
                nodeEl.classList.add('editing');
                textEl.contentEditable = true;
                textEl.focus();
                
                // å…¨é¸æŠ
                const range = document.createRange();
                range.selectNodeContents(textEl);
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
        }

        function finishEditing() {
            if (!editingNodeId) return;
            
            const nodeEl = document.querySelector(`[data-id="${editingNodeId}"]`);
            const textEl = nodeEl?.querySelector('.node-text');
            
            if (textEl) {
                const newText = textEl.textContent.trim() || 'ç©ºã®ãƒãƒ¼ãƒ‰';
                updateNodeText(editingNodeId, newText);
                textEl.contentEditable = false;
                nodeEl.classList.remove('editing');
            }
            
            editingNodeId = null;
        }

        // ========================================
        // Copy & Paste
        // ========================================

        function copyNode() {
            const currentId = getSelectedNodeId();
            if (!currentId) return;
            
            const result = findNode(currentId);
            if (result) {
                clipboard = deepClone(result.node);
                showToast('ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
            }
        }

        function pasteNode() {
            const currentId = getSelectedNodeId();
            if (!clipboard || !currentId) return;
            
            const result = findNode(currentId);
            if (result) {
                saveState();
                
                // IDã‚’æ–°ã—ãæŒ¯ã‚Šç›´ã™
                const cloned = deepClone(clipboard);
                function reassignIds(node) {
                    node.id = generateId();
                    node.children.forEach(reassignIds);
                }
                reassignIds(cloned);
                
                result.node.children.push(cloned);
                render();
                selectNode(cloned.id);
                showToast('ãƒšãƒ¼ã‚¹ãƒˆã—ã¾ã—ãŸ');
            }
        }

        function selectAll() {
            // ã™ã¹ã¦ã®ãƒãƒ¼ãƒ‰ã‚’é¸æŠ
            const allNodes = getAllNodesInOrder();
            
            if (selectedNodeIds.size === allNodes.length) {
                // å…¨é¸æŠæ¸ˆã¿ãªã‚‰è§£é™¤
                clearSelection();
                showToast('é¸æŠã‚’è§£é™¤ã—ã¾ã—ãŸ');
            } else {
                // å…¨ãƒãƒ¼ãƒ‰ã‚’é¸æŠ
                selectedNodeIds.clear();
                allNodes.forEach(node => {
                    selectedNodeIds.add(node.id);
                });
                lastSelectedNodeId = allNodes[0]?.id || null;
                updateSelectionDisplay();
                showToast('å…¨ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¾ã—ãŸ');
            }
        }

        // ========================================
        // Style Toggle Functions
        // ========================================

        function toggleBold() {
            if (selectedNodeIds.size === 0) {
                showToast('ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const nodesToToggle = getSelectedNodes();
            if (nodesToToggle.length === 0) return;
            
            saveState();
            nodesToToggle.forEach(node => {
                node.bold = !node.bold;
            });
            render();
            showToast(nodesToToggle[0].bold ? 'å¤ªå­—ã«ã—ã¾ã—ãŸ' : 'å¤ªå­—ã‚’è§£é™¤ã—ã¾ã—ãŸ');
        }

        function toggleTextColor() {
            if (selectedNodeIds.size === 0) {
                showToast('ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const nodesToToggle = getSelectedNodes();
            if (nodesToToggle.length === 0) return;
            
            saveState();
            nodesToToggle.forEach(node => {
                const currentIndex = textColors.indexOf(node.textColor || '#333333');
                const nextIndex = (currentIndex + 1) % textColors.length;
                node.textColor = textColors[nextIndex];
            });
            render();
            
            const colorNames = {'#333333': 'é»’', '#e53935': 'èµ¤', '#1e88e5': 'é’'};
            showToast(`æ–‡å­—è‰²: ${colorNames[nodesToToggle[0].textColor] || 'é»’'}`);
        }

        function toggleBgColor() {
            if (selectedNodeIds.size === 0) {
                showToast('ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const nodesToToggle = getSelectedNodes();
            if (nodesToToggle.length === 0) return;
            
            saveState();
            nodesToToggle.forEach(node => {
                const currentIndex = bgColors.indexOf(node.bgColor || '#ffffff');
                const nextIndex = (currentIndex + 1) % bgColors.length;
                node.bgColor = bgColors[nextIndex];
            });
            render();
            
            const colorNames = {'#ffffff': 'ç™½', '#fff9c4': 'é»„è‰²', '#e0f7fa': 'æ°´è‰²'};
            showToast(`èƒŒæ™¯è‰²: ${colorNames[nodesToToggle[0].bgColor] || 'ç™½'}`);
        }

        function toggleThickLine() {
            if (selectedNodeIds.size === 0) {
                showToast('ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            // ãƒ«ãƒ¼ãƒˆãƒãƒ¼ãƒ‰ã‚’é™¤å¤–
            const nodesToToggle = getSelectedNodes().filter(n => n.id !== 'root');
            if (nodesToToggle.length === 0) {
                showToast('ãƒ«ãƒ¼ãƒˆä»¥å¤–ã®ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            saveState();
            nodesToToggle.forEach(node => {
                node.thickLine = !node.thickLine;
            });
            render();
            showToast(nodesToToggle[0].thickLine ? 'ç·šã‚’å¤ªãã—ã¾ã—ãŸ' : 'ç·šã‚’é€šå¸¸ã«æˆ»ã—ã¾ã—ãŸ');
        }

        function toggleGrayout() {
            if (selectedNodeIds.size === 0) {
                showToast('ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const nodesToToggle = getSelectedNodes();
            if (nodesToToggle.length === 0) return;
            
            saveState();
            nodesToToggle.forEach(node => {
                node.grayout = !node.grayout;
            });
            render();
            showToast(nodesToToggle[0].grayout ? 'ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ' : 'ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆã‚’è§£é™¤ã—ã¾ã—ãŸ');
        }

        // ========================================
        // Style Dropdown Functions
        // ========================================
        
        let activeDropdown = null;
        
        function toggleStyleDropdown(type) {
            const dropdownId = type + 'Dropdown';
            const dropdown = document.getElementById(dropdownId);
            const btn = dropdown.previousElementSibling;
            
            // ä»–ã®ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã‚’é–‰ã˜ã‚‹
            document.querySelectorAll('.style-dropdown').forEach(d => {
                if (d.id !== dropdownId) {
                    d.classList.remove('active');
                    d.previousElementSibling.classList.remove('active');
                }
            });
            
            // ãƒˆã‚°ãƒ«
            if (dropdown.classList.contains('active')) {
                dropdown.classList.remove('active');
                btn.classList.remove('active');
                activeDropdown = null;
            } else {
                dropdown.classList.add('active');
                btn.classList.add('active');
                activeDropdown = dropdownId;
                updateDropdownSelection(type);
            }
        }
        
        function closeAllDropdowns() {
            document.querySelectorAll('.style-dropdown').forEach(d => {
                d.classList.remove('active');
                d.previousElementSibling.classList.remove('active');
            });
            activeDropdown = null;
        }
        
        // ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³å¤–ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.style-dropdown-wrapper')) {
                closeAllDropdowns();
            }
        });
        
        function updateDropdownSelection(type) {
            // é¸æŠã•ã‚Œã¦ã„ã‚‹ãƒãƒ¼ãƒ‰ã®è‰²ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            const nodes = getSelectedNodes();
            if (nodes.length === 0) return;
            
            const firstNode = nodes[0];
            
            if (type === 'bgColor') {
                const color = firstNode.bgColor || '#ffffff';
                document.getElementById('bgColorPicker').value = color;
                document.querySelectorAll('#bgColorPresets .color-preset').forEach(el => {
                    el.classList.toggle('selected', el.dataset.color === color);
                });
            } else if (type === 'textColor') {
                const color = firstNode.textColor || '#333333';
                document.getElementById('textColorPicker').value = color;
                document.querySelectorAll('#textColorPresets .color-preset').forEach(el => {
                    el.classList.toggle('selected', el.dataset.color === color);
                });
            } else if (type === 'lineColor') {
                const color = firstNode.lineColor || '#999999';
                document.getElementById('lineColorPicker').value = color;
                document.querySelectorAll('#lineColorPresets .color-preset').forEach(el => {
                    el.classList.toggle('selected', el.dataset.color === color);
                });
                // ç·šã®å¤ªã•é¸æŠçŠ¶æ…‹
                document.getElementById('lineThicknessNormal').classList.toggle('selected', !firstNode.thickLine);
                document.getElementById('lineThicknessThick').classList.toggle('selected', !!firstNode.thickLine);
            }
        }
        
        function setBgColor(color) {
            if (selectedNodeIds.size === 0) {
                showToast('ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const nodesToStyle = getSelectedNodes();
            if (nodesToStyle.length === 0) return;
            
            saveState();
            nodesToStyle.forEach(node => {
                node.bgColor = color;
                // ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆè§£é™¤
                if (node.grayout) node.grayout = false;
            });
            render();
            updateStyleIndicators();
            
            // ãƒ—ãƒªã‚»ãƒƒãƒˆé¸æŠçŠ¶æ…‹æ›´æ–°
            document.querySelectorAll('#bgColorPresets .color-preset').forEach(el => {
                el.classList.toggle('selected', el.dataset.color === color);
            });
            document.getElementById('bgColorPicker').value = color;
            
            showToast('èƒŒæ™¯è‰²ã‚’å¤‰æ›´ã—ã¾ã—ãŸ');
        }
        
        function setTextColor(color) {
            if (selectedNodeIds.size === 0) {
                showToast('ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            const nodesToStyle = getSelectedNodes();
            if (nodesToStyle.length === 0) return;
            
            saveState();
            nodesToStyle.forEach(node => {
                node.textColor = color;
                // ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆè§£é™¤
                if (node.grayout) node.grayout = false;
            });
            render();
            updateStyleIndicators();
            
            // ãƒ—ãƒªã‚»ãƒƒãƒˆé¸æŠçŠ¶æ…‹æ›´æ–°
            document.querySelectorAll('#textColorPresets .color-preset').forEach(el => {
                el.classList.toggle('selected', el.dataset.color === color);
            });
            document.getElementById('textColorPicker').value = color;
            
            showToast('æ–‡å­—è‰²ã‚’å¤‰æ›´ã—ã¾ã—ãŸ');
        }
        
        function setLineColor(color) {
            if (selectedNodeIds.size === 0) {
                showToast('ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            // ãƒ«ãƒ¼ãƒˆãƒãƒ¼ãƒ‰ã‚’é™¤å¤–
            const nodesToStyle = getSelectedNodes().filter(n => n.id !== 'root');
            if (nodesToStyle.length === 0) {
                showToast('ãƒ«ãƒ¼ãƒˆä»¥å¤–ã®ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            saveState();
            nodesToStyle.forEach(node => {
                node.lineColor = color;
            });
            render();
            updateStyleIndicators();
            
            // ãƒ—ãƒªã‚»ãƒƒãƒˆé¸æŠçŠ¶æ…‹æ›´æ–°
            document.querySelectorAll('#lineColorPresets .color-preset').forEach(el => {
                el.classList.toggle('selected', el.dataset.color === color);
            });
            document.getElementById('lineColorPicker').value = color;
            
            showToast('ç·šã®è‰²ã‚’å¤‰æ›´ã—ã¾ã—ãŸ');
        }
        
        function setLineThickness(thick) {
            if (selectedNodeIds.size === 0) {
                showToast('ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            // ãƒ«ãƒ¼ãƒˆãƒãƒ¼ãƒ‰ã‚’é™¤å¤–
            const nodesToStyle = getSelectedNodes().filter(n => n.id !== 'root');
            if (nodesToStyle.length === 0) {
                showToast('ãƒ«ãƒ¼ãƒˆä»¥å¤–ã®ãƒãƒ¼ãƒ‰ã‚’é¸æŠã—ã¦ãã ã•ã„');
                return;
            }
            
            saveState();
            nodesToStyle.forEach(node => {
                node.thickLine = thick;
            });
            render();
            
            // é¸æŠçŠ¶æ…‹æ›´æ–°
            document.getElementById('lineThicknessNormal').classList.toggle('selected', !thick);
            document.getElementById('lineThicknessThick').classList.toggle('selected', thick);
            
            showToast(thick ? 'ç·šã‚’å¤ªãã—ã¾ã—ãŸ' : 'ç·šã‚’é€šå¸¸ã«æˆ»ã—ã¾ã—ãŸ');
        }
        
        function updateStyleIndicators() {
            // é¸æŠã•ã‚Œã¦ã„ã‚‹ãƒãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã«åæ˜ 
            const nodes = getSelectedNodes();
            if (nodes.length === 0) return;
            
            const firstNode = nodes[0];
            
            // èƒŒæ™¯è‰²ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
            const bgIndicator = document.getElementById('bgColorIndicator');
            if (bgIndicator) {
                bgIndicator.style.background = firstNode.grayout ? '#e0e0e0' : (firstNode.bgColor || '#ffffff');
            }
            
            // æ–‡å­—è‰²ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
            const textIndicator = document.getElementById('textColorIndicator');
            if (textIndicator) {
                textIndicator.style.background = firstNode.grayout ? '#9e9e9e' : (firstNode.textColor || '#333333');
            }
            
            // ç·šè‰²ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
            const lineIndicator = document.getElementById('lineColorIndicator');
            if (lineIndicator) {
                lineIndicator.style.background = firstNode.lineColor || '#999999';
            }
        }

        // ========================================
        // Node Link (Red Dotted Line)
        // ========================================

        function startLinkDrag(nodeId, clientX, clientY) {
            dragState.isDragging = true;
            dragState.fromNodeId = nodeId;
            dragState.startX = clientX;
            dragState.startY = clientY;
            dragState.currentX = clientX;
            dragState.currentY = clientY;
            
            document.body.style.cursor = 'crosshair';
        }

        function updateLinkDrag(clientX, clientY) {
            if (!dragState.isDragging) return;
            
            dragState.currentX = clientX;
            dragState.currentY = clientY;
            
            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒãƒ¼ãƒ‰ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            document.querySelectorAll('.node').forEach(el => {
                el.classList.remove('link-target');
            });
            
            const targetNode = getNodeAtPosition(clientX, clientY);
            if (targetNode && targetNode.id !== dragState.fromNodeId) {
                const el = document.querySelector(`[data-id="${targetNode.id}"]`);
                if (el) el.classList.add('link-target');
            }
            
            render();
        }

        function endLinkDrag(clientX, clientY) {
            if (!dragState.isDragging) return;
            
            const targetNode = getNodeAtPosition(clientX, clientY);
            
            if (targetNode && targetNode.id !== dragState.fromNodeId) {
                // æ—¢å­˜ã®ãƒªãƒ³ã‚¯ã‚’ãƒã‚§ãƒƒã‚¯
                const existingLink = nodeLinks.find(
                    l => (l.fromId === dragState.fromNodeId && l.toId === targetNode.id) ||
                         (l.fromId === targetNode.id && l.toId === dragState.fromNodeId)
                );
                
                if (existingLink) {
                    // æ—¢å­˜ã®ãƒªãƒ³ã‚¯ã‚’å‰Šé™¤
                    nodeLinks = nodeLinks.filter(l => l !== existingLink);
                    showToast('ãƒªãƒ³ã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
                } else {
                    // æ–°ã—ã„ãƒªãƒ³ã‚¯ã‚’è¿½åŠ 
                    nodeLinks.push({
                        fromId: dragState.fromNodeId,
                        toId: targetNode.id
                    });
                    showToast('ãƒªãƒ³ã‚¯ã‚’ä½œæˆã—ã¾ã—ãŸ');
                }
            }
            
            // ãƒ‰ãƒ©ãƒƒã‚°çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            dragState.isDragging = false;
            dragState.fromNodeId = null;
            document.body.style.cursor = '';
            
            document.querySelectorAll('.node').forEach(el => {
                el.classList.remove('link-target');
            });
            
            render();
        }

        function getNodeAtPosition(clientX, clientY) {
            const elements = document.elementsFromPoint(clientX, clientY);
            for (const el of elements) {
                if (el.classList.contains('node') && !el.classList.contains('drag-ghost')) {
                    const nodeId = el.dataset.id;
                    return findNode(nodeId)?.node;
                }
            }
            return null;
        }

        // ========================================
        // Node Drag & Drop (Reparenting)
        // ========================================

        function startNodeDrag(nodeId, clientX, clientY, nodeEl) {
            // ãƒ«ãƒ¼ãƒˆãƒãƒ¼ãƒ‰ã¯ç§»å‹•ä¸å¯
            if (nodeId === 'root') return;
            
            // å°‘ã—é…å»¶ã•ã›ã¦ã‚¯ãƒªãƒƒã‚¯ã¨ã®åŒºåˆ¥ã‚’ã¤ã‘ã‚‹
            const startTime = Date.now();
            
            const onMouseMove = (e) => {
                const moved = Math.abs(e.clientX - clientX) > 5 || Math.abs(e.clientY - clientY) > 5;
                const elapsed = Date.now() - startTime;
                
                if (moved && elapsed > 100 && !nodeDragState.isDragging) {
                    // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
                    nodeDragState.isDragging = true;
                    nodeDragState.nodeId = nodeId;
                    nodeDragState.startX = clientX;
                    nodeDragState.startY = clientY;
                    nodeDragState.currentX = e.clientX;
                    nodeDragState.currentY = e.clientY;
                    
                    // è¤‡æ•°é¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨ã€ãã†ã§ãªã‘ã‚Œã°ã‚¯ãƒªãƒƒã‚¯ã—ãŸãƒãƒ¼ãƒ‰ã®ã¿
                    if (selectedNodeIds.has(nodeId) && selectedNodeIds.size > 1) {
                        // é¸æŠã•ã‚Œã¦ã„ã‚‹ãƒãƒ¼ãƒ‰ã‚’ãƒ‰ãƒ©ãƒƒã‚°å¯¾è±¡ã«ï¼ˆãƒ«ãƒ¼ãƒˆã‚’é™¤ãï¼‰
                        nodeDragState.draggedNodeIds = [...selectedNodeIds].filter(id => id !== 'root');
                    } else {
                        nodeDragState.draggedNodeIds = [nodeId];
                    }
                    
                    // ã‚´ãƒ¼ã‚¹ãƒˆãƒãƒ¼ãƒ‰ã‚’ä½œæˆï¼ˆè¤‡æ•°ã®å ´åˆã¯ãƒãƒƒã‚¸ä»˜ãï¼‰
                    createDragGhost(nodeEl, e.clientX, e.clientY, nodeDragState.draggedNodeIds.length);
                    
                    // å…ƒã®ãƒãƒ¼ãƒ‰ã‚’åŠé€æ˜ã«
                    nodeDragState.draggedNodeIds.forEach(id => {
                        const el = document.querySelector(`[data-id="${id}"]`);
                        if (el) el.classList.add('dragging');
                    });
                }
                
                if (nodeDragState.isDragging) {
                    updateNodeDrag(e.clientX, e.clientY);
                }
            };
            
            const onMouseUp = (e) => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                
                if (nodeDragState.isDragging) {
                    endNodeDrag(e.clientX, e.clientY);
                }
            };
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function createDragGhost(nodeEl, clientX, clientY, count = 1) {
            // æ—¢å­˜ã®ã‚´ãƒ¼ã‚¹ãƒˆã‚’å‰Šé™¤
            const existingGhost = document.querySelector('.drag-ghost');
            if (existingGhost) existingGhost.remove();
            
            // ã‚´ãƒ¼ã‚¹ãƒˆã‚’ä½œæˆ
            const ghost = nodeEl.cloneNode(true);
            ghost.classList.add('drag-ghost');
            ghost.classList.remove('selected', 'dragging');
            ghost.style.left = clientX + 'px';
            ghost.style.top = clientY + 'px';
            ghost.style.transform = 'translate(-50%, -50%)';
            ghost.style.position = 'fixed';
            ghost.style.width = nodeEl.offsetWidth + 'px';
            
            // è¤‡æ•°ãƒãƒ¼ãƒ‰ã®å ´åˆã¯ãƒãƒƒã‚¸ã‚’è¿½åŠ 
            if (count > 1) {
                const badge = document.createElement('span');
                badge.style.cssText = `
                    position: absolute;
                    top: -8px;
                    right: -8px;
                    background: #e53935;
                    color: white;
                    border-radius: 50%;
                    width: 24px;
                    height: 24px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 12px;
                    font-weight: bold;
                `;
                badge.textContent = count;
                ghost.appendChild(badge);
            }
            
            document.body.appendChild(ghost);
        }

        function updateNodeDrag(clientX, clientY) {
            if (!nodeDragState.isDragging) return;
            
            nodeDragState.currentX = clientX;
            nodeDragState.currentY = clientY;
            
            // ã‚´ãƒ¼ã‚¹ãƒˆã‚’ç§»å‹•
            const ghost = document.querySelector('.drag-ghost');
            if (ghost) {
                ghost.style.left = clientX + 'px';
                ghost.style.top = clientY + 'px';
            }
            
            // ã™ã¹ã¦ã®ãƒãƒ¼ãƒ‰ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢
            document.querySelectorAll('.node').forEach(el => {
                el.classList.remove('drag-over-child', 'drag-over-before', 'drag-over-after');
            });
            
            // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’æ¤œå‡º
            const targetInfo = getDropTarget(clientX, clientY);
            nodeDragState.targetNodeId = targetInfo?.nodeId || null;
            nodeDragState.targetPosition = targetInfo?.position || null;
            
            // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            if (targetInfo) {
                const targetEl = document.querySelector(`[data-id="${targetInfo.nodeId}"]`);
                if (targetEl) {
                    if (targetInfo.position === 'child') {
                        targetEl.classList.add('drag-over-child');
                    } else if (targetInfo.position === 'before') {
                        targetEl.classList.add('drag-over-before');
                    } else if (targetInfo.position === 'after') {
                        targetEl.classList.add('drag-over-after');
                    }
                }
            }
        }

        function getDropTarget(clientX, clientY) {
            const elements = document.elementsFromPoint(clientX, clientY);
            const draggedIds = nodeDragState.draggedNodeIds || [nodeDragState.nodeId];
            
            for (const el of elements) {
                if (el.classList.contains('node') && !el.classList.contains('drag-ghost')) {
                    const targetId = el.dataset.id;
                    
                    // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ãƒãƒ¼ãƒ‰è‡ªèº«ã«ã¯ãƒ‰ãƒ­ãƒƒãƒ—ä¸å¯
                    if (draggedIds.includes(targetId)) continue;
                    
                    // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ãƒãƒ¼ãƒ‰ã®å­å­«ã«ã¯ãƒ‰ãƒ­ãƒƒãƒ—ä¸å¯
                    let isDescendantOfDragged = false;
                    for (const draggedId of draggedIds) {
                        if (isDescendant(draggedId, targetId)) {
                            isDescendantOfDragged = true;
                            break;
                        }
                    }
                    if (isDescendantOfDragged) continue;
                    
                    // ãƒãƒ¼ãƒ‰ã®ä½ç½®ã«å¿œã˜ã¦ãƒ‰ãƒ­ãƒƒãƒ—ä½ç½®ã‚’æ±ºå®š
                    const rect = el.getBoundingClientRect();
                    const relativeY = clientY - rect.top;
                    const height = rect.height;
                    
                    // ãƒ«ãƒ¼ãƒˆãƒãƒ¼ãƒ‰ã®å ´åˆã¯å­ã¨ã—ã¦ã®ã¿ãƒ‰ãƒ­ãƒƒãƒ—å¯èƒ½
                    if (targetId === 'root') {
                        return { nodeId: targetId, position: 'child' };
                    }
                    
                    // ä¸Šéƒ¨1/4ãªã‚‰å‰ã«æŒ¿å…¥ã€ä¸‹éƒ¨1/4ãªã‚‰å¾Œã«æŒ¿å…¥ã€ä¸­å¤®ãªã‚‰å­ã¨ã—ã¦è¿½åŠ 
                    if (relativeY < height * 0.25) {
                        return { nodeId: targetId, position: 'before' };
                    } else if (relativeY > height * 0.75) {
                        return { nodeId: targetId, position: 'after' };
                    } else {
                        return { nodeId: targetId, position: 'child' };
                    }
                }
            }
            
            return null;
        }

        function isDescendant(ancestorId, nodeId) {
            const result = findNode(ancestorId);
            if (!result) return false;
            
            function checkChildren(node) {
                for (const child of node.children) {
                    if (child.id === nodeId) return true;
                    if (checkChildren(child)) return true;
                }
                return false;
            }
            
            return checkChildren(result.node);
        }

        function endNodeDrag(clientX, clientY) {
            if (!nodeDragState.isDragging) return;
            
            // ã‚´ãƒ¼ã‚¹ãƒˆã‚’å‰Šé™¤
            const ghost = document.querySelector('.drag-ghost');
            if (ghost) ghost.remove();
            
            // ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢
            document.querySelectorAll('.node').forEach(el => {
                el.classList.remove('dragging', 'drag-over-child', 'drag-over-before', 'drag-over-after');
            });
            
            // ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†
            if (nodeDragState.targetNodeId && nodeDragState.targetPosition) {
                const draggedIds = nodeDragState.draggedNodeIds || [nodeDragState.nodeId];
                moveNodes(
                    draggedIds, 
                    nodeDragState.targetNodeId, 
                    nodeDragState.targetPosition
                );
            }
            
            // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
            nodeDragState.isDragging = false;
            nodeDragState.nodeId = null;
            nodeDragState.draggedNodeIds = null;
            nodeDragState.targetNodeId = null;
            nodeDragState.targetPosition = null;
            
            render();
        }

        // è¤‡æ•°ãƒãƒ¼ãƒ‰ã‚’ç§»å‹•
        function moveNodes(nodeIds, targetId, position) {
            if (!nodeIds || nodeIds.length === 0) return;
            
            const targetResult = findNode(targetId);
            if (!targetResult) return;
            
            // ç§»å‹•å¯¾è±¡ã®ãƒãƒ¼ãƒ‰ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆãƒ«ãƒ¼ãƒˆã¨ã€ä»–ã®ç§»å‹•å¯¾è±¡ã®å­å­«ã¯é™¤å¤–ï¼‰
            const filteredIds = filterMovableNodes(nodeIds);
            if (filteredIds.length === 0) return;
            
            saveState();
            
            // ãƒãƒ¼ãƒ‰ãƒ‡ãƒ¼ã‚¿ã‚’åé›†ã—ã€å…ƒã®å ´æ‰€ã‹ã‚‰å‰Šé™¤
            const nodesToMove = [];
            for (const nodeId of filteredIds) {
                const nodeResult = findNode(nodeId);
                if (nodeResult && nodeResult.parent) {
                    nodesToMove.push({
                        id: nodeId,
                        data: nodeResult.node,
                        parent: nodeResult.parent,
                        index: nodeResult.index
                    });
                }
            }
            
            // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®å¤§ãã„é †ã«ã‚½ãƒ¼ãƒˆã—ã¦å‰Šé™¤ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ãšã‚Œã‚’é˜²ãï¼‰
            nodesToMove.sort((a, b) => {
                if (a.parent === b.parent) {
                    return b.index - a.index;
                }
                return 0;
            });
            
            // å…ƒã®å ´æ‰€ã‹ã‚‰å‰Šé™¤
            for (const item of nodesToMove) {
                const currentResult = findNode(item.id);
                if (currentResult && currentResult.parent) {
                    currentResult.parent.children.splice(currentResult.index, 1);
                }
            }
            
            // æ–°ã—ã„å ´æ‰€ã«è¿½åŠ ï¼ˆå…ƒã®é †åºã‚’ç¶­æŒï¼‰
            nodesToMove.reverse();
            
            if (position === 'child') {
                for (const item of nodesToMove) {
                    const newTargetResult = findNode(targetId);
                    if (newTargetResult) {
                        newTargetResult.node.children.push(item.data);
                    }
                }
                showToast(`${nodesToMove.length}å€‹ã®ãƒãƒ¼ãƒ‰ã‚’ã€Œ${targetResult.node.text}ã€ã®å­ã«ç§»å‹•ã—ã¾ã—ãŸ`);
            } else if (position === 'before') {
                for (const item of nodesToMove) {
                    const newTargetResult = findNode(targetId);
                    if (newTargetResult && newTargetResult.parent) {
                        newTargetResult.parent.children.splice(newTargetResult.index, 0, item.data);
                    }
                }
                showToast(`${nodesToMove.length}å€‹ã®ãƒãƒ¼ãƒ‰ã‚’ã€Œ${targetResult.node.text}ã€ã®å‰ã«ç§»å‹•ã—ã¾ã—ãŸ`);
            } else if (position === 'after') {
                // afterã®å ´åˆã¯é€†é †ã§æŒ¿å…¥ï¼ˆæœ€åˆã®ãƒãƒ¼ãƒ‰ãŒã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ç›´å¾Œã«æ¥ã‚‹ã‚ˆã†ã«ï¼‰
                nodesToMove.reverse();
                for (const item of nodesToMove) {
                    const newTargetResult = findNode(targetId);
                    if (newTargetResult && newTargetResult.parent) {
                        newTargetResult.parent.children.splice(newTargetResult.index + 1, 0, item.data);
                    }
                }
                showToast(`${nodesToMove.length}å€‹ã®ãƒãƒ¼ãƒ‰ã‚’ã€Œ${targetResult.node.text}ã€ã®å¾Œã«ç§»å‹•ã—ã¾ã—ãŸ`);
            }
            
            // ç§»å‹•ã—ãŸãƒãƒ¼ãƒ‰ã‚’é¸æŠçŠ¶æ…‹ã«
            selectedNodeIds.clear();
            for (const item of nodesToMove) {
                selectedNodeIds.add(item.id);
            }
            lastSelectedNodeId = nodesToMove[0]?.id || null;
        }

        // ç§»å‹•å¯èƒ½ãªãƒãƒ¼ãƒ‰ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆè¦ªå­é–¢ä¿‚ã«ã‚ã‚‹ãƒãƒ¼ãƒ‰ã¯è¦ªã®ã¿ã‚’ç§»å‹•ï¼‰
        function filterMovableNodes(nodeIds) {
            const result = [];
            
            for (const nodeId of nodeIds) {
                if (nodeId === 'root') continue;
                
                // ã“ã®ãƒãƒ¼ãƒ‰ã®ç¥–å…ˆãŒç§»å‹•å¯¾è±¡ã«å«ã¾ã‚Œã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
                let hasAncestorInList = false;
                for (const otherId of nodeIds) {
                    if (otherId !== nodeId && isDescendant(otherId, nodeId)) {
                        hasAncestorInList = true;
                        break;
                    }
                }
                
                if (!hasAncestorInList) {
                    result.push(nodeId);
                }
            }
            
            return result;
        }

        // ========================================
        // Rendering
        // ========================================

        function render() {
            const container = document.getElementById('canvasInner');
            const svg = document.getElementById('linesSvg');
            
            // æ—¢å­˜ã®ãƒãƒ¼ãƒ‰ã‚’ã‚¯ãƒªã‚¢ï¼ˆSVGä»¥å¤–ï¼‰
            const existingNodes = container.querySelectorAll('.node');
            existingNodes.forEach(n => n.remove());
            
            // SVGã‚’ã‚¯ãƒªã‚¢
            svg.innerHTML = '';
            
            // ãƒãƒ¼ãƒ‰ã‚’å†å¸°çš„ã«é…ç½®
            const positions = {};
            layoutNodes(mindMapData.root, positions);
            
            // ãƒãƒ¼ãƒ‰ã‚’æç”»
            renderNodes(mindMapData.root, container, positions);
            
            // æ¥ç¶šç·šã‚’æç”»
            renderLines(mindMapData.root, svg, positions);
            
            // ãƒãƒ¼ãƒ‰é–“ãƒªãƒ³ã‚¯ï¼ˆèµ¤è‰²ç‚¹ç·šï¼‰ã‚’æç”»
            renderNodeLinks(svg, positions);
            
            // ãƒ‰ãƒ©ãƒƒã‚°ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æç”»
            renderDragPreview(svg, positions);
            
            // é¸æŠçŠ¶æ…‹ã‚’å¾©å…ƒ
            updateSelectionDisplay();
            
            // ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–°
            updateView();
        }

        function layoutNodes(node, positions, x = 0, y = 0, level = 1) {
            const nodeWidth = 150;
            const nodeHeight = 40;
            const horizontalGap = 80;
            const verticalGap = 20;
            
            // å­ãƒãƒ¼ãƒ‰ã®ç·é«˜ã•ã‚’è¨ˆç®—
            let totalChildrenHeight = 0;
            const childHeights = [];
            
            for (const child of node.children) {
                const childHeight = calculateSubtreeHeight(child, verticalGap, nodeHeight);
                childHeights.push(childHeight);
                totalChildrenHeight += childHeight;
            }
            
            if (node.children.length > 1) {
                totalChildrenHeight += (node.children.length - 1) * verticalGap;
            }
            
            // ç¾åœ¨ã®ãƒãƒ¼ãƒ‰ã‚’é…ç½®
            positions[node.id] = {
                x: x,
                y: y,
                width: nodeWidth,
                height: nodeHeight,
                level: level
            };
            
            // å­ãƒãƒ¼ãƒ‰ã‚’é…ç½®
            let childY = y - totalChildrenHeight / 2;
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                const childHeight = childHeights[i];
                const childCenterY = childY + childHeight / 2;
                
                layoutNodes(
                    child, 
                    positions, 
                    x + nodeWidth + horizontalGap, 
                    childCenterY,
                    level + 1
                );
                
                childY += childHeight + verticalGap;
            }
            
            return positions;
        }

        function calculateSubtreeHeight(node, gap, nodeHeight) {
            if (node.children.length === 0) {
                return nodeHeight;
            }
            
            let totalHeight = 0;
            for (const child of node.children) {
                totalHeight += calculateSubtreeHeight(child, gap, nodeHeight);
            }
            totalHeight += (node.children.length - 1) * gap;
            
            return Math.max(nodeHeight, totalHeight);
        }

        function renderNodes(node, container, positions) {
            const pos = positions[node.id];
            if (!pos) return;
            
            const nodeEl = document.createElement('div');
            nodeEl.className = 'node' + (node.id === 'root' ? ' root' : '');
            nodeEl.dataset.id = node.id;
            nodeEl.style.left = pos.x + 'px';
            nodeEl.style.top = pos.y + 'px';
            nodeEl.style.transform = 'translateY(-50%)';
            
            // ã‚¹ã‚¿ã‚¤ãƒ«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’é©ç”¨
            if (node.grayout) {
                // ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆçŠ¶æ…‹
                nodeEl.style.backgroundColor = '#e0e0e0';
                nodeEl.style.color = '#9e9e9e';
                nodeEl.style.borderColor = '#bdbdbd';
            } else {
                if (node.bgColor && node.bgColor !== '#ffffff') {
                    nodeEl.style.backgroundColor = node.bgColor;
                }
                if (node.textColor && node.textColor !== '#333333') {
                    nodeEl.style.color = node.textColor;
                }
            }
            if (node.bold) {
                nodeEl.style.fontWeight = 'bold';
            }
            
            const textEl = document.createElement('span');
            textEl.className = 'node-text';
            textEl.textContent = node.text;
            nodeEl.appendChild(textEl);
            
            // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            nodeEl.addEventListener('click', (e) => {
                e.stopPropagation();
                if (editingNodeId !== node.id && !nodeDragState.isDragging) {
                    finishEditing();
                    
                    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                    const cmdKey = isMac ? e.metaKey : e.ctrlKey;
                    
                    if (cmdKey && e.shiftKey) {
                        // Cmd+Shift+ã‚¯ãƒªãƒƒã‚¯: ç¯„å›²è¿½åŠ é¸æŠ
                        rangeAddSelectNode(node.id);
                    } else if (e.shiftKey) {
                        // Shift+ã‚¯ãƒªãƒƒã‚¯: ç¯„å›²é¸æŠ
                        rangeSelectNode(node.id);
                    } else if (cmdKey) {
                        // Cmd+ã‚¯ãƒªãƒƒã‚¯: ãƒˆã‚°ãƒ«é¸æŠ
                        toggleSelectNode(node.id);
                    } else {
                        // é€šå¸¸ã‚¯ãƒªãƒƒã‚¯: å˜ä¸€é¸æŠ
                        selectNode(node.id);
                    }
                }
            });
            
            nodeEl.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                startEditing(node.id);
            });
            
            // ãƒã‚¦ã‚¹ãƒ€ã‚¦ãƒ³: ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
            nodeEl.addEventListener('mousedown', (e) => {
                if (e.altKey) {
                    // Option+ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒªãƒ³ã‚¯ä½œæˆ
                    e.preventDefault();
                    e.stopPropagation();
                    startLinkDrag(node.id, e.clientX, e.clientY);
                } else if (!editingNodeId && e.button === 0 && !e.metaKey && !e.ctrlKey && !e.shiftKey) {
                    // é€šå¸¸ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒãƒ¼ãƒ‰ç§»å‹•ï¼ˆä¿®é£¾ã‚­ãƒ¼ãªã—ã®å ´åˆã®ã¿ï¼‰
                    e.preventDefault();
                    e.stopPropagation();
                    startNodeDrag(node.id, e.clientX, e.clientY, nodeEl);
                }
            });
            
            container.appendChild(nodeEl);
            
            // å­ãƒãƒ¼ãƒ‰ã‚’æç”»
            for (const child of node.children) {
                renderNodes(child, container, positions);
            }
        }

        function renderLines(node, svg, positions) {
            const parentPos = positions[node.id];
            if (!parentPos) return;
            
            // SVGã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆtransformã§-5000pxãšã‚‰ã—ã¦ã„ã‚‹ãŸã‚ï¼‰
            const svgOffset = 5000;
            
            for (const child of node.children) {
                const childPos = positions[child.id];
                if (!childPos) continue;
                
                const startX = parentPos.x + parentPos.width + svgOffset;
                const startY = parentPos.y + svgOffset;
                const endX = childPos.x + svgOffset;
                const endY = childPos.y + svgOffset;
                
                // ãƒ™ã‚¸ã‚§æ›²ç·šã§æ¥ç¶š
                const midX = startX + (endX - startX) / 2;
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M ${startX} ${startY} C ${midX} ${startY}, ${midX} ${endY}, ${endX} ${endY}`);
                path.setAttribute('class', 'connection-line');
                
                // ã‚«ã‚¹ã‚¿ãƒ ç·šè‰²ã®å ´åˆ
                if (child.lineColor && child.lineColor !== '#999999') {
                    path.style.stroke = child.lineColor;
                }
                
                // å¤ªç·šã®å ´åˆ
                if (child.thickLine) {
                    path.style.strokeWidth = '5px';
                    if (!child.lineColor || child.lineColor === '#999999') {
                        path.style.stroke = '#333';
                    }
                }
                
                // ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆã®å ´åˆï¼ˆä»–ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ä¸Šæ›¸ãï¼‰
                if (child.grayout) {
                    path.style.stroke = '#ccc';
                }
                
                svg.appendChild(path);
                
                // å­ã®å­ã‚‚æç”»
                renderLines(child, svg, positions);
            }
        }

        // é¸æŠä¸­ã®ãƒªãƒ³ã‚¯ID
        let selectedLinkIndex = null;

        // ãƒãƒ¼ãƒ‰é–“ãƒªãƒ³ã‚¯ï¼ˆèµ¤è‰²ç‚¹ç·šï¼‰ã‚’æç”»
        function renderNodeLinks(svg, positions) {
            const svgOffset = 5000;
            const dotsSvg = document.getElementById('dotsSvg');
            
            // å‰é¢SVGã‚‚ã‚¯ãƒªã‚¢
            dotsSvg.innerHTML = '';
            
            nodeLinks.forEach((link, index) => {
                const fromPos = positions[link.fromId];
                const toPos = positions[link.toId];
                if (!fromPos || !toPos) return;
                
                // ãƒãƒ¼ãƒ‰ã®ä½ç½®ã‚’è¨ˆç®—
                const fromCenterX = fromPos.x + fromPos.width / 2 + svgOffset;
                const fromCenterY = fromPos.y + svgOffset;
                const toCenterX = toPos.x + toPos.width / 2 + svgOffset;
                const toCenterY = toPos.y + svgOffset;
                
                // ä¸¸ãƒãƒã®ã‚µã‚¤ã‚º
                const dotRadius = 8;
                
                // ãƒãƒ¼ãƒ‰ã®ç«¯ï¼ˆä¸Šç«¯ï¼‰ã‹ã‚‰ä¸¸ãƒãƒã‚’é…ç½®ã™ã‚‹ãŸã‚ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
                const fromY = fromCenterY - 25; // ãƒãƒ¼ãƒ‰ã®ä¸Šç«¯ã‚ˆã‚Šå°‘ã—ä¸Š
                const toY = toCenterY - 25;     // ãƒãƒ¼ãƒ‰ã®ä¸Šç«¯ã‚ˆã‚Šå°‘ã—ä¸Š
                const fromX = fromCenterX;
                const toX = toCenterX;
                
                // ãƒ™ã‚¸ã‚§æ›²ç·šã§æ¥ç¶š
                const midX = (fromX + toX) / 2;
                const midY = (fromY + toY) / 2 - 40; // å°‘ã—ä¸Šã«ã‚«ãƒ¼ãƒ–
                
                // === ç‚¹ç·šéƒ¨åˆ†ï¼ˆèƒŒé¢SVGã«æç”»ï¼‰ ===
                const linkGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                linkGroup.setAttribute('class', 'link-group');
                linkGroup.setAttribute('data-link-index', index);
                linkGroup.style.cursor = 'pointer';
                
                // ã‚¯ãƒªãƒƒã‚¯æ¤œå‡ºç”¨ã®å¤ªã„é€æ˜ãƒ‘ã‚¹
                const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                hitArea.setAttribute('d', `M ${fromX} ${fromY} Q ${midX} ${midY}, ${toX} ${toY}`);
                hitArea.setAttribute('stroke', 'transparent');
                hitArea.setAttribute('stroke-width', '20');
                hitArea.setAttribute('fill', 'none');
                hitArea.style.pointerEvents = 'stroke';
                linkGroup.appendChild(hitArea);
                
                // å®Ÿéš›ã®ç‚¹ç·šãƒ‘ã‚¹
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', `M ${fromX} ${fromY} Q ${midX} ${midY}, ${toX} ${toY}`);
                path.setAttribute('class', 'link-line');
                
                // é¸æŠçŠ¶æ…‹ã®å ´åˆã¯å¤ªãã™ã‚‹
                if (selectedLinkIndex === index) {
                    path.style.strokeWidth = '4px';
                    path.style.stroke = '#c62828';
                }
                
                linkGroup.appendChild(path);
                
                // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
                linkGroup.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectLink(index);
                });
                
                svg.appendChild(linkGroup);
                
                // === ä¸¸ãƒãƒéƒ¨åˆ†ï¼ˆå‰é¢SVGã«æç”»ï¼‰ ===
                const dotGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                dotGroup.setAttribute('class', 'dot-group');
                dotGroup.setAttribute('data-link-index', index);
                dotGroup.style.cursor = 'pointer';
                
                // å§‹ç‚¹ã®ä¸¸ãƒãƒï¼ˆfromãƒãƒ¼ãƒ‰å´ï¼‰
                const startDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                startDot.setAttribute('cx', fromX);
                startDot.setAttribute('cy', fromY);
                startDot.setAttribute('r', dotRadius);
                startDot.setAttribute('fill', selectedLinkIndex === index ? '#c62828' : '#e53935');
                startDot.setAttribute('stroke', '#fff');
                startDot.setAttribute('stroke-width', '2');
                dotGroup.appendChild(startDot);
                
                // çµ‚ç‚¹ã®ä¸¸ãƒãƒï¼ˆtoãƒãƒ¼ãƒ‰å´ï¼‰
                const endDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                endDot.setAttribute('cx', toX);
                endDot.setAttribute('cy', toY);
                endDot.setAttribute('r', dotRadius);
                endDot.setAttribute('fill', selectedLinkIndex === index ? '#c62828' : '#e53935');
                endDot.setAttribute('stroke', '#fff');
                endDot.setAttribute('stroke-width', '2');
                dotGroup.appendChild(endDot);
                
                // ä¸¸ãƒãƒã‚¯ãƒªãƒƒã‚¯ã§ã‚‚ãƒªãƒ³ã‚¯é¸æŠ
                dotGroup.addEventListener('click', (e) => {
                    e.stopPropagation();
                    selectLink(index);
                });
                
                dotsSvg.appendChild(dotGroup);
            });
        }
        
        // ãƒªãƒ³ã‚¯ã‚’é¸æŠ
        function selectLink(index) {
            if (selectedLinkIndex === index) {
                // åŒã˜ãƒªãƒ³ã‚¯ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã¯é¸æŠè§£é™¤
                selectedLinkIndex = null;
            } else {
                selectedLinkIndex = index;
                // ãƒãƒ¼ãƒ‰ã®é¸æŠã‚’è§£é™¤
                selectedNodeIds.clear();
            }
            render();
        }
        
        // é¸æŠä¸­ã®ãƒªãƒ³ã‚¯ã‚’å‰Šé™¤
        function deleteSelectedLink() {
            if (selectedLinkIndex !== null && selectedLinkIndex < nodeLinks.length) {
                nodeLinks.splice(selectedLinkIndex, 1);
                selectedLinkIndex = null;
                render();
                showToast('ãƒªãƒ³ã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸ');
            }
        }

        // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç·šã‚’æç”»
        function renderDragPreview(svg, positions) {
            if (!dragState.isDragging || !dragState.fromNodeId) return;
            
            const svgOffset = 5000;
            const fromPos = positions[dragState.fromNodeId];
            if (!fromPos) return;
            
            const fromX = fromPos.x + fromPos.width / 2 + svgOffset;
            const fromY = fromPos.y + svgOffset;
            
            // ãƒã‚¦ã‚¹ä½ç½®ã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹åº§æ¨™ã«å¤‰æ›
            const toX = (dragState.currentX - viewState.panX) / viewState.zoom + svgOffset;
            const toY = (dragState.currentY - viewState.panY) / viewState.zoom + svgOffset;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M ${fromX} ${fromY} L ${toX} ${toY}`);
            path.setAttribute('class', 'link-line-preview');
            path.setAttribute('id', 'dragPreviewLine');
            svg.appendChild(path);
        }

        // ========================================
        // View Controls (Pan & Zoom)
        // ========================================

        function updateView() {
            const inner = document.getElementById('canvasInner');
            inner.style.transform = `translate(${viewState.panX}px, ${viewState.panY}px) scale(${viewState.zoom})`;
            document.getElementById('zoomLevel').textContent = Math.round(viewState.zoom * 100) + '%';
        }

        function zoomIn() {
            viewState.zoom = Math.min(2, viewState.zoom + 0.1);
            updateView();
        }

        function zoomOut() {
            viewState.zoom = Math.max(0.3, viewState.zoom - 0.1);
            updateView();
        }

        function resetView() {
            const container = document.getElementById('canvasContainer');
            viewState.zoom = 1;
            viewState.panX = container.clientWidth / 2 - 75;
            viewState.panY = container.clientHeight / 2;
            updateView();
        }

        // ========================================
        // Import / Export
        // ========================================

        function exportText() {
            // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®çŠ¶æ…‹ã‚’åæ˜ 
            document.getElementById('exportShowEmoji').checked = exportOptions.showEmoji;
            document.getElementById('exportShowLines').checked = exportOptions.showIndentLines;
            
            updateExportPreview();
            document.getElementById('exportModal').classList.add('active');
        }

        function updateExportPreview() {
            exportOptions.showEmoji = document.getElementById('exportShowEmoji').checked;
            exportOptions.showIndentLines = document.getElementById('exportShowLines').checked;
            
            const text = nodeToText(mindMapData.root, 0, []);
            document.getElementById('exportTextarea').value = text;
        }

        function nodeToText(node, level, parentContinues) {
            let result = '';
            const icon = exportOptions.showEmoji ? levelIcons[Math.min(level + 1, 4)] + ' ' : '';
            
            if (level === 0) {
                // ãƒ«ãƒ¼ãƒˆãƒãƒ¼ãƒ‰
                result = `${icon}${node.text}\n`;
            } else {
                // å‰ç½®ãã®ç¸¦ç·š
                let prefix = '';
                for (let i = 0; i < level - 1; i++) {
                    if (exportOptions.showIndentLines) {
                        prefix += parentContinues[i] ? 'â”‚   ' : '    ';
                    } else {
                        prefix += '    ';
                    }
                }
                
                // æ¥ç¶šè¨˜å·
                const isLast = parentContinues[level - 1] === false;
                let connector = '';
                if (exportOptions.showIndentLines) {
                    connector = isLast ? 'â””â”€ ' : 'â”œâ”€ ';
                } else {
                    connector = '    ';
                }
                
                result = `${prefix}${connector}${icon}${node.text}\n`;
            }
            
            // å­ãƒãƒ¼ãƒ‰ã‚’å‡¦ç†
            for (let i = 0; i < node.children.length; i++) {
                const isLastChild = i === node.children.length - 1;
                const newParentContinues = [...parentContinues, !isLastChild];
                result += nodeToText(node.children[i], level + 1, newParentContinues);
            }
            
            return result;
        }

        function copyExportText() {
            const textarea = document.getElementById('exportTextarea');
            textarea.select();
            document.execCommand('copy');
            showToast('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ');
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('active');
        }

        function showImportModal() {
            document.getElementById('importTextarea').value = '';
            document.getElementById('importModal').classList.add('active');
            document.getElementById('importTextarea').focus();
        }

        function closeImportModal() {
            document.getElementById('importModal').classList.remove('active');
        }

        function importText() {
            const text = document.getElementById('importTextarea').value.trim();
            if (!text) {
                showToast('ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
                return;
            }
            
            try {
                const newData = parseTextToMindMap(text);
                saveState();
                mindMapData = newData;
                render();
                selectNode('root');
                closeImportModal();
                showToast('èª­ã¿è¾¼ã¿ãŒå®Œäº†ã—ã¾ã—ãŸ');
            } catch (e) {
                console.error(e);
                showToast('ãƒ†ã‚­ã‚¹ãƒˆã®è§£æã«å¤±æ•—ã—ã¾ã—ãŸ');
            }
        }

        function parseTextToMindMap(text) {
            const lines = text.split('\n').filter(line => line.trim());
            if (lines.length === 0) {
                throw new Error('ç©ºã®ãƒ†ã‚­ã‚¹ãƒˆ');
            }
            
            // å„è¡Œã®ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãƒ¬ãƒ™ãƒ«ã¨ãƒ†ã‚­ã‚¹ãƒˆã‚’è§£æ
            const parsed = lines.map(line => {
                // ç½«ç·šè¨˜å·ã‚’é™¤å»ã—ã¦ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã‚’è¨ˆç®—
                const cleanedLine = line.replace(/[â”‚â”œâ””â”€â”â”˜â”Œâ”¬â”´â”¼]/g, ' ');
                
                // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãƒ¬ãƒ™ãƒ«ã‚’è¨ˆç®—ï¼ˆã‚¿ãƒ–ã¾ãŸã¯ã‚¹ãƒšãƒ¼ã‚¹4ã¤ã§1ãƒ¬ãƒ™ãƒ«ï¼‰
                let indentLevel = 0;
                let i = 0;
                while (i < cleanedLine.length) {
                    if (cleanedLine[i] === '\t') {
                        indentLevel++;
                        i++;
                    } else if (cleanedLine.substring(i, i + 4) === '    ') {
                        indentLevel++;
                        i += 4;
                    } else if (cleanedLine[i] === ' ') {
                        i++;
                    } else {
                        break;
                    }
                }
                
                // ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡ºï¼ˆçµµæ–‡å­—ãƒ»è¨˜å·ã‚’é™¤å»ï¼‰
                let nodeText = cleanedLine.substring(i).trim();
                // ä¸€èˆ¬çš„ãªçµµæ–‡å­—ã‚„ã‚¢ã‚¤ã‚³ãƒ³ã‚’é™¤å»
                nodeText = nodeText.replace(/^[ğŸ”ğŸ¤ğŸ£ğŸ¥šğŸ”µğŸ”´ğŸŸ¢ğŸŸ¡âšªâš«â—â—‹â—†â—‡â– â–¡â–²â–³â–¼â–½â˜…â˜†â†’â†â†‘â†“ğŸ“ŒğŸ“ğŸ”·ğŸ”¶ğŸ’¡ğŸ’ğŸ¯ğŸ“ğŸ”—âœ…âŒâ­ğŸŒŸ]\s*/u, '');
                nodeText = nodeText.trim() || 'ç©ºã®ãƒãƒ¼ãƒ‰';
                
                return { level: indentLevel, text: nodeText };
            });
            
            // ãƒ„ãƒªãƒ¼æ§‹é€ ã‚’æ§‹ç¯‰
            const root = {
                id: 'root',
                text: parsed[0].text,
                children: []
            };
            
            nodeIdCounter = 0;
            const stack = [{ node: root, level: parsed[0].level }];
            
            for (let i = 1; i < parsed.length; i++) {
                const { level, text } = parsed[i];
                const newNode = {
                    id: generateId(),
                    text: text,
                    children: []
                };
                
                // é©åˆ‡ãªè¦ªã‚’è¦‹ã¤ã‘ã‚‹
                while (stack.length > 1 && stack[stack.length - 1].level >= level) {
                    stack.pop();
                }
                
                // è¦ªã«è¿½åŠ 
                stack[stack.length - 1].node.children.push(newNode);
                stack.push({ node: newNode, level: level });
            }
            
            return { root };
        }

        // ========================================
        // Help Modal
        // ========================================

        function showHelpModal() {
            document.getElementById('helpModal').classList.add('active');
        }

        function closeHelpModal() {
            document.getElementById('helpModal').classList.remove('active');
        }

        // ========================================
        // Event Handlers
        // ========================================

        function handleKeyDown(e) {
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const cmdKey = isMac ? e.metaKey : e.ctrlKey;
            
            // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚‹ã¨ãã¯ç„¡è¦–
            if (document.querySelector('.modal-overlay.active')) {
                if (e.key === 'Escape') {
                    document.querySelectorAll('.modal-overlay.active').forEach(m => m.classList.remove('active'));
                }
                return;
            }
            
            // Cmd+Option+ã‚­ãƒ¼ ã®ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆï¼ˆe.codeã§åˆ¤å®šï¼‰
            if (cmdKey && e.altKey && !editingNodeId) {
                switch (e.code) {
                    case 'KeyA':
                        e.preventDefault();
                        toggleTextColor();
                        return;
                    case 'KeyY':
                        e.preventDefault();
                        toggleBgColor();
                        return;
                    case 'KeyS':
                        e.preventDefault();
                        toggleThickLine();
                        return;
                    case 'KeyG':
                        e.preventDefault();
                        toggleGrayout();
                        return;
                }
            }
            
            // ç·¨é›†ä¸­ã®ç‰¹åˆ¥å‡¦ç†
            if (editingNodeId) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    finishEditing();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    finishEditing();
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    finishEditing();
                    if (e.shiftKey) {
                        goToParent();
                    } else {
                        const currentId = getSelectedNodeId();
                        if (currentId) addChildNode(currentId);
                    }
                }
                return;
            }
            
            // ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚­ãƒ¼å‡¦ç†
            const currentId = getSelectedNodeId();
            
            switch (e.key) {
                case 'Enter':
                    e.preventDefault();
                    if (currentId) {
                        addSiblingNode(currentId);
                    }
                    break;
                    
                case 'Tab':
                    e.preventDefault();
                    if (e.shiftKey) {
                        goToParent();
                    } else if (currentId) {
                        addChildNode(currentId);
                    }
                    break;
                    
                case 'Delete':
                case 'Backspace':
                    e.preventDefault();
                    // ãƒªãƒ³ã‚¯ãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãƒªãƒ³ã‚¯ã‚’å‰Šé™¤
                    if (selectedLinkIndex !== null) {
                        deleteSelectedLink();
                    } else if (currentId && currentId !== 'root') {
                        deleteNode(currentId);
                    }
                    break;
                    
                case 'F2':
                    e.preventDefault();
                    if (currentId) {
                        startEditing(currentId);
                    }
                    break;
                    
                case 'ArrowUp':
                    e.preventDefault();
                    if (cmdKey) {
                        if (currentId) moveNodeUp(currentId);
                    } else {
                        navigateUp();
                    }
                    break;
                    
                case 'ArrowDown':
                    e.preventDefault();
                    if (cmdKey) {
                        if (currentId) moveNodeDown(currentId);
                    } else {
                        navigateDown();
                    }
                    break;
                    
                case 'ArrowLeft':
                    e.preventDefault();
                    if (cmdKey) {
                        if (currentId) promoteNode(currentId);
                    } else {
                        navigateLeft();
                    }
                    break;
                    
                case 'ArrowRight':
                    e.preventDefault();
                    if (cmdKey) {
                        if (currentId) demoteNode(currentId);
                    } else {
                        navigateRight();
                    }
                    break;
                    
                case 'z':
                case 'Z':
                    if (cmdKey) {
                        e.preventDefault();
                        undo();
                    }
                    break;
                    
                case 'y':
                case 'Y':
                    if (cmdKey) {
                        e.preventDefault();
                        redo();
                    }
                    break;
                    
                case 'a':
                case 'A':
                    if (cmdKey) {
                        // Cmd+A: å…¨é¸æŠ
                        e.preventDefault();
                        selectAll();
                    }
                    break;
                    
                case 'b':
                case 'B':
                    if (cmdKey) {
                        // Cmd+B: å¤ªå­—ãƒˆã‚°ãƒ«
                        e.preventDefault();
                        toggleBold();
                    }
                    break;
                    
                case 'c':
                case 'C':
                    if (cmdKey) {
                        e.preventDefault();
                        copyNode();
                    }
                    break;
                    
                case 'v':
                case 'V':
                    if (cmdKey) {
                        e.preventDefault();
                        pasteNode();
                    }
                    break;
                    
                case 'Escape':
                    clearSelection();
                    break;
            }
        }

        // ãƒ‘ãƒ³æ“ä½œ
        function initPanZoom() {
            const canvas = document.getElementById('canvas');
            
            // èƒŒæ™¯ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸã‚‰ãƒ‘ãƒ³é–‹å§‹
            canvas.addEventListener('mousedown', (e) => {
                // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯ãƒ‘ãƒ³ã—ãªã„
                if (dragState.isDragging || nodeDragState.isDragging) return;
                
                // èƒŒæ™¯éƒ¨åˆ†ï¼ˆcanvasè‡ªä½“ã€canvasInnerã€SVGï¼‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸå ´åˆã®ã¿ãƒ‘ãƒ³
                const isBackground = e.target === canvas || 
                                     e.target.id === 'canvasInner' || 
                                     e.target.tagName === 'svg' ||
                                     e.target.classList.contains('lines-svg') ||
                                     e.target.classList.contains('dots-svg');
                
                if (isBackground) {
                    viewState.isPanning = true;
                    viewState.startX = e.clientX - viewState.panX;
                    viewState.startY = e.clientY - viewState.panY;
                    canvas.classList.add('panning');
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                // ãƒªãƒ³ã‚¯ãƒ‰ãƒ©ãƒƒã‚°ä¸­
                if (dragState.isDragging) {
                    updateLinkDrag(e.clientX, e.clientY);
                    return;
                }
                
                // ãƒãƒ¼ãƒ‰ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯ãƒ‘ãƒ³ã—ãªã„
                if (nodeDragState.isDragging) return;
                
                // ãƒ‘ãƒ³ä¸­ï¼šèƒŒæ™¯ã‚’æ´ã‚“ã§ç§»å‹•
                if (viewState.isPanning) {
                    viewState.panX = e.clientX - viewState.startX;
                    viewState.panY = e.clientY - viewState.startY;
                    updateView();
                }
            });
            
            canvas.addEventListener('mouseup', (e) => {
                // ãƒªãƒ³ã‚¯ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†
                if (dragState.isDragging) {
                    endLinkDrag(e.clientX, e.clientY);
                    return;
                }
                
                viewState.isPanning = false;
                canvas.classList.remove('panning');
            });
            
            canvas.addEventListener('mouseleave', (e) => {
                // ãƒªãƒ³ã‚¯ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã«ã‚­ãƒ£ãƒ³ãƒã‚¹å¤–ã«å‡ºãŸå ´åˆ
                if (dragState.isDragging) {
                    endLinkDrag(e.clientX, e.clientY);
                }
                
                // ãƒãƒ¼ãƒ‰ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã«ã‚­ãƒ£ãƒ³ãƒã‚¹å¤–ã«å‡ºãŸå ´åˆ
                if (nodeDragState.isDragging) {
                    endNodeDrag(e.clientX, e.clientY);
                }
                
                viewState.isPanning = false;
                canvas.classList.remove('panning');
            });
            
            // ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ 
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                viewState.zoom = Math.max(0.3, Math.min(2, viewState.zoom + delta));
                updateView();
            }, { passive: false });
            
            // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚¯ãƒªãƒƒã‚¯ã§é¸æŠè§£é™¤
            canvas.addEventListener('click', (e) => {
                const isBackground = e.target === canvas || 
                                     e.target.id === 'canvasInner' || 
                                     e.target.tagName === 'svg' ||
                                     e.target.classList.contains('lines-svg') ||
                                     e.target.classList.contains('dots-svg');
                if (isBackground) {
                    finishEditing();
                    clearSelection();
                }
            });
        }

        // ========================================
        // Initialization
        // ========================================

        function init() {
            // åˆæœŸçŠ¶æ…‹ã‚’å±¥æ­´ã«ä¿å­˜
            saveState();
            
            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆ
            document.addEventListener('keydown', handleKeyDown);
            
            // ãƒ‘ãƒ³ãƒ»ã‚ºãƒ¼ãƒ åˆæœŸåŒ–
            initPanZoom();
            
            // åˆæœŸæç”»
            resetView();
            render();
            
            // ãƒ«ãƒ¼ãƒˆãƒãƒ¼ãƒ‰ã‚’é¸æŠ
            selectNode('root');
        }

        // DOMèª­ã¿è¾¼ã¿å®Œäº†å¾Œã«åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
