<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó</title>
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAJsklEQVR4nO2Ye3AV1R3HP+fs7r1JIAnFEAgUaUdAU0CkoKiodUapdsRHVdRaKIjFVtqK1YqObX3805kKOGLro3YUcNqOjkCphZbpVEe0KmAdQRgpAmJFJUiAhOSS3MeeX/84Z3dv+iDBoP7R/c7c2b1zXr/n9/c7CylSpEiRIkWKFClSpEiRIkWKFP9nUJ/0AVs2b5JtW7fStGcPYgz1gwZxYuNJjD1l/Cd+dk/wiQjR0tIiDyy4j+W/X8H7+1uhoobKfv1RStF5qIVS2wEG1/bl0kunMPfWeTQ0DP7MjOEf6w2XLXtGxo4eRbH/55kwdS5TJp1H7XED0ZkMSinCYoG2A/t4e8OLPPn0r3li6RiWLlksM2Ze95kY4ZgeunD+fXLr7Xdyxb0PcfaVsygWS3S0t2NMEUQQQGuN1j6ZPn3wMwFvrlnO0ttmcvvNc/j5/Ps/dSMcswOXLlksM2bNZu5vn2fI2DNob96LVgq0tooLKGWPFBHEhIhAdV09TTu2sPCqs1j4s3u45dZ5n6oRjslh7+3eLScMO56p83/DqRddw8E976MyGfAUGiAExFlAAZIcXCzm6VffwPb1z/PodReybds/GDhoEL9buoRXX3mZPU1NZLMZGk9q5IKLLmLyV792TA10TDb79szp8tfte/nBE3+mtelDvCBAEEQr63kDAqDEHioKAUSJ5YVCger6wSy/50Y+XLsSv09fWr1qho2bxMBhXyDf2cm7m19n76Z1nDJiGA8+8gjjvzzhmMjeaxLcv79ZRgwfztWLllHM5dBKIyIorVAGEKsoSoEoGwmQmN6Ap30Kba2ce93NLP9gN2dMncUp51+KQeNMh1KKjoP7WP3Izzh94umsWvVHmTLl4l4bodcG+NvaFyhWfo6hjeMp5HIoz+Y8pus8ERsAShTixLYGEpTSlAp5KmvruOHhFYSlkEP7mwFLnMqljAoCrrr7Fww98WQuv+zrbNr0howdO65XRui1AV7bsJ76ExrJVPUhfziH1h4A4nJeuZy3GoBo3LgLAg0GQaEgDMkdPADakqdCoUgixpiQgx/s5pxps9n55mvcMGtmb8VH93aD5uZmauob0FpjlPWYpX2rrCinv9NYRCwJihtTuPKgEBT4nv2pyP9leyiN9n32N+3jgjl3snnnbjasf0V6I//HNsA77+yQNatXyeaNG5FSAYMN78jbkVRKrEGEKA3KBiEekMhAUZVwFUNiCV0saJsudQ1DaRh9GiuXP/NxVQA+RgqsWP6MLLp/IRPPOAtTUU1ldS2nj5tIvrMDpTTOzTbijVivKuVcLrHyYpsCaxD7gihXNqNpZWWznEy1I9T+w0by9rbtn54Bpn3japk++3uMn3oD0+ddwXFDjkd8HykZirl2lBcleOJl0S7Xbd1LnC82VKRLyDiDQZcqYbtIFc8TFPlSibqGwax+8GFOGz9ORjc2cu2MGZw/+YKjIsUeTz737EmyqamNW5b8icr+gzh8qJWwVLCaGYXSytb1SJmo3GkQ5+WYELGcILEETgzHCwqXCiZ6t9GRGFJQvkc+18reHVs58FET29evZdfLa7jwnDP51eNPMKBuQI9069Gkud+fI4v/8BfuePZ1SsUSpfxhtPaJPRflLk5yl/hKKcRYUpeI1ES54STnozSQyEjxsN3LxFkSH4ISQfsBfkUFyvfwgoCOfXtYfNv16A/eYv3rGxlQV9etft1O2Lr1LWkcNZqbnn6VwcNHkWtrwfN9t9i6NCKuJL+dkF3YMJbddcWS8IDrFJWOKka0QOKo+vf+KdnLxIfrbAVVtf14bPYlHK9aeW7ty93q120VWLRgPiO/MoWhY04ld+igbXMF1+gIaFutMUnUI2K9FckGyRqJ+DxRPtIsapasYknbjEmaIRdbiLiyqTVKe2jtE+bzdLS08K35i3lu3UZWrljWbYns1gAvvvQSY86/DIoFe7MTsUJG+kUljLicU14Hxf1XXXxnx1VkRBVTXCJVWR8QLUleBKUEtMT7CuB5PqV8nmxtHWd/cw4PPbioO/WObIB9+z6SA+05GkZ+ic5CJ9q1uVIezpEHdSJkRGKio5x2E+PGh/hddGS5xGAREUZVwpKgSyoXQeJCIjaSe1daYTo6GDnpPN7avrN3Bsi1tZEvGSr7ViPGxCQVdXjg+nqtyjxfxvhO90QxSUgunmPXlBeDxPFRD+EixuVI7AAT/ZeEgpSiUMzTb+BgOkPh3V07j5gGRzRA35oaAq3Itbbi4dk8j2W0DK2USvLb1WyiRxkvxIQY84J06QyT/sBaS6IbVTkvKIk7w5g7yngn+q+UwoQhGkWQyRxJxSMboK5ugDquug/NO7cSZLKIGBuCXcjNWE9El4C49ycO10ippIxZxeNySERs0VikdaJ8jC4NVRJO0V5iDEGmgqZd26nO+gwZMvSIlaBbEpw8eTIbVj2FzviISVylEHeLKxMw6Wpd307XXCjL/66cmOyjkjpoy18Zb9hqY+todFeIL1JuXCQkqKzkzTXLOOvMid2p130fsGPHdhkxYgQ3Pvkcw04+k/aWZlQmiBXtskkcjirOVSVlYzruf4ibh8gFRiVhI112tYQX3THEcVBkIDekRDClIn3r6tn1xjoenXYuW7ZsZvToMb2LgOHDR6h77vopj990LZ3tB6io6YcUC2BMXJv/w4y6rGhHykeXIVxnF7G4iPWq5Xt7X5KovBrEEYkYgzEhRkL7NCFhqYSYEiIhoqC6voH2Pe/x2Hcu4967f9yt8v9N9P+Jq6+8XFa+sI65jz/L4Mbx5NrbKOU7LQeIYIzEHy8iho8/Zzgmj5sZT3dthqJqHjF+NF/bpycKtId4Gq01nlJ4KinJAhRzh1j37FOsnn87P/zu9Sy4/4Ee6dZjAwDcMe9H8stHH+OL51zChIuvYeiJowj6VOP7GXw/AHcbjLwqJsQY47xnn/ZzuEFEMGGIMYIxoZtTwpRCwrBIGJYIC3lK+QLFjsN0dh6m0JGj83A7nW1t5NtbKRxuJ9fWwqF9e2n959sMqvL4yV13MW36jB7rdVQGAFi/fp0sWnAfr274O4cKISaowMtUElRWov0AQYMYTKlIqZBHwiISGiQsubAOSb4LOEJzTxGDRuK2wtcevqcJAo9sJkM2CKiqrKCqqoqqqiqqq/tSW1PLwIEDmTDxNKZccvlR63PUC8qxedMbsndvE60tLbS1tdHZ0UEYGnzfI5PNks1myWYryGQzZDNZ/MDH9wN838fzPDzfw/d8vOi/5+EHAUFg52QzWYJslprqml7JmSJFihQpUqRIkSJFihQpUqRIkaIM/wItfqmNOho25QAAAABJRU5ErkJggg==" />
    <style>
        /* ========================================
           CSS Variables & Reset
           ======================================== */
        :root {
            --primary-color: #4a90d9;
            --primary-hover: #357abd;
            --bg-color: #f5f7fa;
            --node-bg: #ffffff;
            --node-border: #4a90d9;
            --node-selected: #e3f2fd;
            --text-color: #333333;
            --line-color: #999999;
            --shadow: 0 2px 8px rgba(0,0,0,0.1);
            --font-family: 'Meiryo UI', '„É°„Ç§„É™„Ç™', Meiryo, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            font-family: var(--font-family);
            background: var(--bg-color);
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        /* ========================================
           Canvas Container (Full Screen - No Toolbar)
           ======================================== */
        .canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            background: var(--bg-color);
            background-image:
                radial-gradient(circle, #ddd 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            cursor: default;
        }

        .canvas.panning {
            cursor: grabbing;
        }

        .canvas-inner {
            position: absolute;
            transform-origin: 0 0;
        }

        /* ========================================
           SVG Lines
           ======================================== */
        .lines-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 10000px;
            height: 10000px;
            overflow: visible;
            transform: translate(-5000px, -5000px);
            pointer-events: none;
        }

        .connection-line {
            fill: none;
            stroke: var(--line-color);
            stroke-width: 2;
            stroke-linecap: round;
            pointer-events: none;
        }

        /* ========================================
           Node Styles
           ======================================== */
        .node {
            position: absolute;
            min-width: 120px;
            padding: 10px 16px;
            background: var(--node-bg);
            border: 2px solid var(--node-border);
            border-radius: 8px;
            box-shadow: var(--shadow);
            cursor: pointer;
            user-select: none;
            transition: box-shadow 0.2s;
            white-space: nowrap;
            box-sizing: border-box;
            overflow: visible;
        }

        .node:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .node.selected {
            background: var(--node-selected);
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(74, 144, 217, 0.3);
        }

        .node.root {
            font-size: 16px;
            font-weight: bold;
            border-width: 3px;
        }

        .node.editing {
            cursor: text;
        }

        .node.dragging {
            opacity: 0.4;
            z-index: 1000;
        }

        .node.drag-over-child {
            box-shadow: 0 0 0 4px rgba(76, 175, 80, 0.5);
            border-color: #4caf50;
        }

        .node.drag-over-before {
            border-top: 4px solid #2196f3;
        }

        .node.drag-over-after {
            border-bottom: 4px solid #2196f3;
        }

        .node-text {
            outline: none;
            min-width: 50px;
            display: block;
            white-space: pre;
        }

        .node-text[contenteditable="true"] {
            cursor: text;
            background: rgba(255,255,255,0.8);
            padding: 2px 4px;
            margin: -2px -4px;
            border-radius: 3px;
        }

        /* ========================================
           Collapse/Expand Indicator
           ======================================== */
        .collapse-toggle {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #e8eef5;
            border: 1px solid #c0d0e0;
            color: #4a90d9;
            font-size: 10px;
            cursor: pointer;
            position: absolute;
            right: -10px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
            transition: background 0.2s;
            user-select: none;
            line-height: 1;
        }

        .collapse-toggle:hover {
            background: #d0dff0;
        }

        .collapse-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 18px;
            height: 18px;
            border-radius: 9px;
            background: #ff9800;
            color: white;
            font-size: 10px;
            font-weight: bold;
            padding: 0 4px;
            position: absolute;
            right: -12px;
            top: -8px;
            z-index: 10;
            pointer-events: none;
            user-select: none;
        }

        /* ========================================
           Drag Ghost
           ======================================== */
        .drag-ghost {
            position: fixed;
            pointer-events: none;
            z-index: 2000;
            opacity: 0.8;
            transform: rotate(2deg);
            box-shadow: 0 8px 24px rgba(0,0,0,0.2);
        }

        /* ========================================
           Lasso Selection Rectangle
           ======================================== */
        .lasso-rect {
            position: fixed;
            border: 2px dashed var(--primary-color);
            background: rgba(74, 144, 217, 0.08);
            pointer-events: none;
            z-index: 900;
            display: none;
        }

        /* ========================================
           Copy Button (Floating, Bottom-Right)
           ======================================== */
        .copy-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 8px;
            z-index: 500;
            background: #ffffff;
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            border: 1px solid #e0e0e0;
            min-width: 160px;
        }

        .copy-panel select {
            font-family: var(--font-family);
            font-size: 13px;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #f9f9f9;
            color: var(--text-color);
            cursor: pointer;
            outline: none;
            transition: border-color 0.2s;
            width: 100%;
        }

        .copy-panel select:focus {
            border-color: var(--primary-color);
        }

        .copy-btn, .preview-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            background: var(--primary-color);
            color: white;
            font-family: var(--font-family);
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            white-space: nowrap;
            width: 100%;
        }

        .preview-btn {
            background: #6c757d;
        }

        .preview-btn:hover {
            background: #5a6268;
        }

        .copy-btn:hover {
            background: var(--primary-hover);
        }

        .copy-btn:active, .preview-btn:active, .reset-btn:active {
            transform: scale(0.97);
        }

        .reset-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            background: #e53935;
            color: white;
            font-family: var(--font-family);
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
            white-space: nowrap;
            width: 100%;
        }

        .reset-btn:hover {
            background: #c62828;
        }

        /* ========================================
           Map ID Badge
           ======================================== */
        .map-id-badge {
            position: fixed;
            top: 8px;
            right: 12px;
            font-size: 12px;
            color: #999;
            z-index: 500;
            pointer-events: none;
            user-select: none;
        }

        /* ========================================
           Preview Modal
           ======================================== */
        .preview-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .preview-overlay.show {
            display: flex;
        }

        .preview-modal {
            background: #ffffff;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            width: 90%;
            max-width: 680px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .preview-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px 20px;
            border-bottom: 1px solid #e0e0e0;
            background: #f8f9fa;
        }

        .preview-header h3 {
            font-size: 15px;
            color: var(--text-color);
            font-family: var(--font-family);
        }

        .preview-header-btns {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .preview-copy-btn {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 6px 14px;
            border: none;
            border-radius: 6px;
            background: var(--primary-color);
            color: white;
            font-family: var(--font-family);
            font-size: 13px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        .preview-copy-btn:hover {
            background: var(--primary-hover);
        }

        .preview-close-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            background: transparent;
            color: #666;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .preview-close-btn:hover {
            background: #e0e0e0;
        }

        .preview-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .preview-body pre {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.7;
            color: var(--text-color);
            background: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 8px;
            padding: 16px 20px;
            white-space: pre;
            overflow-x: auto;
            margin: 0;
        }

        /* ========================================
           Toast Notification
           ======================================== */
        .toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            background: #333;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 3000;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
    </style>
</head>
<body>

    <!-- Map ID Badge -->
    <div class="map-id-badge" id="mapIdBadge"></div>

    <!-- Canvas Container (Full Screen) -->
    <div class="canvas-container" id="canvasContainer">
        <div class="canvas" id="canvas">
            <div class="canvas-inner" id="canvasInner">
                <svg class="lines-svg" id="linesSvg"></svg>
            </div>
        </div>
    </div>

    <!-- Copy Panel (Floating Bottom-Right) -->
    <div class="copy-panel" id="copyPanel">
        <select id="copyFormat" title="Âá∫ÂäõÂΩ¢Âºè">
            <option value="simple">„Ç∑„É≥„Éó„É´</option>
            <option value="hiyoko">„Å≤„Çà„Åì„É¢„Éº„Éâ üê•</option>
            <option value="family">„Åã„Åû„Åè„É¢„Éº„Éâ üë∂</option>
        </select>
        <select id="copyBorder" title="ÁΩ´Á∑ö">
            <option value="none">ÁΩ´Á∑ö„Å™„Åó</option>
            <option value="border" selected>ÁΩ´Á∑ö„ÅÇ„Çä</option>
        </select>
        <button class="preview-btn" id="previewBtn" title="„Éó„É¨„Éì„É•„Éº">
            üëÅ „Éó„É¨„Éì„É•„Éº
        </button>
        <button class="copy-btn" id="copyBtn" title="„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº">
            üìã „Ç≥„Éî„Éº
        </button>
        <button class="reset-btn" id="resetBtn" title="„Éû„ÉÉ„Éó„Çí„É™„Çª„ÉÉ„Éà">
            üóë „É™„Çª„ÉÉ„Éà
        </button>
    </div>

    <!-- Preview Modal -->
    <div class="preview-overlay" id="previewOverlay">
        <div class="preview-modal">
            <div class="preview-header">
                <h3>üìÑ „Ç≥„Éî„ÉºÂÜÖÂÆπ„Éó„É¨„Éì„É•„Éº</h3>
                <div class="preview-header-btns">
                    <button class="preview-copy-btn" id="previewCopyBtn">üìã „Ç≥„Éî„Éº</button>
                    <button class="preview-close-btn" id="previewCloseBtn">&times;</button>
                </div>
            </div>
            <div class="preview-body">
                <pre id="previewContent"></pre>
            </div>
        </div>
    </div>

    <!-- Lasso Selection Rectangle -->
    <div class="lasso-rect" id="lassoRect"></div>

    <!-- Toast -->
    <div class="toast" id="toast"></div>

    <script>
    (function() {
        'use strict';

        // ========================================
        // Global State
        // ========================================

        const levelIcons = {
            hiyoko: { 1: 'üêî', 2: 'üê§', 3: 'üê£', 4: 'ü•ö' },
            family: { 1: 'üë¥', 2: 'üë®', 3: 'üë¶', 4: 'üë∂' }
        };

        let mindMapData = {
            root: {
                id: 'root',
                text: '‰∏≠ÂøÉ„ÉÜ„Éº„Éû',
                children: []
            }
        };

        let selectedNodeIds = new Set();
        let lastSelectedNodeId = null;
        let editingNodeId = null;

        let viewState = {
            zoom: 1,
            panX: 0,
            panY: 0,
            isPanning: false,
            startX: 0,
            startY: 0
        };

        let undoHistory = [];
        let undoIndex = -1;
        const MAX_HISTORY = 50;

        let clipboard = null;
        let clipboardIsCut = false;

        let collapsedNodeIds = new Set();

        let nodeIdCounter = 0;

        // Drag reparenting state
        let nodeDragState = {
            isDragging: false,
            didDrag: false,     // true if actual drag occurred (to suppress click)
            nodeId: null,
            draggedNodeIds: null,
            targetNodeId: null,
            targetPosition: null
        };

        // Lasso selection state
        let lassoState = {
            active: false,
            didSelect: false,   // true if lasso selected nodes (to suppress click clear)
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0
        };

        // ========================================
        // Utility Functions
        // ========================================

        function generateId() {
            return 'node_' + (++nodeIdCounter) + '_' + Date.now();
        }

        function deepClone(obj) {
            return JSON.parse(JSON.stringify(obj));
        }

        function showToast(message, duration) {
            duration = duration || 2000;
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');
            clearTimeout(toast._tid);
            toast._tid = setTimeout(function() {
                toast.classList.remove('show');
            }, duration);
        }

        // ========================================
        // History Management (Undo/Redo)
        // ========================================

        // ---- Map ID from URL parameter ----
        function getMapId() {
            var params = new URLSearchParams(window.location.search);
            return params.get('id') || 'default';
        }
        const MAP_ID = getMapId();
        const STORAGE_KEY = 'mindmap_data_v2_' + MAP_ID;

        function saveState() {
            undoHistory = undoHistory.slice(0, undoIndex + 1);
            undoHistory.push(deepClone(mindMapData));
            if (undoHistory.length > MAX_HISTORY) {
                undoHistory.shift();
            } else {
                undoIndex++;
            }
            // Note: localStorage save is handled in render() to capture post-mutation state
        }

        function saveToLocalStorage() {
            try {
                var dataToSave = {
                    mindMap: mindMapData,
                    collapsed: Array.from(collapsedNodeIds)
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(dataToSave));
            } catch(e) { /* quota exceeded or private mode */ }
        }

        function loadFromLocalStorage() {
            try {
                var data = localStorage.getItem(STORAGE_KEY);
                if (data) {
                    var parsed = JSON.parse(data);
                    // New format: { mindMap: {...}, collapsed: [...] }
                    if (parsed && parsed.mindMap && parsed.mindMap.root && parsed.mindMap.root.id === 'root') {
                        if (parsed.collapsed && Array.isArray(parsed.collapsed)) {
                            collapsedNodeIds = new Set(parsed.collapsed);
                        }
                        return parsed.mindMap;
                    }
                    // Old format: direct mindMapData
                    if (parsed && parsed.root && parsed.root.id === 'root') {
                        return parsed;
                    }
                }
                // Migration: if accessing as 'default' and no data under new key,
                // try the legacy key (mindmap_data_v2) and migrate it
                if (MAP_ID === 'default') {
                    var legacyKey = 'mindmap_data_v2';
                    var legacyData = localStorage.getItem(legacyKey);
                    if (legacyData) {
                        var legacyParsed = JSON.parse(legacyData);
                        if (legacyParsed && legacyParsed.root && legacyParsed.root.id === 'root') {
                            // Migrate: save under new key and remove legacy key
                            localStorage.setItem(STORAGE_KEY, legacyData);
                            localStorage.removeItem(legacyKey);
                            return legacyParsed;
                        }
                    }
                }
            } catch(e) { /* invalid data */ }
            return null;
        }

        function resetMindMap() {
            if (!confirm('„Éû„Ç§„É≥„Éâ„Éû„ÉÉ„Éó„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åô„ÅãÔºü\n„Åô„Åπ„Å¶„ÅÆ„Éé„Éº„Éâ„ÅåÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ')) return;
            mindMapData = {
                root: { id: 'root', text: '‰∏≠ÂøÉ„ÉÜ„Éº„Éû', children: [] }
            };
            undoHistory = [];
            undoIndex = -1;
            selectedNodeIds.clear();
            lastSelectedNodeId = null;
            editingNodeId = null;
            clipboard = null;
            clipboardIsCut = false;
            collapsedNodeIds.clear();
            try { localStorage.removeItem(STORAGE_KEY); } catch(e) {}
            saveState();
            render();
            resetView();
            selectNode('root');
            setTimeout(function() { startEditing('root'); }, 100);
            showToast('üóë „É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü');
        }

        function undo() {
            if (undoIndex > 0) {
                undoIndex--;
                mindMapData = deepClone(undoHistory[undoIndex]);
                render();
                showToast('ÂÖÉ„Å´Êàª„Åó„Åæ„Åó„Åü');
            }
        }

        function redo() {
            if (undoIndex < undoHistory.length - 1) {
                undoIndex++;
                mindMapData = deepClone(undoHistory[undoIndex]);
                render();
                showToast('„ÇÑ„ÇäÁõ¥„Åó„Åæ„Åó„Åü');
            }
        }

        // ========================================
        // Node Operations
        // ========================================

        function findNode(id, node, parent, index) {
            if (node === undefined) node = mindMapData.root;
            if (parent === undefined) parent = null;
            if (index === undefined) index = 0;
            if (node.id === id) return { node: node, parent: parent, index: index };
            for (var i = 0; i < node.children.length; i++) {
                var result = findNode(id, node.children[i], node, i);
                if (result) return result;
            }
            return null;
        }

        function getNodeLevel(id, node, level) {
            if (node === undefined) node = mindMapData.root;
            if (level === undefined) level = 1;
            if (node.id === id) return level;
            for (var i = 0; i < node.children.length; i++) {
                var result = getNodeLevel(id, node.children[i], level + 1);
                if (result) return result;
            }
            return null;
        }

        function getAllNodesInOrder(node, result) {
            if (node === undefined) node = mindMapData.root;
            if (result === undefined) result = [];
            result.push(node);
            for (var i = 0; i < node.children.length; i++) {
                getAllNodesInOrder(node.children[i], result);
            }
            return result;
        }

        function addChildNode(parentId, text, autoEdit) {
            if (text === undefined) text = 'Êñ∞„Åó„ÅÑ„Éé„Éº„Éâ';
            if (autoEdit === undefined) autoEdit = true;
            var result = findNode(parentId);
            if (!result) return null;
            saveState();
            var newNode = { id: generateId(), text: text, children: [] };
            result.node.children.push(newNode);
            render();
            selectNode(newNode.id);
            if (autoEdit) {
                setTimeout(function() { startEditing(newNode.id); }, 50);
            }
            return newNode;
        }

        function addSiblingNode(nodeId, text, autoEdit) {
            if (text === undefined) text = 'Êñ∞„Åó„ÅÑ„Éé„Éº„Éâ';
            if (autoEdit === undefined) autoEdit = true;
            var result = findNode(nodeId);
            if (!result || !result.parent) {
                return addChildNode(nodeId, text, autoEdit);
            }
            saveState();
            var newNode = { id: generateId(), text: text, children: [] };
            result.parent.children.splice(result.index + 1, 0, newNode);
            render();
            selectNode(newNode.id);
            if (autoEdit) {
                setTimeout(function() { startEditing(newNode.id); }, 50);
            }
            return newNode;
        }

        function deleteNode(nodeId) {
            if (nodeId === 'root') {
                showToast('„É´„Éº„Éà„Éé„Éº„Éâ„ÅØÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì');
                return false;
            }
            var result = findNode(nodeId);
            if (!result || !result.parent) return false;
            saveState();
            result.parent.children.splice(result.index, 1);
            if (result.parent.children.length > 0) {
                var idx = Math.min(result.index, result.parent.children.length - 1);
                selectNode(result.parent.children[idx].id);
            } else {
                selectNode(result.parent.id);
            }
            render();
            return true;
        }

        function deleteSelectedNodes() {
            if (selectedNodeIds.size === 0) return;
            var ids = [];
            selectedNodeIds.forEach(function(id) { if (id !== 'root') ids.push(id); });
            if (ids.length === 0) {
                showToast('„É´„Éº„Éà„Éé„Éº„Éâ„ÅØÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì');
                return;
            }
            var filtered = filterTopLevelNodes(ids);
            saveState();
            var lastParent = null;
            for (var i = 0; i < filtered.length; i++) {
                var r = findNode(filtered[i]);
                if (r && r.parent) {
                    lastParent = r.parent;
                    r.parent.children.splice(r.index, 1);
                }
            }
            selectedNodeIds.clear();
            if (lastParent && lastParent.children.length > 0) {
                selectNode(lastParent.children[0].id);
            } else if (lastParent) {
                selectNode(lastParent.id);
            } else {
                selectNode('root');
            }
            render();
            showToast(filtered.length + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
        }

        function updateNodeText(nodeId, newText) {
            var result = findNode(nodeId);
            if (result && result.node.text !== newText) {
                saveState();
                result.node.text = newText;
            }
        }

        function moveNodeUp(nodeId) {
            var result = findNode(nodeId);
            if (result && result.parent && result.index > 0) {
                saveState();
                var s = result.parent.children;
                var tmp = s[result.index - 1];
                s[result.index - 1] = s[result.index];
                s[result.index] = tmp;
                render();
            }
        }

        function moveNodeDown(nodeId) {
            var result = findNode(nodeId);
            if (result && result.parent && result.index < result.parent.children.length - 1) {
                saveState();
                var s = result.parent.children;
                var tmp = s[result.index];
                s[result.index] = s[result.index + 1];
                s[result.index + 1] = tmp;
                render();
            }
        }

        function promoteNode(nodeId) {
            var result = findNode(nodeId);
            if (!result || !result.parent || result.parent.id === 'root') return;
            var gpResult = findNode(result.parent.id);
            if (gpResult && gpResult.parent) {
                saveState();
                result.parent.children.splice(result.index, 1);
                gpResult.parent.children.splice(gpResult.index + 1, 0, result.node);
                render();
                selectNode(nodeId);
            }
        }

        function demoteNode(nodeId) {
            var result = findNode(nodeId);
            if (!result || !result.parent || result.index === 0) return;
            saveState();
            var prevSibling = result.parent.children[result.index - 1];
            result.parent.children.splice(result.index, 1);
            prevSibling.children.push(result.node);
            render();
            selectNode(nodeId);
        }

        // ========================================
        // Selection & Navigation
        // ========================================

        function selectNode(nodeId) {
            clearSelection();
            if (nodeId) {
                selectedNodeIds.add(nodeId);
                lastSelectedNodeId = nodeId;
                updateSelectionDisplay();
                scrollNodeIntoView(nodeId);
            }
        }

        function clearSelection() {
            selectedNodeIds.clear();
            lastSelectedNodeId = null;
            document.querySelectorAll('.node.selected').forEach(function(el) {
                el.classList.remove('selected');
            });
        }

        function updateSelectionDisplay() {
            document.querySelectorAll('.node').forEach(function(el) {
                el.classList.toggle('selected', selectedNodeIds.has(el.dataset.id));
            });
        }

        function toggleSelectNode(nodeId) {
            if (selectedNodeIds.has(nodeId)) {
                selectedNodeIds.delete(nodeId);
            } else {
                selectedNodeIds.add(nodeId);
            }
            lastSelectedNodeId = nodeId;
            updateSelectionDisplay();
        }

        function rangeSelectNode(nodeId) {
            if (!lastSelectedNodeId) { selectNode(nodeId); return; }
            var allNodes = getAllNodesInOrder();
            var si = -1, ei = -1;
            for (var i = 0; i < allNodes.length; i++) {
                if (allNodes[i].id === lastSelectedNodeId) si = i;
                if (allNodes[i].id === nodeId) ei = i;
            }
            if (si === -1 || ei === -1) { selectNode(nodeId); return; }
            var mn = Math.min(si, ei), mx = Math.max(si, ei);
            clearSelection();
            for (var i = mn; i <= mx; i++) {
                selectedNodeIds.add(allNodes[i].id);
            }
            lastSelectedNodeId = nodeId;
            updateSelectionDisplay();
        }

        function getSelectedNodeId() {
            if (selectedNodeIds.size === 0) return null;
            return lastSelectedNodeId || selectedNodeIds.values().next().value;
        }

        function getSelectedNodes() {
            var nodes = [];
            selectedNodeIds.forEach(function(id) {
                var r = findNode(id);
                if (r) nodes.push(r.node);
            });
            return nodes;
        }

        // Collect all visible nodes at a given depth level in visual (layout) order
        function getNodesAtLevel(targetLevel, node, currentLevel) {
            if (node === undefined) node = mindMapData.root;
            if (currentLevel === undefined) currentLevel = 1;
            var result = [];
            if (currentLevel === targetLevel) {
                result.push(node);
                return result;
            }
            // If this node is collapsed, its children are hidden ‚Äî skip them for navigation
            if (collapsedNodeIds.has(node.id)) return result;
            for (var i = 0; i < node.children.length; i++) {
                var childResults = getNodesAtLevel(targetLevel, node.children[i], currentLevel + 1);
                for (var j = 0; j < childResults.length; j++) {
                    result.push(childResults[j]);
                }
            }
            return result;
        }

        // Navigate UP: cross-parent navigation at same depth
        function navigateUp() {
            var cid = getSelectedNodeId();
            if (!cid) { selectNode('root'); return; }
            var level = getNodeLevel(cid);
            if (!level || level <= 1) return; // root has no siblings
            var nodesAtLevel = getNodesAtLevel(level);
            var idx = -1;
            for (var i = 0; i < nodesAtLevel.length; i++) {
                if (nodesAtLevel[i].id === cid) { idx = i; break; }
            }
            if (idx > 0) {
                selectNode(nodesAtLevel[idx - 1].id);
            }
        }

        // Navigate DOWN: cross-parent navigation at same depth
        function navigateDown() {
            var cid = getSelectedNodeId();
            if (!cid) { selectNode('root'); return; }
            var level = getNodeLevel(cid);
            if (!level || level <= 1) return; // root has no siblings
            var nodesAtLevel = getNodesAtLevel(level);
            var idx = -1;
            for (var i = 0; i < nodesAtLevel.length; i++) {
                if (nodesAtLevel[i].id === cid) { idx = i; break; }
            }
            if (idx >= 0 && idx < nodesAtLevel.length - 1) {
                selectNode(nodesAtLevel[idx + 1].id);
            }
        }

        // Navigate LEFT: collapse if expanded with children, else go to parent
        function navigateLeft() {
            var cid = getSelectedNodeId();
            if (!cid) { selectNode('root'); return; }
            var r = findNode(cid);
            if (r && r.node.children.length > 0 && !collapsedNodeIds.has(cid)) {
                toggleCollapse(cid);
            } else if (r && r.parent) {
                selectNode(r.parent.id);
            }
        }

        // Navigate RIGHT: go to first child (or expand if collapsed)
        function navigateRight() {
            var cid = getSelectedNodeId();
            if (!cid) { selectNode('root'); return; }
            var r = findNode(cid);
            if (r && r.node.children.length > 0) {
                if (collapsedNodeIds.has(cid)) {
                    toggleCollapse(cid);
                } else {
                    selectNode(r.node.children[0].id);
                }
            }
        }

        function goToParent() {
            var cid = getSelectedNodeId();
            if (!cid || cid === 'root') return;
            var r = findNode(cid);
            if (r && r.parent) selectNode(r.parent.id);
        }

        // Collapse/Expand functionality
        function toggleCollapse(nodeId) {
            if (!nodeId || nodeId === 'root') {
                // Allow collapsing root too if it has children
                var r = findNode(nodeId || 'root');
                if (!r || r.node.children.length === 0) return;
            }
            var r = findNode(nodeId);
            if (!r || r.node.children.length === 0) return;
            if (collapsedNodeIds.has(nodeId)) {
                collapsedNodeIds.delete(nodeId);
            } else {
                collapsedNodeIds.add(nodeId);
            }
            render();
            selectNode(nodeId);
        }

        function countDescendants(node) {
            var count = 0;
            for (var i = 0; i < node.children.length; i++) {
                count++;
                count += countDescendants(node.children[i]);
            }
            return count;
        }

        function scrollNodeIntoView(nodeId) {
            var nodeEl = document.querySelector('[data-id="' + nodeId + '"]');
            if (!nodeEl) return;
            var container = document.getElementById('canvasContainer');
            var rect = nodeEl.getBoundingClientRect();
            var cRect = container.getBoundingClientRect();
            var margin = 60;
            var dx = 0, dy = 0;
            if (rect.left < cRect.left + margin) dx = cRect.left + margin - rect.left;
            else if (rect.right > cRect.right - margin) dx = cRect.right - margin - rect.right;
            if (rect.top < cRect.top + margin) dy = cRect.top + margin - rect.top;
            else if (rect.bottom > cRect.bottom - margin - 80) dy = cRect.bottom - margin - 80 - rect.bottom;
            if (dx !== 0 || dy !== 0) {
                viewState.panX += dx;
                viewState.panY += dy;
                updateView();
            }
        }

        // ========================================
        // Edit Mode
        // ========================================

        function startEditing(nodeId) {
            if (editingNodeId === nodeId) return;
            if (editingNodeId) finishEditing();
            editingNodeId = nodeId;
            // Select without clearing other selection state, just ensure this node is selected
            if (!selectedNodeIds.has(nodeId)) {
                selectNode(nodeId);
            }
            var nodeEl = document.querySelector('[data-id="' + nodeId + '"]');
            var textEl = nodeEl ? nodeEl.querySelector('.node-text') : null;
            if (textEl) {
                nodeEl.classList.add('editing');
                // Remove fixed width so node grows/shrinks with text in real-time
                nodeEl.style.width = 'auto';
                textEl.contentEditable = 'true';
                textEl.focus();
                var range = document.createRange();
                range.selectNodeContents(textEl);
                var sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            }
        }

        function finishEditing() {
            if (!editingNodeId) return;
            var prevEditingId = editingNodeId;
            var nodeEl = document.querySelector('[data-id="' + editingNodeId + '"]');
            var textEl = nodeEl ? nodeEl.querySelector('.node-text') : null;
            var textChanged = false;
            if (textEl) {
                // Convert innerHTML <br> tags to \n for storage
                var html = textEl.innerHTML;
                // Replace <br> variants with \n
                var newText = html.replace(/<br\s*\/?>/gi, '\n');
                // Strip any other HTML tags
                var tmp = document.createElement('div');
                tmp.innerHTML = newText;
                newText = tmp.textContent.replace(/\u200B/g, '').trim() || 'Á©∫„ÅÆ„Éé„Éº„Éâ';
                var result = findNode(editingNodeId);
                if (result && result.node.text !== newText) {
                    textChanged = true;
                }
                updateNodeText(editingNodeId, newText);
                textEl.contentEditable = 'false';
                nodeEl.classList.remove('editing');
            }
            editingNodeId = null;
            // Re-render to recalculate layout when text changed
            if (textChanged) {
                render();
                // Re-select the previously edited node
                selectNode(prevEditingId);
            }
        }

        // ========================================
        // Copy, Cut & Paste
        // ========================================

        function copySelectedNodes() {
            if (selectedNodeIds.size === 0) return;
            if (selectedNodeIds.size === 1) {
                var id = getSelectedNodeId();
                var r = findNode(id);
                if (r) {
                    clipboard = deepClone(r.node);
                    clipboardIsCut = false;
                    showToast('„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
                }
            } else {
                var topLevel = filterTopLevelNodes(Array.from(selectedNodeIds));
                var nodes = [];
                for (var i = 0; i < topLevel.length; i++) {
                    var r = findNode(topLevel[i]);
                    if (r) nodes.push(deepClone(r.node));
                }
                if (nodes.length > 0) {
                    clipboard = nodes;
                    clipboardIsCut = false;
                    showToast(nodes.length + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„Çí„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
                }
            }
        }

        function cutSelectedNodes() {
            if (selectedNodeIds.size === 0) return;
            var ids = [];
            selectedNodeIds.forEach(function(id) { if (id !== 'root') ids.push(id); });
            if (ids.length === 0) {
                showToast('„É´„Éº„Éà„Éé„Éº„Éâ„ÅØÂàá„ÇäÂèñ„Çå„Åæ„Åõ„Çì');
                return;
            }
            var topLevel = filterTopLevelNodes(ids);
            var nodes = [];
            for (var i = 0; i < topLevel.length; i++) {
                var r = findNode(topLevel[i]);
                if (r) nodes.push(deepClone(r.node));
            }
            if (nodes.length === 0) return;
            clipboard = nodes.length === 1 ? nodes[0] : nodes;
            clipboardIsCut = true;

            saveState();
            var lastParent = null;
            for (var i = 0; i < topLevel.length; i++) {
                var r = findNode(topLevel[i]);
                if (r && r.parent) {
                    lastParent = r.parent;
                    r.parent.children.splice(r.index, 1);
                }
            }
            selectedNodeIds.clear();
            if (lastParent && lastParent.children.length > 0) {
                selectNode(lastParent.children[0].id);
            } else if (lastParent) {
                selectNode(lastParent.id);
            } else {
                selectNode('root');
            }
            render();
            showToast(topLevel.length + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„ÇíÂàá„ÇäÂèñ„Çä„Åæ„Åó„Åü');
        }

        function pasteNode() {
            var cid = getSelectedNodeId();
            if (!clipboard || !cid) return;
            var r = findNode(cid);
            if (!r) return;
            saveState();
            function reassignIds(node) {
                node.id = generateId();
                if (node.children) {
                    for (var i = 0; i < node.children.length; i++) reassignIds(node.children[i]);
                }
            }
            if (Array.isArray(clipboard)) {
                for (var i = 0; i < clipboard.length; i++) {
                    var cloned = deepClone(clipboard[i]);
                    reassignIds(cloned);
                    r.node.children.push(cloned);
                }
                render();
                showToast(clipboard.length + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„Çí„Éö„Éº„Çπ„Éà„Åó„Åæ„Åó„Åü');
            } else {
                var cloned = deepClone(clipboard);
                reassignIds(cloned);
                r.node.children.push(cloned);
                render();
                selectNode(cloned.id);
                showToast('„Éö„Éº„Çπ„Éà„Åó„Åæ„Åó„Åü');
            }
            if (clipboardIsCut) {
                clipboard = null;
                clipboardIsCut = false;
            }
        }

        function selectAll() {
            var allNodes = getAllNodesInOrder();
            if (selectedNodeIds.size === allNodes.length) {
                clearSelection();
            } else {
                finishEditing();
                selectedNodeIds.clear();
                for (var i = 0; i < allNodes.length; i++) {
                    selectedNodeIds.add(allNodes[i].id);
                }
                lastSelectedNodeId = allNodes[0] ? allNodes[0].id : null;
                updateSelectionDisplay();
            }
        }

        function filterTopLevelNodes(nodeIds) {
            var result = [];
            for (var i = 0; i < nodeIds.length; i++) {
                var nid = nodeIds[i];
                if (nid === 'root') continue;
                var hasAncestor = false;
                for (var j = 0; j < nodeIds.length; j++) {
                    if (nodeIds[j] !== nid && isDescendant(nodeIds[j], nid)) {
                        hasAncestor = true;
                        break;
                    }
                }
                if (!hasAncestor) result.push(nid);
            }
            return result;
        }

        function isDescendant(ancestorId, nodeId) {
            var r = findNode(ancestorId);
            if (!r) return false;
            function check(node) {
                for (var i = 0; i < node.children.length; i++) {
                    if (node.children[i].id === nodeId) return true;
                    if (check(node.children[i])) return true;
                }
                return false;
            }
            return check(r.node);
        }

        // ========================================
        // Copy to Clipboard (Floating Button)
        // ========================================

        function getCurrentCopyText() {
            var format = document.getElementById('copyFormat').value;
            var border = document.getElementById('copyBorder').value;
            var useBorder = (border === 'border');
            return generateCopyText(mindMapData.root, 0, [], format, useBorder);
        }

        function copyToClipboard() {
            var text = getCurrentCopyText();

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(function() {
                    showToast('‚úÖ „Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
                }).catch(function() {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            var ta = document.createElement('textarea');
            ta.value = text;
            ta.style.cssText = 'position:fixed;opacity:0;left:-9999px;';
            document.body.appendChild(ta);
            ta.select();
            try { document.execCommand('copy'); } catch(e) {}
            document.body.removeChild(ta);
            showToast('‚úÖ „Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
        }

        function showPreview() {
            var text = getCurrentCopyText();
            document.getElementById('previewContent').textContent = text;
            document.getElementById('previewOverlay').classList.add('show');
        }

        function hidePreview() {
            document.getElementById('previewOverlay').classList.remove('show');
        }

        function generateCopyText(node, level, parentContinues, format, useBorder) {
            var result = '';
            var iconLevel = Math.min(level + 1, 4);
            var icons = levelIcons[format];
            var icon = icons ? (icons[iconLevel] + ' ') : '';

            // ---- Root (level 0) ----
            if (level === 0) {
                result = icon + node.text + '\n';
            } else {
                // Build the prefix from ancestor continuation info
                var prefix = '';
                for (var i = 0; i < level - 1; i++) {
                    if (useBorder) {
                        prefix += parentContinues[i] ? '‚îÇ  ' : '   ';
                    } else {
                        prefix += '  ';
                    }
                }
                // Connector for this node
                var isLast = (parentContinues[level - 1] === false);
                var connector;
                if (useBorder) {
                    connector = isLast ? '‚îî‚îÄ ' : '‚îú‚îÄ ';
                } else {
                    connector = '  ';
                }
                result = prefix + connector + icon + node.text + '\n';
            }

            // ---- Children ----
            for (var i = 0; i < node.children.length; i++) {
                var isLastChild = (i === node.children.length - 1);
                var newContinues = parentContinues.slice();
                newContinues.push(!isLastChild);
                result += generateCopyText(node.children[i], level + 1, newContinues, format, useBorder);
            }

            // ---- Separator blank line between sibling groups (border mode only) ----
            // Add a continuation-bar blank line after a node that has children,
            // if it is NOT the last sibling at its level and border mode is on.
            if (useBorder && level > 0 && node.children.length > 0) {
                var amILast = (parentContinues[level - 1] === false);
                if (!amILast) {
                    var sep = '';
                    for (var i = 0; i < level - 1; i++) {
                        sep += parentContinues[i] ? '‚îÇ  ' : '   ';
                    }
                    sep += '‚îÇ';
                    result += sep + '\n';
                }
            }
            return result;
        }

        // ========================================
        // Node Drag & Drop (Reparenting)
        // ========================================

        function startNodeDrag(nodeId, clientX, clientY, nodeEl) {
            if (nodeId === 'root') return;
            var startTime = Date.now();
            nodeDragState.didDrag = false;

            function onMouseMove(e) {
                var moved = Math.abs(e.clientX - clientX) > 5 || Math.abs(e.clientY - clientY) > 5;
                var elapsed = Date.now() - startTime;
                if (moved && elapsed > 150 && !nodeDragState.isDragging) {
                    nodeDragState.isDragging = true;
                    nodeDragState.didDrag = true;
                    nodeDragState.nodeId = nodeId;
                    if (selectedNodeIds.has(nodeId) && selectedNodeIds.size > 1) {
                        var ids = [];
                        selectedNodeIds.forEach(function(id) { if (id !== 'root') ids.push(id); });
                        nodeDragState.draggedNodeIds = ids;
                    } else {
                        nodeDragState.draggedNodeIds = [nodeId];
                    }
                    createDragGhost(nodeEl, e.clientX, e.clientY, nodeDragState.draggedNodeIds.length);
                    nodeDragState.draggedNodeIds.forEach(function(id) {
                        var el = document.querySelector('[data-id="' + id + '"]');
                        if (el) el.classList.add('dragging');
                    });
                }
                if (nodeDragState.isDragging) {
                    updateNodeDrag(e.clientX, e.clientY);
                }
            }

            function onMouseUp(e) {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                if (nodeDragState.isDragging) {
                    endNodeDrag();
                }
            }

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        function createDragGhost(nodeEl, clientX, clientY, count) {
            var existing = document.querySelector('.drag-ghost');
            if (existing) existing.remove();
            var ghost = nodeEl.cloneNode(true);
            ghost.classList.add('drag-ghost');
            ghost.classList.remove('selected', 'dragging');
            ghost.style.left = clientX + 'px';
            ghost.style.top = clientY + 'px';
            ghost.style.transform = 'translate(-50%, -50%)';
            ghost.style.position = 'fixed';
            ghost.style.width = nodeEl.offsetWidth + 'px';
            if (count > 1) {
                var badge = document.createElement('span');
                badge.style.cssText = 'position:absolute;top:-8px;right:-8px;background:#e53935;color:white;border-radius:50%;width:24px;height:24px;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:bold;';
                badge.textContent = count;
                ghost.appendChild(badge);
            }
            document.body.appendChild(ghost);
        }

        function updateNodeDrag(clientX, clientY) {
            if (!nodeDragState.isDragging) return;
            var ghost = document.querySelector('.drag-ghost');
            if (ghost) { ghost.style.left = clientX + 'px'; ghost.style.top = clientY + 'px'; }
            document.querySelectorAll('.node').forEach(function(el) {
                el.classList.remove('drag-over-child', 'drag-over-before', 'drag-over-after');
            });
            var target = getDropTarget(clientX, clientY);
            nodeDragState.targetNodeId = target ? target.nodeId : null;
            nodeDragState.targetPosition = target ? target.position : null;
            if (target) {
                var tEl = document.querySelector('[data-id="' + target.nodeId + '"]');
                if (tEl) tEl.classList.add('drag-over-' + target.position);
            }
        }

        function getDropTarget(clientX, clientY) {
            var elements = document.elementsFromPoint(clientX, clientY);
            var draggedIds = nodeDragState.draggedNodeIds || [nodeDragState.nodeId];
            for (var i = 0; i < elements.length; i++) {
                var el = elements[i];
                if (!el.classList.contains('node') || el.classList.contains('drag-ghost')) continue;
                var tid = el.dataset.id;
                if (draggedIds.indexOf(tid) >= 0) continue;
                var isDesc = false;
                for (var j = 0; j < draggedIds.length; j++) {
                    if (isDescendant(draggedIds[j], tid)) { isDesc = true; break; }
                }
                if (isDesc) continue;
                var rect = el.getBoundingClientRect();
                var relY = clientY - rect.top;
                var h = rect.height;
                if (tid === 'root') return { nodeId: tid, position: 'child' };
                if (relY < h * 0.25) return { nodeId: tid, position: 'before' };
                if (relY > h * 0.75) return { nodeId: tid, position: 'after' };
                return { nodeId: tid, position: 'child' };
            }
            return null;
        }

        function endNodeDrag() {
            if (!nodeDragState.isDragging) return;
            var ghost = document.querySelector('.drag-ghost');
            if (ghost) ghost.remove();
            document.querySelectorAll('.node').forEach(function(el) {
                el.classList.remove('dragging', 'drag-over-child', 'drag-over-before', 'drag-over-after');
            });
            if (nodeDragState.targetNodeId && nodeDragState.targetPosition) {
                moveNodes(
                    nodeDragState.draggedNodeIds || [nodeDragState.nodeId],
                    nodeDragState.targetNodeId,
                    nodeDragState.targetPosition
                );
            }
            nodeDragState.isDragging = false;
            nodeDragState.nodeId = null;
            nodeDragState.draggedNodeIds = null;
            nodeDragState.targetNodeId = null;
            nodeDragState.targetPosition = null;
            render();
        }

        function moveNodes(nodeIds, targetId, position) {
            if (!nodeIds || nodeIds.length === 0) return;
            var targetResult = findNode(targetId);
            if (!targetResult) return;
            var filtered = filterTopLevelNodes(nodeIds);
            if (filtered.length === 0) return;
            saveState();
            var nodesToMove = [];
            for (var i = 0; i < filtered.length; i++) {
                var nr = findNode(filtered[i]);
                if (nr && nr.parent) nodesToMove.push({ id: filtered[i], data: nr.node, parent: nr.parent, index: nr.index });
            }
            nodesToMove.sort(function(a, b) { return a.parent === b.parent ? b.index - a.index : 0; });
            for (var i = 0; i < nodesToMove.length; i++) {
                var cur = findNode(nodesToMove[i].id);
                if (cur && cur.parent) cur.parent.children.splice(cur.index, 1);
            }
            nodesToMove.reverse();
            if (position === 'child') {
                for (var i = 0; i < nodesToMove.length; i++) {
                    var tr = findNode(targetId);
                    if (tr) tr.node.children.push(nodesToMove[i].data);
                }
            } else if (position === 'before') {
                for (var i = 0; i < nodesToMove.length; i++) {
                    var tr = findNode(targetId);
                    if (tr && tr.parent) tr.parent.children.splice(tr.index, 0, nodesToMove[i].data);
                }
            } else if (position === 'after') {
                nodesToMove.reverse();
                for (var i = 0; i < nodesToMove.length; i++) {
                    var tr = findNode(targetId);
                    if (tr && tr.parent) tr.parent.children.splice(tr.index + 1, 0, nodesToMove[i].data);
                }
            }
            selectedNodeIds.clear();
            for (var i = 0; i < nodesToMove.length; i++) selectedNodeIds.add(nodesToMove[i].id);
            lastSelectedNodeId = nodesToMove[0] ? nodesToMove[0].id : null;
        }

        // ========================================
        // Lasso (Rectangle) Selection
        // ========================================

        function startLasso(clientX, clientY) {
            lassoState.active = true;
            lassoState.didSelect = false;
            lassoState.startX = clientX;
            lassoState.startY = clientY;
            lassoState.currentX = clientX;
            lassoState.currentY = clientY;
            var rect = document.getElementById('lassoRect');
            rect.style.display = 'block';
            rect.style.left = clientX + 'px';
            rect.style.top = clientY + 'px';
            rect.style.width = '0px';
            rect.style.height = '0px';
        }

        function updateLasso(clientX, clientY) {
            if (!lassoState.active) return;
            lassoState.currentX = clientX;
            lassoState.currentY = clientY;
            var x = Math.min(lassoState.startX, clientX);
            var y = Math.min(lassoState.startY, clientY);
            var w = Math.abs(clientX - lassoState.startX);
            var h = Math.abs(clientY - lassoState.startY);
            var rect = document.getElementById('lassoRect');
            rect.style.left = x + 'px';
            rect.style.top = y + 'px';
            rect.style.width = w + 'px';
            rect.style.height = h + 'px';
        }

        function endLasso() {
            if (!lassoState.active) return;
            lassoState.active = false;
            var rect = document.getElementById('lassoRect');
            rect.style.display = 'none';

            var x1 = Math.min(lassoState.startX, lassoState.currentX);
            var y1 = Math.min(lassoState.startY, lassoState.currentY);
            var x2 = Math.max(lassoState.startX, lassoState.currentX);
            var y2 = Math.max(lassoState.startY, lassoState.currentY);

            // Require minimum size to avoid treating clicks as lasso
            if (Math.abs(x2 - x1) < 8 && Math.abs(y2 - y1) < 8) return;

            clearSelection();
            document.querySelectorAll('.node').forEach(function(el) {
                var r = el.getBoundingClientRect();
                var cx = r.left + r.width / 2;
                var cy = r.top + r.height / 2;
                if (cx >= x1 && cx <= x2 && cy >= y1 && cy <= y2) {
                    selectedNodeIds.add(el.dataset.id);
                }
            });
            if (selectedNodeIds.size > 0) {
                lastSelectedNodeId = selectedNodeIds.values().next().value;
                updateSelectionDisplay();
                lassoState.didSelect = true;
                showToast(selectedNodeIds.size + 'ÂÄã„ÅÆ„Éé„Éº„Éâ„ÇíÈÅ∏Êäû„Åó„Åæ„Åó„Åü');
            }
        }

        // ========================================
        // Rendering
        // ========================================

        function render() {
            var container = document.getElementById('canvasInner');
            var svg = document.getElementById('linesSvg');
            container.querySelectorAll('.node').forEach(function(n) { n.remove(); });
            svg.innerHTML = '';

            // Pass 1: Measure actual node dimensions by creating temporary elements
            var nodeDims = measureNodeDimensions(mindMapData.root, container);

            // Pass 2: Layout with actual dimensions
            var positions = {};
            layoutNodes(mindMapData.root, positions, 0, 0, 1, nodeDims);

            // Pass 3: Render nodes and lines
            renderNodes(mindMapData.root, container, positions);
            renderLines(mindMapData.root, svg, positions);
            updateSelectionDisplay();
            updateView();
            // Auto-save to localStorage after every render (post-mutation state)
            saveToLocalStorage();
        }

        // Measure actual rendered width AND height of each node's text
        function measureNodeDimensions(rootNode, container) {
            var dims = {};
            // Create a measurer that exactly mirrors the .node DOM structure
            var measurer = document.createElement('div');
            measurer.className = 'node';
            measurer.style.position = 'absolute';
            measurer.style.visibility = 'hidden';
            measurer.style.pointerEvents = 'none';
            // Don't set transform since we just need dimensions
            var measurerText = document.createElement('span');
            measurerText.className = 'node-text';
            measurer.appendChild(measurerText);
            container.appendChild(measurer);

            function measure(node) {
                // Render \n as <br> for accurate measurement
                if (node.text.indexOf('\n') >= 0) {
                    measurerText.innerHTML = node.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
                } else {
                    measurerText.textContent = node.text;
                }
                // Root nodes have larger font
                if (node.id === 'root') {
                    measurer.classList.add('root');
                } else {
                    measurer.classList.remove('root');
                }
                dims[node.id] = { width: measurer.offsetWidth, height: measurer.offsetHeight };
                for (var i = 0; i < node.children.length; i++) {
                    measure(node.children[i]);
                }
            }
            measure(rootNode);
            container.removeChild(measurer);
            return dims;
        }

        function layoutNodes(node, positions, x, y, level, nodeDims) {
            if (x === undefined) x = 0;
            if (y === undefined) y = 0;
            if (level === undefined) level = 1;
            var dims = (nodeDims && nodeDims[node.id]) ? nodeDims[node.id] : { width: 150, height: 40 };
            var nodeWidth = dims.width;
            var nodeHeight = dims.height;
            var hGap = 40, vGap = 16;
            positions[node.id] = { x: x, y: y, width: nodeWidth, height: nodeHeight, level: level };

            // If collapsed, don't layout children
            if (collapsedNodeIds.has(node.id)) return positions;

            var totalH = 0, childHeights = [];
            for (var i = 0; i < node.children.length; i++) {
                var ch = calcSubtreeHeight(node.children[i], vGap, nodeDims);
                childHeights.push(ch);
                totalH += ch;
            }
            if (node.children.length > 1) totalH += (node.children.length - 1) * vGap;
            var childX = x + nodeWidth + hGap;
            var childY = y - totalH / 2;
            for (var i = 0; i < node.children.length; i++) {
                var ch = childHeights[i];
                var centerY = childY + ch / 2;
                layoutNodes(node.children[i], positions, childX, centerY, level + 1, nodeDims);
                childY += ch + vGap;
            }
            return positions;
        }

        function calcSubtreeHeight(node, gap, nodeDims) {
            var dims = (nodeDims && nodeDims[node.id]) ? nodeDims[node.id] : { width: 150, height: 40 };
            var nodeHeight = dims.height;
            // If collapsed, only this node's height matters
            if (collapsedNodeIds.has(node.id) || node.children.length === 0) return nodeHeight;
            var total = 0;
            for (var i = 0; i < node.children.length; i++) {
                total += calcSubtreeHeight(node.children[i], gap, nodeDims);
            }
            total += (node.children.length - 1) * gap;
            return Math.max(nodeHeight, total);
        }

        function renderNodes(node, container, positions) {
            var pos = positions[node.id];
            if (!pos) return;
            var el = document.createElement('div');
            el.className = 'node' + (node.id === 'root' ? ' root' : '');
            el.dataset.id = node.id;
            el.style.left = pos.x + 'px';
            el.style.top = pos.y + 'px';
            el.style.width = pos.width + 'px';
            el.style.transform = 'translateY(-50%)';
            var textEl = document.createElement('span');
            textEl.className = 'node-text';
            // Render \n as <br> for display
            if (node.text.indexOf('\n') >= 0) {
                textEl.innerHTML = node.text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
            } else {
                textEl.textContent = node.text;
            }
            el.appendChild(textEl);

            // Use a closure to capture node reference
            (function(nodeData, nodeElement) {

                // Click handler: default to editing mode
                nodeElement.addEventListener('click', function(e) {
                    e.stopPropagation();

                    // If a drag just occurred, suppress click
                    if (nodeDragState.didDrag) {
                        nodeDragState.didDrag = false;
                        return;
                    }

                    var isMac = /Mac/.test(navigator.platform);
                    var cmdKey = isMac ? e.metaKey : e.ctrlKey;

                    if (cmdKey && e.shiftKey) {
                        finishEditing();
                        var allNodes = getAllNodesInOrder();
                        var si = -1, ei = -1;
                        for (var i = 0; i < allNodes.length; i++) {
                            if (allNodes[i].id === lastSelectedNodeId) si = i;
                            if (allNodes[i].id === nodeData.id) ei = i;
                        }
                        if (si !== -1 && ei !== -1) {
                            var mn = Math.min(si, ei), mx = Math.max(si, ei);
                            for (var i = mn; i <= mx; i++) selectedNodeIds.add(allNodes[i].id);
                            lastSelectedNodeId = nodeData.id;
                            updateSelectionDisplay();
                        }
                    } else if (e.shiftKey) {
                        finishEditing();
                        toggleSelectNode(nodeData.id);
                    } else if (cmdKey) {
                        finishEditing();
                        toggleSelectNode(nodeData.id);
                    } else {
                        // Normal click -> enter edit mode directly
                        if (editingNodeId === nodeData.id) return;
                        finishEditing();
                        selectNode(nodeData.id);
                        startEditing(nodeData.id);
                    }
                });

                // Double-click: enter edit mode (for when already selected but not editing)
                nodeElement.addEventListener('dblclick', function(e) {
                    e.stopPropagation();
                    startEditing(nodeData.id);
                });

                // Mousedown: start potential drag (only left button, no modifiers, not editing)
                nodeElement.addEventListener('mousedown', function(e) {
                    if (e.button !== 0) return;
                    if (editingNodeId) return;
                    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
                    e.preventDefault();
                    e.stopPropagation();
                    startNodeDrag(nodeData.id, e.clientX, e.clientY, nodeElement);
                });

            })(node, el);

            // Add collapse/expand toggle for parent nodes
            if (node.children.length > 0) {
                var isCollapsed = collapsedNodeIds.has(node.id);
                var toggleBtn = document.createElement('span');
                toggleBtn.className = 'collapse-toggle';
                toggleBtn.textContent = isCollapsed ? '‚ñ∂' : '‚ñº';
                toggleBtn.title = isCollapsed ? 'Â±ïÈñã (Cmd+.)' : 'Êäò„Çä„Åü„Åü„Åø (Cmd+.)';
                toggleBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    toggleCollapse(node.id);
                });
                toggleBtn.addEventListener('mousedown', function(e) {
                    e.stopPropagation();
                });
                el.appendChild(toggleBtn);

                // Show child count badge when collapsed
                if (isCollapsed) {
                    var count = countDescendants(node);
                    var badge = document.createElement('span');
                    badge.className = 'collapse-badge';
                    badge.textContent = '+' + count;
                    el.appendChild(badge);
                }
            }

            container.appendChild(el);

            // Only render children if not collapsed
            if (!collapsedNodeIds.has(node.id)) {
                for (var i = 0; i < node.children.length; i++) {
                    renderNodes(node.children[i], container, positions);
                }
            }
        }

        function renderLines(node, svg, positions) {
            var pp = positions[node.id];
            if (!pp) return;
            // If collapsed, don't draw lines to hidden children
            if (collapsedNodeIds.has(node.id)) return;
            var off = 5000;
            for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];
                var cp = positions[child.id];
                if (!cp) continue;
                var sx = pp.x + pp.width + off, sy = pp.y + off;
                var ex = cp.x + off, ey = cp.y + off;
                var mx = sx + (ex - sx) / 2;
                var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'M ' + sx + ' ' + sy + ' C ' + mx + ' ' + sy + ', ' + mx + ' ' + ey + ', ' + ex + ' ' + ey);
                path.setAttribute('class', 'connection-line');
                svg.appendChild(path);
                renderLines(child, svg, positions);
            }
        }

        // ========================================
        // View Controls
        // ========================================

        function updateView() {
            var inner = document.getElementById('canvasInner');
            inner.style.transform = 'translate(' + viewState.panX + 'px, ' + viewState.panY + 'px) scale(' + viewState.zoom + ')';
        }

        function resetView() {
            var container = document.getElementById('canvasContainer');
            viewState.zoom = 1;
            viewState.panX = container.clientWidth / 2 - 75;
            viewState.panY = container.clientHeight / 2;
            updateView();
        }

        // ========================================
        // Keyboard Handler
        // ========================================

        function handleKeyDown(e) {
            var isMac = /Mac/.test(navigator.platform);
            var cmdKey = isMac ? e.metaKey : e.ctrlKey;

            // While editing
            if (editingNodeId) {
                // IMEÂÖ•Âäõ‰∏≠Ôºà„É≠„Éº„ÉûÂ≠ó‚ÜíÊó•Êú¨Ë™ûÂ§âÊèõÔºâ„ÅÆ„Ç≠„Éº„ÅØÁÑ°Ë¶ñ„Åô„Çã
                if (e.isComposing || e.keyCode === 229) return;

                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    finishEditing();
                } else if (e.key === 'Enter' && e.shiftKey) {
                    // Shift+Enter: insert line break
                    e.preventDefault();
                    var sel = window.getSelection();
                    if (sel.rangeCount) {
                        var range = sel.getRangeAt(0);
                        range.deleteContents();
                        var br = document.createElement('br');
                        range.insertNode(br);
                        // Insert a zero-width space after <br> so cursor has a text node to land in
                        var textNode = document.createTextNode('\u200B');
                        br.parentNode.insertBefore(textNode, br.nextSibling);
                        // Move cursor into the text node after <br>
                        range = document.createRange();
                        range.setStart(textNode, 1);
                        range.setEnd(textNode, 1);
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    finishEditing();
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    finishEditing();
                    if (e.shiftKey) { goToParent(); }
                    else { var cid = getSelectedNodeId(); if (cid) addChildNode(cid); }
                } else if (cmdKey && (e.key === 'z' || e.key === 'Z')) {
                    e.preventDefault(); finishEditing(); undo();
                } else if (cmdKey && (e.key === 'y' || e.key === 'Y')) {
                    e.preventDefault(); finishEditing(); redo();
                }
                return;
            }

            var currentId = getSelectedNodeId();

            switch (e.key) {
                case 'Enter':
                    e.preventDefault();
                    if (currentId) addSiblingNode(currentId);
                    break;
                case 'Tab':
                    e.preventDefault();
                    if (e.shiftKey) goToParent();
                    else if (currentId) addChildNode(currentId);
                    break;
                case 'Delete':
                case 'Backspace':
                    e.preventDefault();
                    if (selectedNodeIds.size > 1) deleteSelectedNodes();
                    else if (currentId && currentId !== 'root') deleteNode(currentId);
                    break;
                case 'F2':
                    e.preventDefault();
                    if (currentId) startEditing(currentId);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    if (cmdKey) { if (currentId) moveNodeUp(currentId); }
                    else navigateUp();
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (cmdKey) { if (currentId) moveNodeDown(currentId); }
                    else navigateDown();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (cmdKey) { if (currentId) promoteNode(currentId); }
                    else navigateLeft();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (cmdKey) { if (currentId) demoteNode(currentId); }
                    else navigateRight();
                    break;
                case 'z': case 'Z':
                    if (cmdKey) { e.preventDefault(); undo(); }
                    break;
                case 'y': case 'Y':
                    if (cmdKey) { e.preventDefault(); redo(); }
                    break;
                case 'a': case 'A':
                    if (cmdKey) { e.preventDefault(); selectAll(); }
                    break;
                case 'c': case 'C':
                    if (cmdKey) { e.preventDefault(); copySelectedNodes(); }
                    break;
                case 'v': case 'V':
                    if (cmdKey) { e.preventDefault(); pasteNode(); }
                    break;
                case 'x': case 'X':
                    if (cmdKey) { e.preventDefault(); cutSelectedNodes(); }
                    break;
                case 'Escape':
                    clearSelection();
                    break;
                case '.': case '/':
                    if (cmdKey) {
                        e.preventDefault();
                        if (currentId) toggleCollapse(currentId);
                    }
                    break;
            }
        }

        // ========================================
        // Canvas Interaction: Pan, Zoom, Lasso
        // ========================================

        function initCanvasInteraction() {
            var canvas = document.getElementById('canvas');

            // --- Mousedown ---
            canvas.addEventListener('mousedown', function(e) {
                if (nodeDragState.isDragging) return;

                var isBackground = (e.target === canvas ||
                    e.target.id === 'canvasInner' ||
                    e.target.tagName === 'svg' ||
                    e.target.classList.contains('lines-svg'));

                if (!isBackground) return;

                // Right-click or middle-click: pan
                if (e.button === 2 || e.button === 1) {
                    e.preventDefault();
                    viewState.isPanning = true;
                    viewState.startX = e.clientX - viewState.panX;
                    viewState.startY = e.clientY - viewState.panY;
                    canvas.classList.add('panning');
                    return;
                }

                // Left-click on background: start lasso
                if (e.button === 0) {
                    finishEditing();
                    startLasso(e.clientX, e.clientY);
                }
            });

            // --- Mousemove ---
            canvas.addEventListener('mousemove', function(e) {
                if (nodeDragState.isDragging) return;
                if (viewState.isPanning) {
                    viewState.panX = e.clientX - viewState.startX;
                    viewState.panY = e.clientY - viewState.startY;
                    updateView();
                    return;
                }
                if (lassoState.active) {
                    updateLasso(e.clientX, e.clientY);
                }
            });

            // --- Mouseup ---
            canvas.addEventListener('mouseup', function(e) {
                if (viewState.isPanning) {
                    viewState.isPanning = false;
                    canvas.classList.remove('panning');
                    return;
                }
                if (lassoState.active) {
                    endLasso();
                }
            });

            // --- Click on background: clear selection ---
            canvas.addEventListener('click', function(e) {
                var isBackground = (e.target === canvas ||
                    e.target.id === 'canvasInner' ||
                    e.target.tagName === 'svg' ||
                    e.target.classList.contains('lines-svg'));

                if (!isBackground) return;

                // Don't clear if lasso just selected nodes
                if (lassoState.didSelect) {
                    lassoState.didSelect = false;
                    return;
                }
                finishEditing();
                clearSelection();
            });

            // --- Mouseleave ---
            canvas.addEventListener('mouseleave', function() {
                if (viewState.isPanning) {
                    viewState.isPanning = false;
                    canvas.classList.remove('panning');
                }
                if (lassoState.active) endLasso();
                if (nodeDragState.isDragging) endNodeDrag();
            });

            // --- Context menu prevention ---
            canvas.addEventListener('contextmenu', function(e) {
                e.preventDefault();
            });

            // --- Wheel: zoom (mouse scroll wheel) / pan (trackpad 2-finger) ---
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                var container = document.getElementById('canvasContainer');
                var rect = container.getBoundingClientRect();
                var mouseX = e.clientX - rect.left;
                var mouseY = e.clientY - rect.top;

                // ctrlKey is set by browser during trackpad pinch gesture
                if (e.ctrlKey) {
                    // Pinch zoom
                    var zoomDelta = -e.deltaY * 0.01;
                    applyZoom(mouseX, mouseY, zoomDelta);
                    return;
                }

                // Trackpad 2-finger scroll ‚Üí pan
                // Mouse scroll wheel ‚Üí zoom (deltaMode = 1 for line-based, or large deltaY)
                if (e.deltaMode === 0 && (Math.abs(e.deltaX) > 1 || Math.abs(e.deltaY) < 80)) {
                    // Likely trackpad: pan
                    viewState.panX -= e.deltaX;
                    viewState.panY -= e.deltaY;
                    updateView();
                } else {
                    // Mouse scroll wheel: zoom
                    var zoomDelta = e.deltaY > 0 ? -0.1 : 0.1;
                    applyZoom(mouseX, mouseY, zoomDelta);
                }
            }, { passive: false });

            // --- Touch events for pinch-zoom ---
            var lastTouchDist = 0;
            var lastTouchCenter = { x: 0, y: 0 };

            canvas.addEventListener('touchstart', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    var t1 = e.touches[0], t2 = e.touches[1];
                    lastTouchDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                    lastTouchCenter = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault();
                    var t1 = e.touches[0], t2 = e.touches[1];
                    var dist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                    var center = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
                    var scale = dist / lastTouchDist;
                    var oldZoom = viewState.zoom;
                    var newZoom = Math.max(0.2, Math.min(3, oldZoom * scale));
                    var actualScale = newZoom / oldZoom;
                    viewState.panX = center.x - actualScale * (center.x - viewState.panX);
                    viewState.panY = center.y - actualScale * (center.y - viewState.panY);
                    viewState.zoom = newZoom;
                    viewState.panX += center.x - lastTouchCenter.x;
                    viewState.panY += center.y - lastTouchCenter.y;
                    lastTouchDist = dist;
                    lastTouchCenter = center;
                    updateView();
                }
            }, { passive: false });
        }

        function applyZoom(mouseX, mouseY, zoomDelta) {
            var oldZoom = viewState.zoom;
            var newZoom = Math.max(0.2, Math.min(3, oldZoom + zoomDelta));
            var scale = newZoom / oldZoom;
            viewState.panX = mouseX - scale * (mouseX - viewState.panX);
            viewState.panY = mouseY - scale * (mouseY - viewState.panY);
            viewState.zoom = newZoom;
            updateView();
        }

        // ========================================
        // Initialization
        // ========================================

        function init() {
            // Show map ID badge (hide if default)
            if (MAP_ID !== 'default') {
                document.getElementById('mapIdBadge').textContent = '\uD83D\uDCCC ' + MAP_ID;
            }
            // Restore from localStorage if available
            var saved = loadFromLocalStorage();
            if (saved) {
                mindMapData = saved;
            }
            saveState();
            document.addEventListener('keydown', handleKeyDown);
            initCanvasInteraction();
            document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
            document.getElementById('resetBtn').addEventListener('click', resetMindMap);
            document.getElementById('previewBtn').addEventListener('click', showPreview);
            document.getElementById('previewCopyBtn').addEventListener('click', function() {
                copyToClipboard();
            });
            document.getElementById('previewCloseBtn').addEventListener('click', hidePreview);
            document.getElementById('previewOverlay').addEventListener('click', function(e) {
                if (e.target === this) hidePreview();
            });
            // Update preview in real-time when dropdowns change while preview is open
            document.getElementById('copyFormat').addEventListener('change', function() {
                if (document.getElementById('previewOverlay').classList.contains('show')) showPreview();
            });
            document.getElementById('copyBorder').addEventListener('change', function() {
                if (document.getElementById('previewOverlay').classList.contains('show')) showPreview();
            });
            resetView();
            render();
            selectNode('root');
            // Start editing root on first load
            setTimeout(function() { startEditing('root'); }, 100);
        }

        document.addEventListener('DOMContentLoaded', init);

        // Expose for testing/integration
        window.getCurrentCopyText = getCurrentCopyText;
        window.toggleCollapse = toggleCollapse;
        window.collapsedNodeIds = collapsedNodeIds;
        window.getSelectedNodeIds = function() { return selectedNodeIds; };
        window.getMindMapData = function() { return mindMapData; };

    })();
    </script>
</body>
</html>
